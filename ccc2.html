<!DOCTYPE html>
<html theme=dark>
<body>
<base href="www2/">
<link rel="preload" href="fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="fa-solid-900.woff2"   as="font" type="font/woff2" crossorigin>
<script src=glue.js global extend></script>
<script src=ui.js></script>
<script src=ui_validation.js></script>
<script src=ui_nav.js></script>
<script src=ui_grid.js></script>
<script>

/* THE WALLS MODEL
------------------------------------------------------------------------------

A wall-run is an array of straight walls end-to-end connected implicitly at
90 degrees (we can't have walls at any angle or curved walls in this model).
The first wall can be horizontal (default) or vertical.

A wall has a main axis and a cross axis. A wall specifies only the coordinate
on the main-axis of its second end-point (in the field "to"), which is its
x-coord if the wall is horizontal, or its y-coord if it's vertical. To get
a wall's (x1,y1) and (x2,y2) you have to look at the neighboring walls.

A wall-run can be open or closed. When closed, the last wall implicitly
connects to the first. When open, the last two walls are invisible and only
serve to complete the coordinates of the first wall. All wall-runs must have
an even number of walls.

A wall-run has a thickness which creates a parallel edge at an offset.
The offset can be positive or negative. A positive offset creates the offset
edge to the left of the wall's edge seen as a vector.

An open wall-run can butt-joint a wall, or it can end-joint another open wall-run.
A closed wall-run that flows clockwise with a positive offset creates its offset
edge on the outside. This is how exterior walls are modeled so that changing
the wall thickness preserves interior space.

*/

let EPSILON = 1e-5

function near(a, b) { return abs(a - b) < EPSILON }

function wall_vert(wr, i) { return ((wr.vertical ? 1 : 0) + i) & 1 }

// capital X means wall's main axis, Y means cross axis.
// for horizontal walls X is x and Y is y, for vertical walls X is y and Y is x.
function wall_X1(wr, i) { return wr.walls[mod(i-2, wr.walls.length)].to }
function wall_X2(wr, i) { return wr.walls[mod(i-0, wr.walls.length)].to }
function wall_Y (wr, i) { return wr.walls[mod(i-1, wr.walls.length)].to }

function wall_set_X1(wr, i, v) { wr.walls[mod(i-2, wr.walls.length)].to = v }
function wall_set_X2(wr, i, v) { wr.walls[mod(i-0, wr.walls.length)].to = v }
function wall_set_Y (wr, i, v) { wr.walls[mod(i-1, wr.walls.length)].to = v }

function wall_x1(wr, i) { return wr.walls[mod(i-2+wall_vert(wr, i), wr.walls.length)].to }
function wall_y1(wr, i) { return wr.walls[mod(i-1-wall_vert(wr, i), wr.walls.length)].to }
function wall_x2(wr, i) { return wr.walls[mod(i-0-wall_vert(wr, i), wr.walls.length)].to }
function wall_y2(wr, i) { return wr.walls[mod(i-1+wall_vert(wr, i), wr.walls.length)].to }

// wall's main axis unit vector: positive when pointing to right and down.
function wall_sign(wr, i) {
	let a = wr.walls
	let n = a.length
	let iX1 = mod(i-2, n)
	let iX2 = mod(i-0, n)
	return sign(a[iX2].to - a[iX1].to)
}

// wall's normal vector: wall's _|_ unit vector pointing to the left of the
// wall's main axis vector.
function wall_offset_sign(wr, i) {
	let v = wall_vert(wr, i)
	let s = wall_sign(wr, i)
	return v ? s : -s
}

// wall's starting point as (x, y).
// oY is the offset on the wall's cross axis (true = thickness).
// oX is the offset on the wall's main axis (optional).
function wall_p1(wr, i, oY, oX) {
	let p = [
		wall_x1(wr, i),
		wall_y1(wr, i)
	]
	if (!(oY || oX))
		return p
	if (oY === true)
		oY = wr.thickness * (wr.offset_sign ?? 1)
	let v1 = wall_vert(wr, i)
	let s1 = wall_sign(wr, i)
	let s0 = wall_sign(wr, i-1)
	if (oX === undefined) {
		oX = oY
		if (!wr.closed) {
			let n = wr.walls.length
			i = mod(i, n)
			if (i == 0 || i == n-2) // wall-run's ends are cut straight.
				oX = 0
			if (i == n-2) // use starting point's orientation for the end point.
				v1 = 1-v1
		}
	}
	let sx = 0
	let sy = 0
	if (s1 == s0) {
		sx =  s1
		sy = -s1
	} else {
		sx = (s1 < s0) == v1 ? -1 : 1
		sy = sx
	}
	let ox = v1 ? oY : oX
	let oy = v1 ? oX : oY
	p[0] += sx * ox
	p[1] += sy * oy
	return p
}

function wall_line_XY(wr, i, oY, oX) {
	let [x1, y1] = wall_p1(wr, i+0, oY, oX)
	let [x2, y2] = wall_p1(wr, i+1, oY, oX)
	if (wall_vert(wr, i))
		return [y1, y2, x1]
	else
		return [x1, x2, y1]
}

function wall_end_XY(wr, first, oY, oX) {
	assert(!wr.closed)
	let i = first ? 0 : wr.walls.length-2
	let [x, y] = wall_p1(wr, i, oY, oX)
	if (wall_vert(wr, first ? i : i-1))
		return [y, x]
	else
		return [x, y]
}

function overlap_segs(_a1, _a2, _b1, _b2) {
	let a1 = min(_a1, _a2)
	let a2 = max(_a1, _a2)
	let b1 = min(_b1, _b2)
	let b2 = max(_b1, _b2)
	return !(a2 <= b1 || b2 <= a1)
}

// points are in polygon order, but lines are in offset sign order i.e. first
// the left line then the right, first the top line then the bottom.
function wall_lines(wr, i, o) {
	let p1  = wall_p1(wr, i+0)
	let p2  = wall_p1(wr, i+1)
	let op1 = wall_p1(wr, i+0, o ?? true)
	let op2 = wall_p1(wr, i+1, o ?? true)
	if (wall_offset_sign(wr, i) < 0)
		return [op1, op2, p1, p2]
	else
		return [p1, p2, op1, op2]
}

function wall_rect(wr, i, o) { // returns (x1, y1, x2, y2), not (x, y, w, h)
	let p1  = wall_p1(wr, i+0)
	let p2  = wall_p1(wr, i+1)
	let op1 = wall_p1(wr, i+0, o ?? true)
	let op2 = wall_p1(wr, i+1, o ?? true)
	let v   = wall_vert (wr, i)
	let X = v ? 1 : 0
	let Y = v ? 0 : 1
	let r = [0, 0, 0, 0]
	r[X+0] = min(p1[X], op1[X], p2[X], op2[X])
	r[X+2] = max(p1[X], op1[X], p2[X], op2[X])
	r[Y+0] = min(p1[Y], op1[Y])
	r[Y+2] = max(p1[Y], op1[Y])
	return r
}

function wall_joints(plan, wr, i) {
	let v  = wall_vert        (wr, i)
	let os = wall_offset_sign (wr, i)
	let joints = []
	for (let bwr of plan.wall_runs) {
		if (bwr.closed) // has no free ends
			continue
		// test for butt-joints
		let ba = bwr.walls
		for (let first = -1; first <= 0; first++) { // test both wall-run ends
			let bi = first ? 0 : ba.length-3 // index of first or last wall-run end
			let bv = wall_vert(bwr, bi)
			if (bv != v) { // _|_
				let [bmpX, bmpY] = wall_end_XY(bwr, first)
				let [bopX, bopY] = wall_end_XY(bwr, first, true)
				let bs = wall_sign(bwr, bi)
				// the first wall-run-end butt-joints to the wall's main edge
				// if it goes opposite to the wall's offset normal, and it
				// butt-joints to the wall's offset edge if it goes in the same
				// direction as the wall's offset normal. And it's the opposite
				// for the last wall-run-end.
				let butt_to_main_edge = first ? bs == -os : bs == os
				let [pX1, pX2, pY] = wall_line_XY(wr, i, !butt_to_main_edge)
				if (near(bmpX, pY)) { // butt-end's main axis == butted-edge's cross axis
					let bY1 = min(bmpY, bopY)
					let bY2 = max(bmpY, bopY)
					if (bY1 >= pX1 && bY2 <= pX2) { // butt-end is fully in front of butted-edge
						joints.push({
							type: 'butt',
							wall_run: bwr,
							wall: i,
							to_main_edge: butt_to_main_edge,
						})
					}
				}
			}
		}
	}
	return joints
}

function aligned_walls(plan, wr, i) {
	//
}

let comp = {}

comp.opening = {}

comp.opening.plan_rect = function(e, wr, i) {
	let t = wr.thickness ?? 5
	let r = [e.sx, e.sy || 0, e.w, t, 0]
	if (i != null) {
		let p1   = wall_p1          (wr, i)
		let vert = wall_vert        (wr, i)
		let dir  = wall_sign        (wr, i)
		let odir = wall_offset_sign (wr, i)
		let X = vert ? 1 : 0
		let Y = vert ? 0 : 1
		r[X] = p1[X] + (dir > 0 ? e.d : -(e.d + e.w))
		r[Y] = p1[Y] + (odir > 0 ? 0 : -t)
		if (vert) {
			r[4] = 90 * rad
			r[0] += t
		}
	}
	return r
}

comp.opening.face_rect = function(e, wr, i) {
	let t = wr.thickness
	let r = [e.x, wr.h - e.h - (e.y || 0), e.w, e.h]
	if (i != null) {
		let p1   = wall_p1          (wr, i)
		let vert = wall_vert        (wr, i)
		let dir  = wall_sign        (wr, i)
		let odir = wall_offset_sign (wr, i)
		let X = vert
		let Y = 1-vert
		r[0] = p1[X] + (dir > 0 ? e.d : -(e.d + e.w))
	}
	return r
}

function moving_ranges(plan, wr, ti1) {
	let a = wr.walls
	let n = a.length
	let ti0 = mod(ti1-1, n)
	let ti2 = mod(ti1+1, n)
	let p1 = wall_p1(wr, ti1)
	let p2 = wall_p1(wr, ti2)
	let v  = wall_vert (wr, ti1)
	let X = v ? 1 : 0
	let Y = v ? 0 : 1
	let tl = wall_lines(wr, ti1)

	// collision with other walls
	let rangeY = [-1/0, 1/0]
	for (let wr1 of plan.wall_runs) {
		let a = wr1.walls
		let n = a.length
		let o = wr1.thickness
		for (let i1 = 0; i1 < n; i1++) {
			if (wr1 == wr && (i1 == ti1 || i1 == ti0 || i1 == ti2))
				continue
			let r = wall_rect(wr1, i1)

			if (r[Y+2] <= tl[0][Y]) // rect bottom side < top of the wall
				if (overlap_segs(tl[0][X], tl[1][X], r[X], r[X+2])) {
					let minY = r[Y+2]
					if (tl[0][Y] < p1[Y]) // offset side up
						minY += o
					rangeY[0] = max(rangeY[0], minY)
				}

			if (r[Y+0] >= tl[2][Y]) // rect top side > bottom of the wall
				if (overlap_segs(tl[2][X], tl[3][X], r[X], r[X+2])) {
					let maxY = r[Y+0]
					if (tl[2][Y] > p1[Y]) // offset side down
						maxY -= o
					rangeY[1] = min(rangeY[1], maxY)
				}

		}
	}
	return [rangeY]
}

function begin_closed_wall_path(cx, wr, o) {

	let n = wr.walls.length

	cx.beginPath()

	// draw offset path clockwise.
	for (let i = 0; i < n; i++) {
		let [x, y] = wall_p1(wr, i, o ?? true)
		if (i == 0)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()

	// draw main (inner) path counterclockwise.
	for (let i = n-1; i >= 0; i--) {
		let x = wall_x1(wr, i)
		let y = wall_y1(wr, i)
		if (i == n-1)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()
}

function begin_open_wall_path(cx, wr, o) {

	let n = wr.walls.length-1

	cx.beginPath()

	// draw non-offset path.
	for (let i = 0; i < n; i++) {
		let [x, y] = wall_p1(wr, i)
		if (i == 0)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}

	// draw offset path in reverse.
	for (let i = n-1; i >= 0; i--) {
		let [x, y] = wall_p1(wr, i, o ?? true)
		cx.lineTo(x, y)
	}

	cx.closePath()
}

function begin_wall_path(cx, wr, o) {
	if (wr.closed)
		begin_closed_wall_path(cx, wr, o)
	else
		begin_open_wall_path(cx, wr, o)
}

function draw_wall_openings(cx, wr, hs) {
	let i = -1
	for (let wall of wr.walls) {
		i++
		if (wall.openings) {
			for (let op of wall.openings) {
				let [x, y, w, h, rotation] = comp.opening.plan_rect(op, wr, i)

				cx.save()
				cx.translate(x, y)
				cx.rotate(rotation)

				cx.beginPath()
				cx.rect(0, 0, w, h)
				cx.fillStyle = ui.bg_color('bg')
				cx.fill()

				if (op.type == 'window') {
					cx.beginPath()
					cx.rect(.5, .5 - 4.5, w, h + 4.5)
					cx.moveTo(    .5, round(h / 3) - .5)
					cx.lineTo(w - .5, round(h / 3) - .5)
				} else if (op.type == 'door') {
					cx.beginPath()
					cx.arc(.5, round(h / 2) + .5, w - .5, 0, (op.swing ?? 90) * rad)
					cx.lineTo(.5, round(h / 2) - .5)
				}
				cx.strokeStyle = ui.fg_color('text', hs && hs.get('opening') == op ? 'hover' : null)
				cx.stroke()

				cx.restore()
			}
		}
	}
}

function draw_walls(cx, plan, storey, hs) {

	// draw walls
	for (let wr of plan.wall_runs) {
		if ((wr.storey ?? 1) != (storey ?? 1))
			continue

		begin_wall_path(cx, wr)

		//cx.lineWidth = 1
		// cx.strokeStyle = ui.fg_color('text')
		// cx.stroke()
		cx.fillStyle = ui.bg_color('bg3')
		cx.fill()

		draw_wall_openings(cx, wr, hs)

	}
}

function draw_facade(cx, plan, vert, sign, hs) {

	// sort walls by depth.
	let walls = []
	for (let wr of plan.wall_runs) {
		if (!wr.exterior)
			continue
		for (let i = 0, n = wr.walls.length; i < n; i++) {
			if (wall_vert(wr, i) != vert)
				continue
			if (wall_sign(wr, i) != sign)
				continue
			walls.push([wr, i])
		}
	}
	walls.sort(function(e1, e2) {
		let y1 = wall_Y(e1[0], e1[1])
		let y2 = wall_Y(e2[0], e2[1])
		return y1 < y2 ? sign : y1 > y2 ? -sign : 0
	})

	// draw walls (offset face) in depth order.
	let X = vert ? 1 : 0
	let Y = vert ? 0 : 1
	for (let [wr, i] of walls) {
		let p1 = wall_p1(wr, i+0, true)
		let p2 = wall_p1(wr, i+1, true)
		let x1 = p1[X]
		let x2 = p2[X]
		let x = min(x1, x2)
		let w = max(x1, x2) - x
		let y = p1[Y]
		let h = wr.h

		cx.beginPath()
		cx.rect(x, 0, w, h)
		cx.fillStyle = ui.hsl_adjust(ui.bg_color_hsl('bg3'), 1, 1, p1[Y] / 500)
		cx.fill()

		cx.beginPath()
		cx.rect(x + .5, .5, w, h)
		cx.strokeStyle = ui.fg_color('text')
		cx.stroke()

		// draw openings.
		let wall = wr.walls[i]
		let ops = wall.openings
		if (ops) {
			for (let op of ops) {

				let [x, y, w, h] = comp.opening.face_rect(op, wr, i)

				cx.save()
				cx.translate(x, y)

				cx.beginPath()
				cx.rect(0, 0, w, h)
				cx.fillStyle = ui.bg_color('bg')
				cx.fill()

				if (op.type == 'window') {
					cx.beginPath()
					cx.rect(.5, .5, w, h)
				} else if (op.type == 'door') {
					cx.beginPath()
					cx.rect(.5, .5, w, h)
				}
				cx.strokeStyle = ui.fg_color('text', hs && hs.get('opening') == op ? 'hover' : null)
				cx.stroke()

				cx.restore()
			}
		}

	}

}

function hit_opening(wr, x00, y00, id) {
	let i = -1
	for (let wall of wr.walls) {
		i++
		if (!wall.openings)
			continue
		for (let op of wall.openings) {
			let [x, y, w, h, rotation] = comp.opening.plan_rect(op, wr, i)

			let cx = ui.cx
			cx.save()
			cx.translate(x00 + x, y00 + y)
			cx.rotate(rotation)
			ui.update_mouse()
			let hit = ui.hit_rect(- 5, - 5, w + 10, h + 10)
			cx.restore()
			ui.update_mouse()

			if (hit) {
				let hs = ui.hover(id)
				hs.set('opening', op)
				return true
			}
		}
	}
}

function hit_walls(wr, x00, y00, id) {
	for (let i = 0, n = wr.walls.length; i < n; i++) {
		let x  = x00 + wall_x1(wr, i)
		let y  = y00 + wall_y1(wr, i)
		let x2 = x00 + wall_x2(wr, i)
		let y2 = y00 + wall_y2(wr, i)
		let h = y2 == y
		if (
			(!h && abs(ui.mx - x) < 5 && ui.my >= min(y, y2) && ui.my <= max(y, y2)) ||
			( h && abs(ui.my - y) < 5 && ui.mx >= min(x, x2) && ui.mx <= max(x, x2))
		) {
			let hs = ui.hover(id)
			hs.set('wall_run', wr)
			hs.set('pi', i)
			hs.set('side', h ? 'y' : 'x')
			return true
		}
	}
}

let PLAN_ID     = ui.S-1
let PLAN_STRUCT = ui.S+0

ui.box_widget('plan', {

	create: function(cmd, id, fr, align, valign, min_w, min_h, plan) {

		let [dstate, dx, dy] = ui.drag(id)

		let hs = ui.hovers(id)
		let cs = ui.captured(id)
		let cursors = {x: 'ew-resize', y: 'ns-resize'}

		if (dstate == 'hover') {
			let side = hs.get('side')
			if (side)
				ui.set_cursor(cursors[side])
			let opening = hs.get('opening')
			if (opening) {
				ui.set_cursor('move')
			}
		}
		if (dstate == 'drag') {
			let side = hs.get('side')
			if (side) {
				let wr = hs.get('wall_run')
				let pi = hs.get('pi')
				ui.set_cursor(cursors[side])
				cs.set('side', side)
				cs.set('pi'  , pi)
				cs.set('px0' , wall_x1(wr, pi))
				cs.set('py0' , wall_y1(wr, pi))
				cs.set('rs'  , moving_ranges(plan, wr, pi))
				cs.set('joints', wall_joints(plan, wr, pi))
				pr(cs.get('joints'))
			}
			let opening = hs.get('opening')
			if (opening) {
				cs.set('opening', opening)
			}
		}
		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {
			let side = cs.get('side')
			if (side) {
				let wr = cs.get('wall_run')
				let pi = cs.get('pi')
				let rs = cs.get('rs')
				let joints = cs.get('joints')
				ui.set_cursor(cursors[side])
				let X = side == 'x' ? 0 : 1
				let dX = X ? dy : dx
				let pX = cs.get(X ? 'py0' : 'px0') + dX
				let r = rs[0]
				pX = clamp(pX, r[0], r[1])
				//TODO: move_jointed_walls(plan, wr, pi, dX)
				wall_set_Y(wr, pi, pX)
			}
			let opening = cs.get('opening')
			if (opening) {
				//
			}
		}

		return ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
				id, plan
			)
	},

	draw: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+PLAN_ID]
		let plan = a[i+PLAN_STRUCT]

		let hs = ui.hit(id)

		let cx = ui.cx

		cx.beginPath()

		cx.translate(x00, y00)

		draw_walls(cx, plan, 1, hs)
		cx.translate( 300, 0)
		draw_walls(cx, plan, 2, hs)
		cx.translate(-300, 0)

		cx.translate(0,  500)
		draw_facade(cx, plan, 0, -1, hs)
		cx.translate(0, -500)

		cx.translate(0,  600)
		draw_facade(cx, plan, 0, 1, hs)
		cx.translate(0, -600)

		cx.translate( 600, 0)
		draw_facade(cx, plan, 1, 1, hs)
		cx.translate(-600, 0)

		cx.translate( 600,  100)
		draw_facade(cx, plan, 1, -1, hs)
		cx.translate(-600, -100)

		cx.translate(-x00, -y00)

	},

	hit: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+PLAN_ID]
		let plan = a[i+PLAN_STRUCT]

		let hs = ui.hovers(id)
		let cs = ui.captured(id)

		if (!cs) {

			for (let wr of plan.wall_runs)
				if (hit_opening(wr, x00, y00, id))
					return

			for (let wr of plan.wall_runs)
				if (hit_walls(wr, x00, y00, id))
					return

		}

	},

})

let plan = {
	wall_runs: [
		{
			h: 80,
			exterior: true,
			closed: true,
			thickness: 5,
			walls: [
				{to: 100,},
				{to: 100,},
				{to: 200,},
				{to: 200,},
				{to: 100, openings: [
					{type: 'door', d: 20, w: 50, h: 70},
				]},
				{to: 300,},
				{to: 150,},
				{to: 400,},
				{to:   0,},
				{to:   0, openings: [
					{type: 'window', d: 50, w: 150, h: 50, y: 20},
				]},
			],
		},
		{
			storey: 2,
			h: 80,
			exterior: true,
			closed: true,
			thickness: 5,
			walls: [
				{to: 100,},
				{to: 100,},
				{to: 200,},
				{to: 200,},
				{to: 100, openings: [
					{type: 'door', d: 20, w: 50, h: 70},
				]},
				{to: 300,},
				{to: 150,},
				{to: 400,},
				{to:   0,},
				{to:   0, openings: [
					{type: 'window', d: 50, w: 150, h: 50, y: 20},
				]},
			],
		},
		{
			h: 80,
			thickness: 10,
			offset_sign: 1,
			vertical: true,
			walls: [
				{to: 150},
				{to: 0, openings: [
					{type: 'door', d: 10, w: 40, h: 70, swing: 45},
				]},
				{to: 100}, // y0
				{to: 100}, // x0
			],
		},
	],
}

ui.main = function() {

	ui.m(100)
	ui.v()
		ui.plan('p1', 1, null, null, null, null, plan)
	ui.end_v()

}

</script>
</body>
</html>
