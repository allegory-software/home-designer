<!DOCTYPE html>
<html theme=dark>
<body>
<base href="www2/">
<link rel="preload" href="icons/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="icons/fa-solid-900.woff2"   as="font" type="font/woff2" crossorigin>
<script src=glue.js global extend></script>
<script src=ui.js></script>
<script src=ui_validation.js></script>
<script src=ui_nav.js></script>
<script src=ui_grid.js></script>
<script>

(function () {
"use strict"
const G = window

DEBUG('DEBUG_PLAN')

let clone = structuredClone

let EPSILON = 1e-5

function near(a, b) { return abs(a - b) < EPSILON }

// debugging -----------------------------------------------------------------

let errs = []
let log_stack = []
function log(err, ...args) {
	errs.push(isstr(err) ? subst(err, ...args) : err)
}
function push_log() {
	log_stack.push(errs)
	errs = []
	errs.t0 = clock()
}
function pop_log(err, ...args) {
	let errs1 = errs
	let dt = (clock() - errs1.t0) * 1000
	errs1.dt = dt
	errs = log_stack.pop()
	if (err !== undefined && errs1.length) {
		log(err, ...args)
		log(errs1)
		if (dt > 3)
			log('{0} TIME {1} ms', ('*').repeat(dt), dec(dt))
	} else {
		return errs1
	}
}
function check(v, ...args) {
	if (!v) log(...args)
	return v
}
function pr_errs(es, level) {
	let indent = ('  ').repeat(level)
	for (let s of es)
		if (isarray(s))
			pr_errs(s, level+1)
		else
			pr(indent + s)
}
function pr_log() {
	assert(!log_stack.length)
	pr_errs(errs, 0)
	errs.length = 0
}

let next_id = {}
function gen_id(k) {
	if (!next_id[k])
		next_id[k] = 1
	else
		next_id[k]++
	return next_id[k]
}

// bbox geometry -------------------------------------------------------------

function bbox() {
	return [inf, inf, -inf, -inf] // x1, y1, x2, y2
}

function bbox_add_bbox(bb, x1, y1, x2, y2) {
	bb[0] = min(bb[0], x1, x2)
	bb[1] = min(bb[1], y1, y2)
	bb[2] = max(bb[2], x1, x2)
	bb[3] = max(bb[3], y1, y2)
}

function bbox_add_point(bb, x, y) {
	bb[0] = min(bb[0], x)
	bb[1] = min(bb[1], y)
	bb[2] = max(bb[2], x)
	bb[3] = max(bb[3], y)
}

function bb_inside(cbb, pbb) {
	let [px1, py1, px2, py2] = pbb
	let [cx1, cy1, cx2, cy2] = cbb
	return cx1 >= px1 && cx2 <= px2 && cy1 >= py1 && cy2 <= py2
}

// polygon geometry ----------------------------------------------------------

// NOTE: do `ps.push(ps[0], ps[1])` before you call this!
function poly_area(ps) {
	let area = 0
	for (let i = 1, n = ps.length; i <= n; i++)
		area += ps[mod(i, n)][0] * (ps[mod(i+1, n)][1] - ps[i-1][1])
	return area / 2
}

function poly_center(ps) {
	let [x0, y0] = ps[0]
	let twicearea = 0
	let x = 0
	let y = 0
	for (let i = 0, n = ps.length, j = n-1; i < n; j = i++) {
		let [x1, y1] = ps[i]
		let [x2, y2] = ps[j]
		let f = (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0)
		twicearea += f
		x += (x1 + x2 - 2 * x0) * f
		y += (y1 + y2 - 2 * y0) * f
	}
	let f = twicearea * 3
	return [
		x / f + x0,
		y / f + y0
	]
}

function point_inside_poly(x, y, ps) {
	let inside = false
	for (let i = 0, j = ps.length - 1; i < ps.length; j = i++) {
		let xi = ps[i][0]
		let yi = ps[i][1]
		let xj = ps[j][0]
		let yj = ps[j][1]
		let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
		if (intersect)
			inside = !inside
	}
	return inside
}

// polygon offset algorithm --------------------------------------------------

// hypotenuse function: computes sqrt(a^2 + b^2) without underflow / overflow problems.
function hypot(a, b) {
	if (a == 0 && b == 0) return 0
	a = abs(a)
	b = abs(b)
	let M = max(a, b)
	let m = min(a, b)
	return M * sqrt(1 + (m / M)**2)
}

// distance between two points. avoids underflow and overflow.
function distance(x1, y1, x2, y2) {
	return hypot(x2-x1, y2-y1)
}

// parallel line segment at a distance on the right side of a segment.
// use a negative distance for the left side, or reflect the returned points
// against their respective initial points.
function line_offset(d, x1, y1, x2, y2, out) {
	// normal vector of the same length as original segment.
	let dx = -(y2-y1)
	let dy =   x2-x1
	let k = d / distance(x1, y1, x2, y2) // normal vector scale factor
	// normal vector scaled and translated to (x1,y1) and (x2,y2)
	out[0] = x1 + dx * k
	out[1] = y1 + dy * k
	out[2] = x2 + dx * k
	out[3] = y2 + dy * k
	return out
}

// evaluate a line at time t using linear interpolation.
// the time between 0..1 covers the segment interval.
function line_point(t, x1, y1, x2, y2, out) {
	out[0] = x1 + t * (x2 - x1)
	out[1] = y1 + t * (y2 - y1)
	return out
}

// intersect line segment (x1, y1, x2, y2) with line segment (x3, y3, x4, y4).
// returns the time on the first line where intersection occurs.
// if the intersection occurs outside the segments themselves, then t is
// outside the 0..1 range. if the lines are parallel then t is +/-inf.
// if they are coincidental, t is NaN.
function line_line_intersection(x1, y1, x2, y2, x3, y3, x4, y4) {
	let d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)
	return ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d
}

function set_seg_offset(p1, p2, d) {
	for (let seg of p1.segs) {
		if (seg[0] == p2) { // (p2,p1) right side offset
			seg[-2] = d
			return
		} else if (seg[1] == p2) { // (p1,p2) right side offset
			seg[-1] = d
			return
		}
	}
	// TODO: see why this breaks
	///assert(false, '#'+p1.segs.length)
}

function offset_corner(p0, p1, p2, d, out) {
	set_seg_offset(p0, p1, d)
	set_seg_offset(p1, p2, d)
	p0.max_offset = max(p0.max_offset, abs(d))
	p1.max_offset = max(p1.max_offset, abs(d))
	p2.max_offset = max(p2.max_offset, abs(d))
	let [x1, y1, x2, y2] = line_offset( d, p0[0], p0[1], p1[0], p1[1], out)
	let [x3, y3, x4, y4] = line_offset(-d, p2[0], p2[1], p1[0], p1[1], out)
	let t1 = line_line_intersection(x1, y1, x2, y2, x3, y3, x4, y4)
	if (abs(t1) == inf) { // 0-degree corner: make a line cap of 2 points, 1*d thick
		let dx = x2 == x4 ? d * sign(x1 - x2) : 0
		let dy = y2 == y4 ? d * sign(y1 - y2) : 0
		out[0] = x2 + dx
		out[1] = y2 + dy
		out[2] = x4 + dx
		out[3] = y4 + dy
	} else if (t1 != t1) { // 180-degree corner: use the offset point on the first line
		out[0] = x2
		out[1] = y2
		out[2] = null
		out[3] = null
	} else { // bent corner
		out[2] = null
		out[3] = null
		line_point(t1, x1, y1, x2, y2, out)
	}
	return out
}

function points_colinear(p0, p1, p2) {
	return (
		pseudo_angle(p1[0] - p0[0], p1[1] - p0[1]) ==
		pseudo_angle(p2[0] - p1[0], p2[1] - p1[1])
	)
}

function offset_poly(ps, d) {
	let ops = []
	let out = []

	// remove null segments as we can't offset those (they don't have a normal).
	let ps1 = ps
	ps = []
	for (let i = 0, n = ps1.length; i < n; i++) {
		let p0 = ps1[mod(i-1, n)]
		let p1 = ps1[i]
		if (!points_equal(p0, p1))
			ps.push(p1)
	}

	if (ps.length == 1) { // single null seg: make a square
		let ci = 0
		for (let op of [[-d, -d], [d, -d], [d, d], [-d, d]]) {
			op.p = ps[0]
			op.ci = ci++
			ops.push(op)
		}
	} else {
		let ci = 0
		for (let i = 0, n = ps.length; i < n; i++) {
			let p1 = ps[i]
			let i0 = i-1
			let i2 = i+1
			let p0 = ps[mod(i0--, n)]
			let p2 = ps[mod(i2++, n)]
			let [x1, y1, x2, y2] = offset_corner(p0, p1, p2, d, out)
			let [x0, y0] = p1
			let op1 = [x1 - x0, y1 - y0]
			op1.p = p1
			op1.ci = ci++
			ops.push(op1)
			if (x2 != null) {
				let op2 = [x2 - x0, y2 - y0]
				op2.p = p1
				op2.ci = ci++
				ops.push(op2)
			}
		}
	}
	return ops
}

/* ---------------------------------------------------------------------------
	Algorithm for extracting all base cycles from an unidirected planar graph.
	- input: no null segs, no isolated points, no overlapping or intersecting segs allowed.
	- points can be: end-points (#adj=1), joints (#adj=2) or branch points (#adj > 2).
	- output: cycles and filaments.
	Paper : https://www.geometrictools.com/Documentation/MinimalCycleBasis.pdf
	Code  : https://github.com/vbichkovsky/min-cycles/blob/master/src/cycles.js
*/

function rebuild_adj_refs(ps) {
	for (let p of ps)
		p.adj.length = 0
	for (let p of ps)
		for (let seg of p.segs)
			p.adj.push(seg[1-seg_pi(seg, p)])
}

function rem_edge(p1, p2, ps) {
	remove_value(p1.adj, p2)
	remove_value(p2.adj, p1)
	if (p1.adj == 0) remove_value(ps, p1)
	if (p2.adj == 0) remove_value(ps, p2)
}

function rem_filament(p, ps) {
	while (p && p.adj.length < 2) {
		remove_value(ps, p)
		let pa = p.adj[0]
		if (pa)
			rem_edge(p, pa, ps)
		p = pa
	}
}

function is_cw(ps) {
	let s = 0
	for (let i = 0, n = ps.length; i < n; i++) {
		let [x1, y1] = ps[mod(i-1, n)]
		let [x2, y2] = ps[i]
		s += (x2-x1)*(y2+y1)
	}
	return s < 0
}

function left_bottom_point(ps) {
	return ps.reduce((p0, p1) => {
		let x1 = p1[0]
		let x0 = p0[0]
		if (x1 < x0) return p1
		if (x0 < x1) return p0
		let y1 = p1[1]
		let y0 = p0[1]
		if (y1 > y0) return p1
		return p0
	})
}

// return a number from the range [0..4) which is monotonically increasing
// with the clockwise angle that the input vector makes against the x axis.
function pseudo_angle(dx, dy) {
	let p = dx / (abs(dx) + abs(dy))  // -1..0 (x <= 0) or 0..1 (x >= 0)
	return dy < 0 ? 3 + p : 1 - p     //  2..4 (y <= 0) or 0..2 (y >= 0)
}

// return the angle sweep from angle a1 to a2 in cw (+) or ccw (-) dir.
function angle_sweep(a1, a2, clockwise, circle_sweep) {
	circle_sweep ??= 4
	let d = a2 - a1
	if (d < 0 && clockwise)
		d += circle_sweep
	else if (d > 0 && !clockwise)
		d -= circle_sweep
	return d
}

// return p1 from p.adj where the angle at p on (p0,p,p1) is smallest in cw or ccw direction.
function next_adj(p0, p, clockwise, max_a) {
	max_a ??= inf
	if (p.adj.length == 1 && max_a >= 2) // end-point, go back (or forward if first)
		return p.adj[0]
	let x0 = p0 ? p0[0] - p[0] : 0
	let y0 = p0 ? p0[1] - p[1] : 1
	let a0 = pseudo_angle(x0, y0)
	let min_a = inf // min angle
	let min_p // point with min angle to (p0,p)
	for (let p1 of p.adj) {
		if (p1 == p0)
			continue
		let x1 = p1[0] - p[0]
		let y1 = p1[1] - p[1]
		let a1 = pseudo_angle(x1, y1)
		let a = abs(angle_sweep(a1, a0, clockwise))
		if (a < min_a && a <= max_a) {
			min_a = a
			min_p = p1
		}
	}
	return min_p
}

function closed_walk(first, outer_cycle) {
	let walk = []
	let curr = first
	let prev
	do {
		walk.push(curr)
		let next = next_adj(prev, curr, !prev || outer_cycle)
		prev = curr
		curr = next
		if (curr == first) {
			if (outer_cycle) {
				// when tracing the outer cycle is not enough to stop when the
				// starting point is encountered since multiple outer cycles can
				// meet at the starting point (connected with filaments or not).
				let next = next_adj(prev, curr, true)
				if (next == walk[1])
					break
			} else {
				break // filament check done later on inner cycles
			}
		}
	} while (1)
	return walk
}

function extract_cycles_for(comp) {
	let ps = [...comp.ps]
	while (ps.length > 0) {
		let p = left_bottom_point(ps)
		let c = closed_walk(p)
		if (c[1] != c[c.length-1]) { // not started with a filament
			c.i = gen_id('cycle')
			c.comp = comp
			c.area = abs(poly_area(c))
			c.area_pos = poly_center(c)
			comp.cycles.push(c)
		}
		// the first edge is always safe to remove because starting from the leftmost
		// point means that there cannot be a cycle to the right of that first edge
		// so that edge is part of at most one cycle: our cycle.
		rem_edge(c[0], c[1], ps)
		// the removed edge's end-points are now possibly end-points of filaments
		// that we must remove too.
		rem_filament(c[0], ps)
		rem_filament(c[1], ps)
	}
}

function extract_outer_cycle_for(comp) {
	let p = left_bottom_point(comp.ps)
	let c = closed_walk(p, true)
	c.i = gen_id('cycle')
	c.outer = true
	c.comp = comp
	c.area = abs(poly_area(c))
	c.area_pos = poly_center(c)
	c.reverse()
	comp.cycles.push(c)
	comp.outer_cycle = c
}

// house plan model ----------------------------------------------------------

function is_h(seg) { return seg[0][1] == seg[1][1] }
function is_v(seg) { return seg[0][0] == seg[1][0] }
function is_null(seg) { return is_h(seg) && is_v(seg) }
function seg_dir(seg) { return is_h(seg) ? '-' : is_v(seg) ? '|' : '/' }

function seg_x1(seg) { return min(seg[0][0], seg[1][0]) }
function seg_y1(seg) { return min(seg[0][1], seg[1][1]) }
function seg_x2(seg) { return max(seg[0][0], seg[1][0]) }
function seg_y2(seg) { return max(seg[0][1], seg[1][1]) }

function set_seg_x1(seg, x) { let x1i = seg[0][0] < seg[1][0] ? 0 : 1; seg[x1i][0] = x }
function set_seg_y1(seg, y) { let y1i = seg[0][1] < seg[1][1] ? 0 : 1; seg[y1i][1] = y }
function set_seg_x2(seg, x) { let x2i = seg[0][0] < seg[1][0] ? 1 : 0; seg[x2i][0] = x }
function set_seg_y2(seg, y) { let y2i = seg[0][1] < seg[1][1] ? 1 : 0; seg[y2i][1] = y }

function seg_axis(seg) { return is_v(seg) ? seg_x1(seg) : seg_y1(seg) }
function seg_m1  (seg) { return is_v(seg) ? seg_y1(seg) : seg_x1(seg) }
function seg_m2  (seg) { return is_v(seg) ? seg_y2(seg) : seg_x2(seg) }

function set_seg_m1  (seg, m) { if (is_v(seg)) set_seg_y1(seg, m); else set_seg_x1(seg, m) }
function set_seg_m2  (seg, m) { if (is_v(seg)) set_seg_y2(seg, m); else set_seg_x2(seg, m) }
function set_seg_axis(seg, a) {
	if (is_v(seg)) {
		seg[0][0] = a
		seg[1][0] = a
	} else {
		seg[0][1] = a
		seg[1][1] = a
	}
}

function points_equal(p1, p2) { return p1[0] == p2[0] && p1[1] == p2[1] }

function seg_pi(seg, p) {
	assert(seg[0] == p || seg[1] == p)
	return seg[0] == p ? 0 : 1
}

function seg_i1(seg) { let mi = is_v(seg) ? 1 : 0; return seg[0][mi] < seg[1][mi] ? 0 : 1 }
function seg_i2(seg) { let mi = is_v(seg) ? 1 : 0; return seg[0][mi] < seg[1][mi] ? 1 : 0 }

function seg_p1(seg) { return seg[seg_i1(seg)] }
function seg_p2(seg) { return seg[seg_i2(seg)] }

function seg_center(seg) {
	let [p1, p2] = seg
	let [x1, y1] = p1
	let [x2, y2] = p2
	return [
		(x2 + x1) / 2,
		(y2 + y1) / 2,
	]
}

// ep = edge point aka offset point.
function ep_x(ep) { return ep[0] + ep.p[0] }
function ep_y(ep) { return ep[1] + ep.p[1] }

let format_length = d => format_kcount(d / 1e2, 2)+'m'
let format_area = a => format_kcount(a / 1e4)+'mÂ²'

function house_plan(t) {

	let levels = t.levels

	let house_plan = {levels: levels}

	function recompute_house_plan_bbox() {
		let bb = bbox()
		for (let level of house_plan.levels) {
			let level_plan = house_plan.level_plan(level)
			bbox_add_bbox(bb, ...level_plan.bb)
		}
		return bb
	}

	function level_plan(level) {

		if (level.level_plan)
			return level.level_plan

		let ps = level.ps; if (!ps) { ps = []; level.ps = ps; }
		let segs = level.segs
		let comps = []

		let level_plan = {ps: ps, segs: segs, comps: comps, house_plan: house_plan}
		level.level_plan = level_plan

		// model editing -------------------------------------------------------

		function init_point(p, i) {
			p.segs = []
			p.adj = []
			p.i = i
		}

		function add_point(x, y) {
			let p = [x, y]
			init_point(p, ps.length)
			ps.push(p)
			log('point added: {0}', p.i)
			return p
		}
		level_plan.add_point = add_point

		function rem_point(p) {
			remove_value(ps, p)
			log('point removed: {0}', p.i)
		}

		function rem_points(cond, msg) {
			let a = []
			remove_values(ps, function(p) {
				if (!cond(p)) return
				a.push(p.i)
				return true
			})
			if (a.length)
				log('{0} removed: {1}', msg ?? 'points', a.join(' '))
		}

		function add_seg_ref(p, seg) {
			p.segs.push(seg)
		}

		function rem_seg_ref(p, seg) {
			remove_value(p.segs, seg)
		}

		function add_seg_refs(seg) {
			add_seg_ref(seg[0], seg)
			add_seg_ref(seg[1], seg)
		}

		function rem_seg_refs(seg) {
			rem_seg_ref(seg[0], seg)
			rem_seg_ref(seg[1], seg)
		}

		function add_seg(p1, p2) {
			let seg = [p1, p2]
			seg.i = segs.length
			segs.push(seg)
			add_seg_refs(seg)
			log('seg added: {0}: {1} {2}', seg.i, seg[0].i, seg[1].i)
			return seg
		}
		level_plan.add_seg = add_seg

		function rem_seg(seg) {
			rem_seg_refs(seg)
			remove_value(segs, seg)
			log('seg removed: {0}', seg.i)
		}

		function rem_segs(cond, msg) {
			let a = []
			remove_values(segs, function(seg) {
				if (!cond(seg)) return
				rem_seg_refs(seg)
				a.push(seg.i)
				return true
			})
			if (log && a.length)
				log('{0} removed: {1}', msg ?? 'segs', a.join(','))
		}

		function rem_marked_segs(msg) {
			rem_segs(seg => seg.removed, msg)
		}

		function set_seg_point(seg, i, p) {
			let old_p = seg[i]
			rem_seg_ref(old_p, seg)
			seg[i] = p
			add_seg_ref(p, seg)
			log('seg end moved: {0}/{1}: {2}->{3}', seg.i, i, old_p.i, p.i)
			return old_p
		}

		// model fixing --------------------------------------------------------

		function rebuild_seg_refs() {
			for (let p of ps)
				p.segs.length = 0
			for (let seg of segs)
				add_seg_refs(seg)
		}

		function remove_isolated_points() {
			rem_points(p => p.segs.length == 0, 'isolated points')
		}

		function remove_null_segs() {
			rem_segs(is_null, 'null segs')
		}

		function remove_angled_segs() {
			rem_segs(seg => seg_dir(seg) == '/', 'angled segs')
		}

		// NOTE: assumes segs are sorted, null segs removed, points deduplicated.
		function merge_colinear_segs() {
			for (let p of ps) {
				if (p.segs.length == 2) {
					let s1 = p.segs[0]
					let s2 = p.segs[1]
					if (is_v(s1) && is_v(s2) || is_h(s1) && is_h(s2)) { // colinear
						let s1_pi = seg_pi(s1, p)
						let s2_p2 = s2[1-seg_pi(s2, p)]
						push_log()
						set_seg_point(s1, s1_pi, s2_p2)
						rem_seg(s2)
						pop_log('segs merged: {0} + {1} => {0}', s1.i, s2.i, s1.i)
					}
				}
			}
		}

		// shortens seg at m with new point and adds new seg without detaching the original seg's end-points.
		function split_seg_at(seg, m) {
			push_log()
			let m1 = seg_m1(seg)
			let m2 = seg_m2(seg)
			let x = is_v(seg) ? seg_x1(seg) : m
			let y = is_v(seg) ? m : seg_y1(seg)
			let new_p = add_point(x, y)
			let old_p = set_seg_point(seg, seg_i2(seg), new_p)
			let new_seg = add_seg(new_p, old_p)
			pop_log('seg split: {0} {4}>{1}<{5} => {2} {3}', seg.i, m, seg.i, new_seg.i, m1, m2)
		}

		// NOTE: only works for h and v segs.
		function split_intersecting_segs_on(v) {
			push_log()
			for (let seg1 of segs) {
				if (is_v(seg1) == v) {
					for (let seg2 of segs) {
						if (is_v(seg2) != v) {
							let m1  = seg_m1(seg1)
							let m2  = seg_m2(seg1)
							let bm1 = seg_m1(seg2)
							let bm2 = seg_m2(seg2)
							let a   = seg_axis(seg1)
							let ba  = seg_axis(seg2)
							if (bm1 <= a && bm2 >= a && ba > m1 && ba < m2) {
								// splitting adds a seg at the end of segs array which will
								// be also tested in the outer loop and possibly split further.
								// the shortened seg is potentially split multiple times
								// in this inner loop.
								split_seg_at(seg1, ba)
							}
						}
					}
				}
			}
			pop_log('split all intersecting segs')
		}
		function split_intersecting_segs() {
			split_intersecting_segs_on(0)
			split_intersecting_segs_on(1)
		}

		// NOTE: leaves isolated points behind.
		function points_cmp(p1, p2) {
			if (p1[0] < p2[0]) return -1
			if (p1[0] > p2[0]) return  1
			if (p1[1] < p2[1]) return -1
			if (p1[1] > p2[1]) return  1
			if (p1.i < p2.i) return -1
			if (p1.i > p2.i) return  1
			return 0
		}
		function deduplicate_points() {
			push_log()
			ps.sort(points_cmp)
			let p0
			for (let i = 0; i < ps.length; i++) {
				let p = ps[i]
				if (p0 && points_equal(p, p0)) {
					for (let j = 0; j < p.segs.length; j++) { // each connected seg
						let seg = p.segs[j]
						for (let i = 0; i < 2; i++) // each seg end
							if (seg[i] == p) {
								set_seg_point(seg, i, p0, 'seg end point dedup')
								j-- // because seg was just removed from p.segs
							}
					}
					continue
				}
				p0 = p
			}
			pop_log('deduplicate all points')
		}

		// NOTE: requires no intersecting segments.
		function break_overlapping_segs() {
			push_log()
			segs.sort(function(s1, s2) {
				let v1 = is_v(s1)
				let v2 = is_v(s2)
				// level 1 grouping by direction
				if (v1 < v2) return -1
				if (v1 > v2) return  1
				let m1 = seg_axis(s1)
				let m2 = seg_axis(s2)
				// level 2 grouping by axis
				if (m1 < m2) return -1
				if (m1 > m2) return  1
				// level 3 grouping by starting point because most segments are
				// non-overlapping and we want to skip those quickly.
				let i = v1 ? 1 : 0
				let c1 = min(s1[0][i], s1[1][i])
				let c2 = min(s2[0][i], s2[1][i])
				if (c1 < c2) return -1
				if (c1 > c2) return  1
				return 0
			})
			let i0, v0, m0
			for (let i = 0, n = segs.length; i <= n; i++) {
				let seg = segs[i]
				let v = seg ? is_v(seg) : null
				let m = seg ? seg_axis(seg) : null
				if (v0 == null) {
					i0 = i
					v0 = v
					m0 = m
				} else if (v != v0 || m != m0) {
					if (i >= i0 + 2) { // there's at least 2 segments on this axis
						for (let j = i0+1; j < i; j++) {
							let seg1 = segs[j]
							let seg0 = segs[j-1]
							let m1_1 = seg_m1(seg1)
							let m2_0 = seg_m2(seg0)
							if (m1_1 < m2_0) {
								// seg points that are overlapping segs have no _|_ joints
								// or they wouldn't be overlapping the seg, so it's safe
								// to remove the overlapping seg as long as we elongate
								// the overlapped seg.
								log('segs overlap: {0} {1}: {2}<={3}: seg {1} removed, seg {0}.m2 set to {4}',
									seg0.i, seg1.i, m1_1, m2_0, seg_m2(seg1))
								seg1.removed = true
								set_seg_m2(seg0, max(seg_m2(seg1), seg_m2(seg0)))
							}
						}
					}
					i0 = i
					v0 = v
					m0 = m
				}
			}
			rem_marked_segs()
			pop_log('breaking overlapping colinear segs')
		}

		// finding graph components --------------------------------------------

		function add_comp() {
			let comp = {}
			comp.i = comps.length
			comp.ps = []
			comp.cycles = []
			comp.segs = []
			comps.push(comp)
			return comp
		}

		// NOTE: needs adj refs
		function find_comps() {

			for (let p of ps)
				p.visited = false

			comps.length = 0

			function dfs(p, ps, segs) {
				p.visited = true
				ps.push(p)
				for (let seg of p.segs)
					segs.add(seg)
				for (p of p.adj)
					if (!p.visited)
						dfs(p, ps, segs)
			}

			for (let p of ps) {
				if (!p.visited) {
					let comp = add_comp()
					let segs = set()
					dfs(p, comp.ps, segs)
					comp.segs = set_toarray(segs)
					log('comp {0}: {1}', comp.i, comp.ps.map(p=>p.i).join(' '))
				}
			}

		}

		// finding which components are inside islands -------------------------

		function segs_bb(comp) {
			let bb = bbox()
			for (let seg of comp.segs) {
				let [x1, y1] = seg[0]
				let [x2, y2] = seg[1]
				bbox_add_bbox(bb, x1, y1, x2, y2)
			}
			return bb
		}

		function skin_bb(comp) {
			let bb = bbox()
			for (let ep of comp.outer_cycle.edges)
				bbox_add_point(bb, ep_x(ep), ep_y(ep))
			return bb
		}

		function plan_bb() {
			let bb = bbox()
			for (let c of comps) {
				bbox_add_bbox(bb, ...c.bb)
			}
			return bb
		}

		function comp_inside(c, p) {
			if (!bb_inside(c.bb, p.bb))
				return false
			return point_inside_poly(c.ps[0][0], c.ps[0][1], p.outer_cycle)
		}

		function find_inside_comps() {

			// seg-based bbox: enough for computing inside flag.
			for (let c of comps) {
				c.inside = false
				c.bb = segs_bb(c)
			}
			level_plan.bb = plan_bb()

			for (let c of comps) {
				if (c.inside)
					continue
				for (let p of comps) {
					if (p == c)
						continue
					if (comp_inside(c, p)) {
						c.inside = true
						log('comp {0} is inside', c.i)
					}
				}
			}
		}

		// plan loading & validation -------------------------------------------

		function extract_cycles() {

			for (let c of comps)
				extract_outer_cycle_for(c)
			rebuild_adj_refs(ps)

			for (let c of comps)
				extract_cycles_for(c)
			rebuild_adj_refs(ps)

			if (1)
			for (let co of comps)
				for (let c of co.cycles)
					log('cycle {0}/{1} {2} {3} {4}: {5}', co.i, c.i,
						is_cw(c) ? 'cw' : 'ccw',
						c.outer ? 'outer' : '',
						c.inside ? 'inside' : '',
						c.map(p=>p.i).join(' ')
					)
		}

		function create_edges_for(c) {
			c.edges = offset_poly(c, (c.outer ? (c.comp.inside ? -4 : -12) : -4))
		}
		function create_edges() {
			for (let p of ps)
				p.max_offset = 0
			for (let comp of comps) {
				for (let c of comp.cycles) {
					create_edges_for(c)
					create_edges_for(comp.outer_cycle)
				}
			}

			// recompunte bbox now that we have the skin.
			for (let c of comps)
				c.bb = skin_bb(c)
			level_plan.bb = plan_bb()

			// recompute house plan bbox.
			if (house_plan.bb)
				house_plan.bb = recompute_house_plan_bbox()

		}

		level_plan.snap_lines = []

		function fix_level() {
			split_intersecting_segs()
			break_overlapping_segs()
			remove_null_segs()
			deduplicate_points()
			merge_colinear_segs()
			remove_isolated_points()
			rebuild_adj_refs(ps)
			find_comps()
			extract_cycles()
			find_inside_comps()
			create_edges()
			level_plan.snap_lines[0] = snap_lines_for(1)
			level_plan.snap_lines[1] = snap_lines_for(0)
		}

		// plan view UI ops ----------------------------------------------------

		// Find and fix the the cycles that contain the sequence (p0,p1,p2) or (p2,p1,p0).
		// If (p0,p1,p2) is found then the cycle is to the left of the sequence if it's an inner cycle.
		// If (p2,p1,p0) is found then the cycle is to the right of the sequence if it's an inner cycle.
		// It's the opposite if it's an outer cycle.
		// The same cycle will contain the sequence twice (once as is once in reverse)
		// if the sequence is (part of) a filament.
		// NOTE: replacing a point in the cycle (instead of always adding one) makes the cycle
		// technically invalid (as it's skipping a point) but we do it to keep the offset edge
		// stable at that corner while dragging the segment.
		function fix_cycle(c, i, fw, action, new_p, p0, p1, p2) {
			if (action == 'replace') {
				log('cycle point replaced: {0}/{1}: {2}->{3}', c.i, i, c[i].i, new_p.i)
				c[i] = new_p
			} else if (action == 'insert') {
				i = fw ? i : i+1 // insert point in the cycle array
				log('cycle point inserted: {0}/{1} (before {2}): {3}', c.i, i, c[i] ? c[i].i : 'end', new_p.i)
				insert(c, i, new_p)
			}
		}
		function fix_cycles_containing(p0, p1, p2, action, new_p) {
			push_log()
			for (let comp of comps)
				for (let c of comp.cycles) {
					let i0 = 0
					while (1) {
						let i = c.indexOf(p1, i0)
						if (i == -1)
							break
						let fp0 = c[mod(i-1, c.length)]
						let fp2 = c[mod(i+1, c.length)]
						if (fp0 == p0 && fp2 == p2) fix_cycle(c, i, 1, action, new_p, p0, p1, p2)
						if (fp0 == p2 && fp2 == p0) fix_cycle(c, i, 0, action, new_p, p2, p1, p0)
						i0 = i+1
					}
				}
			pop_log('all cycles containing ({0},{1},{2}): {3} with {4}', p0.i, p1.i, p2.i, action, new_p.i)
		}

		// colinear segs directly end-to-end tied to the segment we want to move
		// must be separated by addidng a _|_ seg in between so they're not dragged along.
		// NOTE: do not deduplicate points after this!
		function detach_seg_at(seg, i, p00) {
			push_log()
			let p  = seg[i]
			let p0 = seg[1-i]
			let new_p = add_point(p[0], p[1])

			// each side of (p0,p) needs a different kind of fixing depending on
			// whether there's a _|_ seg at the separation point on that side or not.
			if (p.adj.length > 2) {
				for (let cw = 0; cw <= 1; cw++) {
					let p1 = next_adj(p0, p, cw, 1)
					fix_cycles_containing(p0, p, p1 ?? p00, p1 ? 'replace' : 'insert', new_p)
				}
			} else { // no _|_ segs on the sides.
				fix_cycles_containing(p0, p, p00, 'insert', new_p)
			}

			set_seg_point(seg, i, new_p, 1)
			let new_seg = add_seg(p, new_p)
			pop_log('seg detached: {0}', seg.i)
		}
		function opposite_seg(seg, i) {
			let v = is_v(seg)
			let p = seg[i]
			for (let seg1 of p.segs) { // each segment connected to that end-point
				if (seg1 == seg) // itself
					continue
				if (is_v(seg1) != v) // not colinear
					continue
				if (is_null(seg1)) // just added
					continue
				return seg1
			}
		}
		function detach_opposite_seg(seg, i) {
			let seg1 = opposite_seg(seg, i)
			if (!seg1) return
			let p = seg[i]
			if (seg1[0] == p) detach_seg_at(seg1, 0, seg[1-i])
			else
			if (seg1[1] == p) detach_seg_at(seg1, 1, seg[1-i])
		}
		function detach_colinear_segs(seg) {
			detach_opposite_seg(seg, 0)
			detach_opposite_seg(seg, 1)
		}

		function segs_overlap(am1, am2, bm1, bm2) { // check if two segments overlap
			return !(am2 <= bm1 || bm2 <= am1)
		}

		function snap_lines_for(v, exclude_seg) {
			let mi = v ? 0 : 1
			let ms = []
			for (let p of ps) {
				if (exclude_seg && (exclude_seg[0] == p || exclude_seg[1] == p))
					continue
				let m = p[mi]
				ms.push(m)
			}
			ms.sort()
			uniq_sorted(ms)

			ms.snap = function(m, snap_d) {
				let min_d = 1/0
				let min_m
				for (let m1 of ms) {
					let d = abs(m - m1)
					if (d <= snap_d && d < min_d) {
						min_d = d
						min_m = m1
					}
				}
				return min_m // ?? snap(m, 10)
			}

			ms.v = v

			return ms
		}

		function snap_point(x, y, nosnap) {
			let snap_d = nosnap ? 2 : 20
			let sx = level_plan.snap_lines[0].snap(x, snap_d)
			let sy = level_plan.snap_lines[1].snap(y, snap_d)
			return [sx, sy]
		}
		level_plan.snap_point = snap_point

		function seg_move_bump_limit(seg, sign) {
			let v = is_v(seg)
			let a = seg_axis(seg)
			let min_a1 = sign * 1/0
			let s_m1 = seg_m1(seg)
			let s_m2 = seg_m2(seg)
			for (let seg1 of segs) {
				let s1_m1 = seg_m1(seg1)
				let s1_m2 = seg_m2(seg1)
				let a1 = seg_axis(seg1)
				if (is_v(seg1) != v) {
					let closest_m = sign < 0 ? max(s1_m1, s1_m2) : min(s1_m1, s1_m2)
					s1_m1 = a1
					s1_m2 = a1
					a1 = closest_m
				}
				if (sign * a1 > sign * a && sign * a1 < sign * min_a1) {
					if (segs_overlap(s_m1, s_m2, s1_m1, s1_m2)) {
						min_a1 = a1
					}
				}
			}
			return min_a1
		}
		function seg_move_ranges(seg) {
			let min_a = seg_move_bump_limit(seg, -1)
			let max_a = seg_move_bump_limit(seg,  1)
			let ranges = [
				[min_a, max_a],
			]
			return ranges
		}
		function seg_resize_bump_limit(seg, p, sign) {
			let v = is_v(seg)
			let a = p[v ? 1 : 0]
			let m = p[v ? 0 : 1]
			let min_a1 = sign * 1/0
			for (let seg1 of segs) {
				if (is_v(seg1) != v) {
					let a1 = seg_axis(seg1)
					if (sign * a1 > sign * a && sign * a1 < sign * min_a1) {
						let m1 = seg_m1(seg1)
						let m2 = seg_m2(seg1)
						if (m >= m1 && m <= m2)
							min_a1 = a1
					}
				}
			}
			return min_a1
		}
		function seg_resize_ranges(seg, p) {
			let min_a = seg_resize_bump_limit(seg, p, -1)
			let max_a = seg_resize_bump_limit(seg, p,  1)
			let ranges = [
				[min_a, max_a],
			]
			return ranges
		}
		function closest_range(a, ranges) {
			let min_range
			let min_d = 1/0
			for (let range of ranges) {
				let [a1, a2] = range
				if (a >= a1 && a <= a2) { // in range
					min_range = range
					break
				}
				let d = max(0, min(abs(a1 - a), abs(a2 - a))) // distance to range's closest end-point
				if (d < min_d) {
					min_range = range
					min_d = d
				}
			}
			return min_range
		}
		function snap_seg(a, ranges, snap_lines, draw_state, snap_d) {
			let snap_range = closest_range(a, ranges)
			let [min_a, max_a] = snap_range
			a = clamp(a, min_a, max_a)
			let sa = snap_lines.snap(a, ui.key('shift') ? 2 : snap_d)
			draw_state.snap_lines.length = 0
			if (sa != null)
				draw_state.snap_lines.push(sa, snap_lines.v)
			return sa
		}

		// find the seg in the left, right, top, bottom side around p.
		function seg_around_point(p, sdx, sdy) {
			let p0 = [p[0] + sdx, p[1] + sdy]
			let p1 = next_adj(p0, p, 1, 0)
			// find the seg of (p, p1)
			for (let seg of p.segs)
				if (seg[0] == p && seg[1] == p1 || seg[1] == p && seg[0] == p1)
					return seg
		}

		function start_move_seg(seg, draw_state) {

			push_log()

			detach_colinear_segs(seg)

			pop_log('START MOVE SEG: {0}', seg.i)
			pr_log()

			let move_freely = seg[0].segs.length == 1 && seg[1].segs.length == 1
			let seg0 = [[...seg[0]], [...seg[1]]]
			let ranges = seg_move_ranges(seg)
			let snap_lines = snap_lines_for(is_v(seg), move_freely && seg)
			let v = is_v(seg0)
			let m_snap_lines = move_freely && snap_lines_for(!is_v(seg), seg)

			// find all affected _|_ edges so we can show their lengths as we move the seg
			{
			let perp_edges = []
			function is_edge_v(ep1, ep2) {
				let x1 = ep_x(ep1)
				let x2 = ep_x(ep2)
				return x1 == x2
			}
			// find the farthest edge point from `c.edges[i0]` going in `dir` direction
			// in the array, which has the same spatial direction `v` with the previous point.
			function last_perp_edge_point(c, i, n, dir, v) {
				let ep0 = c.edges[mod(i, n)]
				while (1) {
					let ep1 = c.edges[mod(i, n)]
					let ep2 = c.edges[mod(i+dir, n)]
					if (ep2.p == ep0.p) // end-cap, don't measure
						return
					if (is_edge_v(ep1, ep2) != v) // changed direction, return last edge point
						return ep1
					i += dir
				}
			}
			let sp1 = seg[0]
			let sp2 = seg[1]
			let v = is_v(seg)
			for (let co of comps) {
				for (let c of co.cycles) {
					for (let i = 0, n = c.edges.length; i <= n; i++) {
						let ep1 = c.edges[mod(i+0, n)]
						let ep2 = c.edges[mod(i+1, n)]
						if (!(ep1.p == sp1 && ep2.p == sp2 || ep1.p == sp2 && ep2.p == sp1)) // not seg's edge
							continue
						let ep0 = last_perp_edge_point(c, i+0, n, -1, !v)
						let ep3 = last_perp_edge_point(c, i+1, n,  1, !v)
						if (!(ep0 || ep3))
							continue
						if (0) {
							// remove measurement of parallel wall of the same length
							let A = v ? 0 : 1 // index of cross axis of perp segs
							let dupe = ep0 && ep3 && ep0.p[A] == ep3.p[A]
							if (dupe)
								ep3 = null
						}
						if (ep0) perp_edges.push([ep0, ep1])
						if (ep3) perp_edges.push([ep2, ep3])
					}
				}
			}
			draw_state.measure_edges = perp_edges
			}

			let s = {}

			s.move = function(dx, dy, draw_state) {

				let dm = v ? dy : dx
				let da = v ? dx : dy

				if (move_freely) {

					let a = seg_axis(seg0) + da
					let sa = snap_lines.snap(a) ?? a
					a = sa ?? a

					// snap both end-points on main-axis.
					let m1 = seg_m1(seg0) + dm
					let m2 = seg_m2(seg0) + dm
					let m1s = m_snap_lines.snap(m1)
					let m2s = m_snap_lines.snap(m2)
					if (m1s != null && m2s != null) // both ends snapped
						if (abs(m1s - m1) <= abs(m2s - m2)) // pick the one closer to snap line
							m2s = null
						else
							m1s = null
					if (m1s != null)
						m2s = m1s + (seg_m2(seg0) - seg_m1(seg0))
					else if (m2s != null)
						m1s = m2s - (seg_m2(seg0) - seg_m1(seg0))

					seg[0][0] =  v ? a : m1s ?? m1
					seg[1][0] =  v ? a : m2s ?? m2
					seg[0][1] = !v ? a : m1s ?? m1
					seg[1][1] = !v ? a : m2s ?? m2

				} else { // move on cross axis

					let a = seg_axis(seg0) + (v ? dx : dy)
					let sa = snap_seg(a, ranges, snap_lines, draw_state, 20)
					a = sa ?? a
					set_seg_axis(seg, a)
					create_edges()

				}

			}

			s.stop = function(draw_state) {
				push_log()
				fix_level()
				pop_log('STOP MOVE SEG: {0}', seg.i)
				pr_log()
				draw_state.snap_lines.length = 0
				draw_state.measure_edges.length = 0
			}

			return s
		}
		level_plan.start_move_seg = start_move_seg

		function start_resize_seg(p, mx0, my0, dx, dy, sdx, sdy, draw_state) {

			// based on direction of drag, either detach a seg or add a seg, and start resizing it.
			push_log()

			let seg
			if (p) {
				// find seg in the drag direction around p.
				if (p.segs.length == 1 && is_v(p.segs[0]) == !!sdy) {
					// p is a free end-point and we're dragging along its main axis: resize it.
					seg = p.segs[0]
				} else {
					// find the seg around p in the direction of drag: that's the segment we want to detach and resize.
					seg = seg_around_point(p, sdx, sdy)
					if (seg) {
						// detach seg at branch point p so we can then resize it by its free end-point.
						let x = p[0] + dx * abs(sdx)
						let y = p[1] + dy * abs(sdy)
						let new_p = add_point(x, y)
						set_seg_point(seg, seg_pi(seg, p), new_p)
						p = new_p
					}
				}
			}

			if (!seg) { // create new seg, anchored to "hovered point" or to "mouse pos when clicked"
				let x1, y1
				if (p) {
					[x1, y1] = p
				} else {
					x1 = mx0
					y1 = my0
				}
				let x2 = x1 + dx * abs(sdx)
				let y2 = y1 + dy * abs(sdy)
				let p1 = add_point(x1, y1)
				let p2 = add_point(x2, y2)
				seg = add_seg(p1, p2)
				p = p2
			}

			let p0 = [...p]

			fix_level()

			pop_log('START RESIZE SEG: {0}', seg.i)
			pr_log()

			let ranges = seg_resize_ranges(seg, p)
			let snap_lines = snap_lines_for(!is_v(seg), seg)

			let s = {seg: seg}

			s.resize = function(dx, dy, draw_state) {
				let x1 = p0[0] + dx * abs(sdx)
				let y1 = p0[1] + dy * abs(sdy)

				let a = sdx ? x1 : y1
				let sa = snap_seg(a, ranges, snap_lines, draw_state, 30)
				if (sa != null)
					a = sa
				if (sdx)
					x1 = a
				else
					y1 = a
				p[0] = x1
				p[1] = y1
				create_edges()
			}

			s.stop = function(draw_state) {
				push_log()
				fix_level()
				pop_log('STOP RESIZE SEG: {0}', seg.i)
				pr_log()
				draw_state.snap_lines.length = 0
				draw_state.measure_edges.length = 0
			}

			return s
		}
		level_plan.start_resize_seg = start_resize_seg

		// init level_plan -----------------------------------------------------

		push_log()

		for (let i = 0, n = ps.length; i < n; i++)
			init_point(ps[i], i)

		let seg_i = 0
		for (let seg of segs) {
			seg.i = seg_i++
			for (let k = 0; k < 2; k++) {
				let i = seg[k]
				let p
				if (isarray(i)) // inline point
					p = add_point(...i)
				else
					p = check(ps[i], 'seg {0}/{1} invalid index {2}', seg.i, k, i)
				seg[k] = p
			}
		}
		remove_values(segs, seg => !seg[0] || !seg[1])

		rebuild_seg_refs()
		remove_angled_segs()
		fix_level()

		pop_log('LEVEL LOADED {0}', level.i)

		return level_plan
	}

	house_plan.level_plan = level_plan

	// face view UI ops ----------------------------------------------------

	function face_bb(plan, vert) { // returns (x1, y1, x2, y2, min_depth, max_depth)
		let [x1, y1, x2, y2] = plan_bb(plan)
		let h = 0
		for (let lv of plan.levels)
			h += lv.h
		if (vert)
			return [y1, 0, y2, h, x1, x2]
		else
			return [x1, 0, x2, h, y1, y2]
	}

	// init house_plan --------------------------------------------------------

	push_log()

	let i = 0
	for (let level of house_plan.levels)
		level.i = i++

	house_plan.bb = recompute_house_plan_bbox()

	pop_log('PLAN LOADED')
	pr_log()

	return house_plan

}

// shared scale --------------------------------------------------------------

function scaler() {
	let s = {}
	let st = 5 // thickness of wall line stroke at 1:1 scale
	let scale
	s.d = d => round(d * scale)
	s.x = x => round(x * scale)
	s.y = y => round(y * scale)
	s.plan_x = x => x / scale
	s.plan_y = y => y / scale
	s.plan_d = d => d / scale
	s.ep_x = e => s.x(e.p[0]) + s.d(e[0])
	s.ep_y = e => s.y(e.p[1]) + s.d(e[1])
	function set_scale(sc) {
		scale = sc
		s.scale = sc
		s.line_width = 1 + ((st * sc >> 1) * 2) // we seek an odd number for sharpness
	}
	s.scale_to_fit = function(bb, w, h) {
		if (s.zoomed) return
		w -= 2*st
		h -= 2*st
		let [x1, y1, x2, y2] = bb
		let bw = x2 - x1
		let bh = y2 - y1
		set_scale(min(
			scale,
			w / bw,
			h / bh
		))
		if (!s.panned) {
			s.x0 = -s.x(x1) + s.line_width // pixels from widget's origin
			s.y0 = -s.y(y1) + s.line_width // pixels from widget's origin
		}
	}
	s.set_scale = function(sc) {
		if (s.zoomed) return
		set_scale(sc)
	}
	s.zoom = function(d, xc, yc) { // zoom around (xc,yc) pixels from widget's origin
		if (!d) return
		d /= 150
		d *= 1.2

		let plan_xt = s.plan_x(-s.x0 + xc)
		let plan_yt = s.plan_y(-s.y0 + yc)

		set_scale(clamp(abs(scale * (d < 0 ? 1 / d : d)), 0.1, 10))

		let xt = s.x(plan_xt)
		let yt = s.y(plan_yt)

		s.x0 = -(xt - xc)
		s.y0 = -(yt - yc)

		s.zoomed = true
	}
	s.reset_zoom = function() {
		s.zoomed = false
		s.panned = false
	}
	return s
}

let scale_group = memoize(name => scaler())

// plan view -----------------------------------------------------------------

function draw_grid(cx, sg, x0, y0, w, h, step, dark_color, light_color) {
	if (!sg.show_grid)
		return
	if (sg.d(step) < 7)
		return
	let color = ui.dark() ? dark_color : light_color
	cx.strokeStyle = color
	for (let i = mod(sg.plan_x(x0), step), n = sg.plan_d(w); i < n; i += step) {
		cx.beginPath()
		cx.moveTo(sg.x(i), 0)
		cx.lineTo(sg.y(i), h-1)
		cx.stroke()
	}
	for (let i = mod(sg.plan_y(y0), step), n = sg.plan_d(h); i < n; i += step) {
		cx.beginPath()
		cx.moveTo(0, sg.x(i))
		cx.lineTo(w-1, sg.y(i))
		cx.stroke()
	}
}

// evaluate a line at time t using linear interpolation.
// the time between 0..1 covers the segment interval.
function point_on_line(t, x1, y1, x2, y2, out) {
	out[0] = x1 + t * (x2 - x1)
	out[1] = y1 + t * (y2 - y1)
	return out
}

let out = []
function draw_length(cx, sg, x1, y1, x2, y2) {

	let d = distance(x1, y1, x2, y2)
	if (sg.d(d) < 20)
		return

	let s = format_length(d)

	x1 = sg.x(x1)
	y1 = sg.y(y1)
	x2 = sg.x(x2)
	y2 = sg.y(y2)

	if (x1 > x2) {
		let x3 = x1
		let y3 = y1
		x1 = x2
		y1 = y2
		x2 = x3
		y2 = y3
	}
	let a = atan2(y2 - y1, x2 - x1)

	cx.save()

	cx.font = 'bold 14px sans-serif'
	let m = ui.measure_text(cx, '0.00m')
	let w = m.width

	let t1 = clamp((sg.d(d) - (w + 10)) / 2 / sg.d(d), 0, 1)
	let t2 = clamp((sg.d(d) + (w + 10)) / 2 / sg.d(d), 0, 1)

	if (!(t1 > 0 && t2 < 1)) {
		s = '...'
		w = 10
	}

	cx.translate(.5, .5)

	cx.beginPath()

	// left arrow
	let [x1a1, y1a1] = point_around(x1, y1, 8, a + 45*rad, out)
	let [x1a2, y1a2] = point_around(x1, y1, 8, a - 45*rad, out)
	let [x1e, y1e] = point_on_line(t1, x1, y1, x2, y2, out)

	cx.moveTo(x1  , y1)
	cx.lineTo(x1a1, y1a1)
	cx.moveTo(x1  , y1)
	cx.lineTo(x1a2, y1a2)
	cx.moveTo(x1  , y1)
	cx.lineTo(x1e , y1e)

	// right arrow
	let [x2a1, y2a1] = point_around(x2, y2, 8, a + (90+45)*rad, out)
	let [x2a2, y2a2] = point_around(x2, y2, 8, a - (90+45)*rad, out)
	let [x2e, y2e] = point_on_line(t2, x1, y1, x2, y2, out)
	cx.moveTo(x2  , y2)
	cx.lineTo(x2a1, y2a1)
	cx.moveTo(x2  , y2)
	cx.lineTo(x2a2, y2a2)
	cx.moveTo(x2  , y2)
	cx.lineTo(x2e , y2e)

	cx.strokeStyle = ui.fg_color('text')
	cx.stroke()

	let [xc, yc] = point_on_line(.5, x1, y1, x2, y2, out)
	cx.translate(xc, yc)
	cx.rotate(a)
	let tx = round(-w / 2)
	let ty = round((m.fontBoundingBoxAscent - m.fontBoundingBoxDescent) / 2)
	cx.translate(tx, ty)
	cx.fillStyle = ui.fg_color('text')
	cx.fillText(s, 0, 0)

	cx.restore()
}

let PLAN_VIEW_ID         = ui.S-1
let PLAN_VIEW_DRAW_STATE = ui.S+0

ui.box_widget('plan_view', {

	create: function(cmd, id, plan, fr, align, valign, min_w, min_h) {

		let s = ui.state(id)
		let draw_state = s.get('draw_state')
		if (!draw_state) {
			draw_state = {snap_lines: [], measure_edges: []}
			s.set('draw_state', draw_state)
		}
		s.set('plan', plan)

		let [dstate, dx, dy] = ui.drag(id)

		let sg = scale_group('editor')

		dx /= sg.scale
		dy /= sg.scale

		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {

			let hs = ui.hover(id)
			let cs = ui.captured(id)

			if (dstate == 'drag') {

				let action = hs.get('action')
				let seg    = hs.get('seg')
				let p      = hs.get('p')

				if (action == 'move_seg') { // move seg
					cs.set('move_seg', plan.start_move_seg(seg, draw_state))
				} else if (action == 'pan') {
					sg.pan_x0 = sg.x0
					sg.pan_y0 = sg.y0
					cs.set('action', action)
				}
			}

			let action = cs.get('action')

			if (!action && (abs(dx) >= 10 || abs(dy) >= 10)) { // dragged far enough to assume intent to drag.

				// establish direction of drag on x and y axis.
				let sdx = abs(dx) > 1.5 * abs(dy) ? sign(dx) : 0 // straight enough
				let sdy = abs(dy) > 1.5 * abs(dx) ? sign(dy) : 0 // straight enough
				if (sdx || sdy) {
					action = 'resize_seg'
					cs.set('action', action)
					let p   = cs.get('p')
					let mx0 = cs.get('x')
					let my0 = cs.get('y')
					let s = plan.start_resize_seg(p, mx0, my0, dx, dy, sdx, sdy, draw_state)
					cs.set('resize_seg', s)
				}

			}

			if (action == 'move_seg')
				cs.get('move_seg').move(dx, dy, draw_state)

			if (action == 'resize_seg')
				cs.get('resize_seg').resize(dx, dy, draw_state)

			if (action == 'pan') {
				sg.x0 = sg.pan_x0 + sg.d(dx)
				sg.y0 = sg.pan_y0 + sg.d(dy)
				sg.panned = true
			}

			if (dstate == 'drop') {
				if (action == 'move_seg') {
					cs.get('move_seg').stop(draw_state)
				} else if (action == 'resize_seg') {
					cs.get('resize_seg').stop(draw_state)
				}
			}

		}

		ui.stack()

			ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
					id, draw_state,
				)

			ui.m(ui.sp())
			ui.h(0, ui.sp05(), 's', 't')

				if (!ui.window_focused) {
					ui.p(ui.sp05(), 0)
					ui.stack('', 0)
						ui.font('far')
						ui.fs(ui.xlarge())
						ui.color('text')
						ui.text('', '\uf11c', 0, 'c', 'c')
						ui.polyline('', '0 5  35 20', 1, null, null, 'text', null, 2)
					ui.end_stack()
				}

				ui.v(1); ui.end()

				if (sg.zoomed) {
					if (ui.icon_button(id+'.zoom_button', 'fas', sg.scale > 1 ? '\uf00e' : '\uf010', 0, ']')) {
						sg.reset_zoom()
						ui.redraw()
					}
				}

				if (ui.icon_button(id+'.grid_button', 'fas', '\uf00a', 0)) {
					sg.show_grid = !sg.show_grid
					ui.animate()
				}

			ui.end_h()

		ui.end_stack()

	},

	after_position: function(a, i, axis)	{
		let sg = scale_group('editor')
		if (!axis) {
			sg.set_scale(1/0)
			return
		}
		let w  = a[i+2]
		let h  = a[i+3]
		let id = a[i+PLAN_VIEW_ID]
		let plan = ui.state(id).get('plan')
		sg.scale_to_fit(plan.house_plan.bb, w, h)
	},

	after_translate: function(a, i) {
		let x00 = a[i+0]
		let y00 = a[i+1]
		let id = a[i+PLAN_VIEW_ID]
		let draw_state = a[i+PLAN_VIEW_DRAW_STATE]

		let sg = scale_group('editor')
		let plan = ui.state(id).get('plan')

		draw_state.x0 = sg.x0
		draw_state.y0 = sg.y0
		draw_state.scale = sg.scale

		// pick what parts of the plan to send over the network for drawing
		// and in which format. note that the plan has arrays with props but
		// the props will not be sent over because of how json works.
		draw_state.comps = plan.comps
		draw_state.segs = plan.segs // TODO: remove this from draw stream
		draw_state.ps = plan.ps // TODO: remove this from draw stream
		draw_state.plan_snap_lines = plan.snap_lines
	},

	draw: function(a, i) {

		let x00   = a[i+0]
		let y00   = a[i+1]
		let w     = a[i+2]
		let h     = a[i+3]
		let id    = a[i+PLAN_VIEW_ID]
		let draw_state = a[i+PLAN_VIEW_DRAW_STATE]
		let x0 = draw_state.x0
		let y0 = draw_state.y0

		x00 += ui.focused(id) ? 100 : 0

		let hs = ui.hit(id)
		let cs = ui.captured(id)

		let sg = scale_group('editor')
		sg.set_scale(draw_state.scale)

		let cx = ui.cx
		cx.save()

		cx.beginPath()
		cx.rect(x00, y00, w, h)
		cx.clip()

		cx.translate(x00, y00)
		cx.font = 'bold 14px sans-serif'

		// fixed grid
		cx.save()
		cx.translate(.5, .5)
		// TODO: make this dynamic; show at most 3-levels based on zoom level
		// with dynamic lightness based on level.
		if (0) {
		for (let i = 0; i < 3; i++) {
			let step = (i == 0 ? 1 : i == 1 ? 5 : 10)
			let L = ui.dark() ? 1 : 0
			draw_grid(cx, sg, x0, y0, w, h,  10, hsl(0, 0, L))
		}
		}
		draw_grid(cx, sg, x0, y0, w, h,  10, '#222'   , '#eee')
		draw_grid(cx, sg, x0, y0, w, h,  50, '#282828', '#ddd')
		draw_grid(cx, sg, x0, y0, w, h, 100, '#333'   , '#ccc')
		cx.restore()

		// legend
		{
		let m = ui.em()
		let cm = 100
		let d = sg.d(cm)
		while (d > w - 2*m) {
			cm /= 5
			d = sg.d(cm)
		}
		cx.beginPath()
		let t = 4
		let x = w - d - m - t
		let y = h - m - t
		cx.rect(x, y, d, t)
		cx.fillStyle = ui.fg_color('label')
		cx.fill()
		let s = format_length(cm)
		let tw = ui.measure_text(cx, s).width
		cx.fillText(s, x + d - tw, y - 2)
		}

		cx.translate(x0, y0)

		// snap lines
		cx.setLineDash([5, 8])
		cx.strokeStyle = ui.dark() ? '#555' : '#999'
		for (let i = 0, sl = draw_state.snap_lines, n = sl.length; i < n; i += 2) {
			let sa   = sl[i]
			let is_v = sl[i+1]
			let x1, y1, x2, y2
			if (is_v) {
				x1 = sg.x(sa)
				x2 = sg.x(sa)
				y1 = -draw_state.y0
				y2 = -draw_state.y0 + h
			} else {
				y1 = sg.y(sa)
				y2 = sg.y(sa)
				x1 = -draw_state.x0
				x2 = -draw_state.x0 + w
			}
			cx.beginPath()
			cx.moveTo(x1+.5, y1+.5)
			cx.lineTo(x2+.5, y2+.5)
			cx.stroke()
		}
		cx.setLineDash([])

		// room backgrounds
		for (let co of draw_state.comps) {
			for (let c of co.cycles) {
				if (c.outer)
					continue
				if (!c.edges)
					continue
				cx.beginPath()
				for (let ep of c.edges) {
					let x = sg.ep_x(ep)
					let y = sg.ep_y(ep)
					if (ep == c.edges[0])
						cx.moveTo(x, y)
					else
						cx.lineTo(x, y)
				}
				cx.closePath()
				cx.fillStyle = ui.alpha_adjust(ui.bg_color_hsl('bg1', hs?.get('cycle') == c ? 'hover' : null), .5)
				cx.fill()
			}
		}

		// walls
		for (let comp of draw_state.comps) {

			cx.beginPath()

			for (let c of comp.cycles) {
				if (c.edges) {
					for (let ep of c.edges) {
						let [dx, dy] = ep
						let [x0, y0] = ep.p
						let x = sg.x(x0) + sg.d(dx)
						let y = sg.y(y0) + sg.d(dy)
						if (ep == c.edges[0])
							cx.moveTo(x, y)
						else
							cx.lineTo(x, y)
					}
					cx.closePath()
				}
			}

			if (!cx.wall_pattern) {
				let w = 100
				let c = new OffscreenCanvas(w, w)
				let x = c.getContext('2d')
				let g = x.createLinearGradient(0, 0, w, 2*w)
				for (let i = 0, n = 2*w; i <= n; i += 4) {
					g.addColorStop(clamp((i - 1) / n, 0, 1), 'white')
					g.addColorStop(clamp((i + 0) / n, 0, 1), 'gray')
					g.addColorStop(clamp((i + 1) / n, 0, 1), 'white')
				}
				x.rect(0, 0, w, w)
				x.fillStyle = g
				x.fill()
				cx.wall_pattern = cx.createPattern(c, 'repeat')
			}
			cx.lineWidth = DEBUG_PLAN ? 1 : sg.line_width
			cx.strokeStyle = 'black' //ui.fg_color('text')
			cx.lineJoin = 'round'
			cx.stroke()
			cx.lineJoin = 'miter'
			cx.lineWidth = 1
			cx.fillStyle = DEBUG_PLAN ? '#333' : cx.wall_pattern
			cx.fill('nonzero')
		}

		// cycles area
		if (sg.scale > 0.4)
			for (let co of draw_state.comps) {
				for (let c of co.cycles) {
					if (c.area) {
						let [x, y] = c.area_pos
						x = sg.x(x)
						y = sg.y(y)
						cx.fillStyle = ui.fg_color('label')
						cx.fillText(format_area(c.area), x, y+5)
					}
				}
			}

		// hit seg
		let hit_seg    = hs?.get('seg')
		let hit_action = hs?.get('action')
		if (hit_seg && !hit_action) {
			let x = sg.x(hs.get('x'))
			let y = sg.y(hs.get('y'))
			cx.beginPath()
			cx.arc(x, y, 3, 0, 2*PI)
			cx.strokeStyle = 'black'
			cx.lineWidth = 3
			cx.stroke()
			cx.lineWidth = 1
			cx.fillStyle = 'white'
			cx.fill()
		}

		// edge measurements
		let me = draw_state.measure_edges
		if (me) {
			for (let [ep1, ep2] of me) {
				let x1 = ep_x(ep1)
				let y1 = ep_y(ep1)
				let x2 = ep_x(ep2)
				let y2 = ep_y(ep2)
				pr(ep1.ci, ep2.ci, x1, y1, x2, y2)
				;[x1, y1, x2, y2] = line_offset(-10, x1, y1, x2, y2, [])
				draw_length(cx, sg, x1, y1, x2, y2)
			}
		}

		// hit point
		let hit_p = hs?.get('p')
		if (hit_p) {
			let x = sg.x(hit_p[0])
			let y = sg.y(hit_p[1])
			cx.beginPath()
			cx.arc(x, y, 3, 0, 2*PI)
			cx.strokeStyle = 'black'
			cx.lineWidth = 3
			cx.stroke()
			cx.lineWidth = 1
			cx.fillStyle = 'white'
			cx.fill()
		}

		// orthogonal measurements
		if (0)
		for (let i = 0; i < 2; i++) {
			for (let m of draw_state.plan_snap_lines[i]) {
				let x = sg.x(i == 0 ? m : -50)
				let y = sg.y(i == 1 ? m : -20)
				cx.save()
				cx.translate(x, y)
				//if (i == 0)
					cx.rotate(-PI/4)
				cx.fillStyle = 'white' //ui.fg_color('label')
				cx.strokeStyle = 'black'
				cx.shadowBlur = 4
				cx.shadowColor = 'black'
				let s = format_length(m)
				cx.fillText(s, 0, 0)
				cx.restore()
			}
		}

		// cursor
		let action = cs?.get('action')
		let seg = action == 'move_seg' && cs.get('seg') || (hit_action == 'move_seg' && hs?.get('seg'))
		if (seg) {
			if (seg[0].segs.length == 1 && seg[1].segs.length == 1)
				ui.set_cursor('move')
			else
				ui.set_cursor(is_v(seg) ? 'ew-resize' : 'ns-resize')
		} else if (hs?.get('p'))
			ui.set_cursor(hs.get('p_seg') ? 'alias' : 'copy')
		else if (action == 'pan')
			ui.set_cursor('grabbing')
		else if (hs) {
			if (hit_action == 'pan')
				ui.set_cursor('grab')
			else
				ui.set_cursor('copy')
		}

		// DEBUG ---------------------------------------------------------------

		// segment lines and segment numbers
		if (DEBUG_PLAN)
		for (let seg of draw_state.segs) {
			let p1 = seg[0]
			let p2 = seg[1]
			cx.beginPath()
			let x1 = sg.x(p1[0])
			let y1 = sg.y(p1[1])
			let x2 = sg.x(p2[0])
			let y2 = sg.y(p2[1])
			cx.moveTo(x1, y1)
			cx.lineTo(x2, y2)
			cx.strokeStyle = hit_seg == seg ? 'white' : '#666'
			cx.stroke()

			let [x0, y0] = seg_center(seg)
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = '#f66'
			cx.fillText(seg.i, x, y)
		}

		// point numbers
		if (DEBUG_PLAN)
		for (let p of draw_state.ps) {
			let [x0, y0] = p
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = 'white'
			cx.fillText(p.i, x, y)
		}

		// edge point numbers
		if (0 && DEBUG_PLAN)
		for (let c of draw_state.comps) {
			let co = c // no var shadowing because langauge designers are dumb
			for (let c of co.cycles) {
				for (let ep of c.edges) {
					let x = sg.ep_x(ep) - 5
					let y = sg.ep_y(ep) + 15
					cx.fillStyle = '#0f0'
					cx.fillText(c.i+'/'+ep.ci, x, y)
				}
			}
		}

		cx.restore()
	},

	hit: function(a, i) {

		let x00 = a[i+0]
		let y00 = a[i+1]
		let w   = a[i+2]
		let h   = a[i+3]
		let id  = a[i+PLAN_VIEW_ID]
		let draw_state = a[i+PLAN_VIEW_DRAW_STATE]

		if (ui.captured_id != null)
			return

		if (!ui.hit_box(a, i))
			return

		let hs = ui.hover(id)
		if (!hs)
			return

		let sl = draw_state.snap_lines
		sl.length = 0

		let sg = scale_group('editor')

		let cx = ui.cx

		let nosnap = ui.key('shift')

		sg.zoom(ui.wheel_dy,
			ui.mx - x00,
			ui.my - y00
		)

		if (nosnap) {
			hs.set('action', 'pan')
			return
		}

		cx.save()
		cx.translate(x00, y00)
		cx.translate(draw_state.x0, draw_state.y0)
		ui.update_mouse()

		let snap_margin = 15

		let hit_p
		for (let p of draw_state.ps) {
			let dx = ui.mx - sg.x(p[0])
			let dy = ui.my - sg.y(p[1])
			let snap_d = nosnap ? 2 : sg.d(p.max_offset) + sg.line_width + snap_margin
			if (abs(dx) <= snap_d && abs(dy) <= snap_d) {
				hit_p = p
				hs.set('p', p) // point to start new seg from
				sl.push(p[0], 1, p[1], 0)
				break
			}
		}

		let hit_seg
		if (!hit_p)
			for (let seg of draw_state.segs) {

				let x1 = seg[0][0]
				let y1 = seg[0][1]
				let x2 = seg[1][0]
				let y2 = seg[1][1]
				let v = is_v(seg)

				let sx1, sy1, sx2, sy2 // screen hit box

				// test over the seg's area between its offset edges.
				let m = sg.line_width
				if (v) {
					let x = x1
					sx1 = sg.x(x + seg[y1 < y2 ? -2 : -1]) - m
					sx2 = sg.x(x - seg[y1 < y2 ? -1 : -2]) + m
					sy1 = sg.y(seg_y1(seg))
					sy2 = sg.y(seg_y2(seg))
				} else if (y1 == y2) {
					let y = y1
					sy1 = sg.y(y + seg[x1 > x2 ? -2 : -1]) - m
					sy2 = sg.y(y - seg[x1 > x2 ? -1 : -2]) + m
					sx1 = sg.x(seg_x1(seg))
					sx2 = sg.x(seg_x2(seg))
				} else {
					continue
				}
				if (ui.hit_bb(sx1, sy1, sx2, sy2)) {
					hit_seg = seg
					hs.set('seg', seg)
					hs.set('action', 'move_seg')
					break
				}

				// try a wider area and compute the point of the mouse projected on the seg.
				if (v) {
					sx1 -= snap_margin
					sx2 += snap_margin
				} else {
					sy1 -= snap_margin
					sy2 += snap_margin
				}
				if (ui.hit_bb(sx1, sy1, sx2, sy2)) {
					hit_seg = seg
					hs.set('seg', seg)
					let sx = !v ? sg.plan_x(ui.mx) : null
					let sy = v  ? sg.plan_y(ui.my) : null
					hs.set('x', sx ?? x1)
					hs.set('y', sy ?? y1)
					if (sx != null) sl.push(sx, 1)
					if (sy != null) sl.push(sy, 0)
					break
				}

			}

		if (!hit_p && !hit_seg) {

			let x = sg.plan_x(ui.mx)
			let y = sg.plan_y(ui.my)

			// hit snapping point
			let [sx, sy] = ui.state(id).get('plan').snap_point(x, y, nosnap)
			hs.set('x', sx ?? x)
			hs.set('y', sy ?? y)
			if (sx != null) sl.push(sx, 1)
			if (sy != null) sl.push(sy, 0)

			// hit inner cycle
			let hit_comp, hit_cycle
			for (let co of draw_state.comps) {
				for (let c of co.cycles) {
					if (!c.edges)
						continue
					if (c.outer)
						continue
					if (point_inside_poly(x, y, c)) {
						hit_comp = co
						hit_cycle = c
						hs.set('comp', co)
						hs.set('cycle', c)
						break
					}
				}
				if (hit_cycle)
					break
			}
		}

		cx.restore()
		ui.update_mouse()

	},

})

// face view -----------------------------------------------------------------

let FACE_VIEW_ID   = ui.S-1
let FACE_VIEW_PLAN = ui.S+0
let FACE_VIEW_FACE = ui.S+1

ui.box_widget('face_view', {

	create: function(cmd, id, plan, face, fr, align, valign, min_w, min_h) {

		let [dstate, dx, dy] = ui.drag(id)

		return ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
				id, plan, face
			)
	},

	draw: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let plan = a[i+FACE_VIEW_PLAN]
		let face = a[i+FACE_VIEW_FACE]

		return

		// face is 1,2,3,4 going clockwise from the left-to-right face.
		let face_vert = (face-1) & 1
		let face_sign = face <= 2 ? 1 : -1

		let [scale, face_x, face_y, min_depth, max_depth] = face_scale(plan, face_vert, w, h)

		let hs = ui.hit(id)

		let cx = ui.cx

		cx.beginPath()

		cx.save()

		cx.translate(x00, y00)
		cx.translate(-face_x, -face_y)

		let walls = sort_face_walls(plan, face_vert, face_sign)

		for (let level_num = plan.levels.length-1; level_num >= 0; level_num--) {

			let lv = plan.levels[level_num]
			let h = pix(lv.h, scale)

			// draw walls (offset face) in depth order.
			let X = face_vert ? 1 : 0
			let Y = face_vert ? 0 : 1
			for (let [wr, i] of walls) {

				if ((wr.level ?? 0) != level_num)
					continue

				let [x, y, w, h, z] = wall_face_rect(plan, lv, wr, i, scale)

				let depth = lerp(z, min_depth * scale, max_depth * scale, 0, 1)

				cx.beginPath()
				cx.rect(x, y, w, h)
				cx.fillStyle = ui.hsl_adjust(ui.bg_color_hsl('bg3'), 1, 1, depth, 1 - depth/4)
				cx.fill()

				cx.beginPath()
				cx.rect(x + .5, .5, w, h)
				cx.strokeStyle = ui.fg_color('text')
				cx.stroke()

				// draw openings.
				let wall = wr.walls[i]
				let ops = wall.openings
				if (ops) {
					for (let op of ops) {

						let [x, y, w, h] = opening_face_rect(op, wr, i, lv, scale)

						cx.save()
						cx.translate(x, y)

						cx.beginPath()
						cx.rect(0, 0, w, h)
						cx.fillStyle = ui.bg_color('bg')
						cx.fill()

						let op_class = comp[op.type]
						op_class.draw_face(cx, op, w, h, hs)

						cx.restore()
					}
				}

			}

			cx.translate(0, h)

		}

		cx.restore()

	},

	hit: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let plan = a[i+FACE_VIEW_PLAN]
		let face = a[i+FACE_VIEW_FACE]

		return

		// face is 1,2,3,4 going clockwise from the left-to-right face.
		let face_vert = (face-1) & 1
		let face_sign = face <= 2 ? 1 : -1

		let hs = ui.hit(id)
		let cs = ui.captured(id)

		if (!cs) {

			let [scale, face_x, face_y] = face_scale(plan, face_vert, w, h)

			let cx = ui.cx

			cx.save()
			cx.translate(x00, y00)
			cx.translate(-face_x, -face_y)
			ui.update_mouse()

			let walls = sort_face_walls(plan, face_vert, face_sign)
			walls.reverse()

			let y = 0
			for (let level_num = plan.levels.length-1; level_num >= 0; level_num--) {

				let lv = plan.levels[level_num]

				if (hit_face(plan, lv, level_num, walls, id, scale, true))
					break

				y += pix(lv.h, scale)
				cx.translate(0, y)
				ui.update_mouse()
			}

			cx.restore()
			ui.update_mouse()

		}

	},

})

// test UI -------------------------------------------------------------------

G.test_plan = house_plan({

	levels: [
		{
			segs: [
				// outside rect
				[[0,0],[500,0]],
				[[500,0],[500,500]],
				[[500,500],[0,500]],
				[[0,500],[0,0]],

				[[0,300],[500,300]],
				[[0,200],[300,200]],
				[[200,0],[200,400]],

				// peninsula
				[[300,200],[300,100]],
				[[300,100],[400,100]],
				[[400,100],[400,200]],
				[[400,200],[300,200]],

				[[200,400],[300,400]],

				[[500,300],[600,300]],
				[[600,300],[600,400],],
				[[600,300],[700,300]],

				// island for testing inside check

				// [[0,600],[300,600]],
				// [[300,600],[300,900]],
				// [[300,900],[0,900]],
				// [[0,900],[0,600]],

				// [[100,650],[200,650]],
				// [[200,650],[200,800]],
				// [[200,800],[100,800]],
				// [[100,800],[100,650]],

				// brick-like-layout for testing seg detach on seg move

				// [[700,500],[700,1000]],
				// [[700,1000],[1200,1000]],
				// [[1200,1000],[1200,500]],
				// [[1200,500],[700,500]],
				// [[900,500],[900,1000]],
				// [[700,600],[900,600]],
				// [[700,800],[900,800]],
				// [[900,700],[1200,700]],
			],
		},
		{
			segs: [
				[[100,300],[400,300]],
				[[100,300],[100,100]],
			],
		},
	],

})

ui.main = function() {

	ui.m(20)

	ui.v()

		ui.h(0, ui.sp05())

			if (ui.button('debug_plan_button', 'DEBUG', 0))
				DEBUG_PLAN = !DEBUG_PLAN

			if (ui.button('btn_light', 'lights', 0))
				ui.default_theme = ui.default_theme == 'light' ? 'dark' : 'light'

		ui.end_h()

		ui.h()

			for (let i = test_plan.levels.length-1; i >= 0; i--) {
				ui.m(10)
				ui.stack()
					ui.bb('', null, null, 1, 'light')
					ui.plan_view('pv'+i, test_plan.level_plan(test_plan.levels[i]))
				ui.end_stack()
			}

			/*
			ui.v()

				for (let face = 1; face <= 4; face++) {
					ui.m(10)
					ui.stack()
						ui.bb('', null, null, 1, 'light')
						//ui.face_view('fv'+face, test_plan, face)
					ui.end_stack()
				}

			ui.end_v()
			//ui.comps()
			*/

		ui.end_h()

	ui.end_v()

}

DEBUG_PLAN = 0

}()) // module function

</script>
</body>
</html>
