<!DOCTYPE html>
<html theme=dark>
<body>
<base href="www2/">
<link rel="preload" href="fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="fa-solid-900.woff2"   as="font" type="font/woff2" crossorigin>
<script src=glue.js global extend></script>
<script src=ui.js></script>
<script src=ui_validation.js></script>
<script src=ui_nav.js></script>
<script src=ui_grid.js></script>
<script>

function wall_x_direct(a, i) {
	let vert = i & 1
	return a[mod(i-2+vert, a.length)].to
}

function wall_y_direct(a, i) {
	let vert = i & 1
	return a[mod(i-1-vert, a.length)].to
}

function wall_x(a, i, o) {
	assert(!o)
	return wall_x_direct(a, i)
}

function wall_y(a, i, o) {
	assert(!o)
	return wall_y_direct(a, i)
}

function wall_X(a, i) { return a[mod(i  , a.length)].to }
function wall_Y(a, i) { return a[mod(i-1, a.length)].to }

function wall_set_X(a, i, v) { a[mod(i  , a.length)].to = v }
function wall_set_Y(a, i, v) { a[mod(i-1, a.length)].to = v }

function wall_point_direct(a, i) {
	let vert = i & 1
	let n = a.length
	let ix = mod(i-2+vert, n)
	let iy = mod(i-1-vert, n)
	return [a[ix].to, a[iy].to]
}

function wall_line(a, i) { // points in draw order
	let vert = i & 1
	let n = a.length
	let ix1 = mod(i-2+vert, n)
	let iy1 = mod(i-1-vert, n)
	let ix2 = mod(i+0-vert, n)
	let iy2 = mod(i-1+vert, n)
	return [a[ix1].to, a[iy1].to, a[ix2].to, a[iy2].to]
}

function wall_vert  (a, i) { return i & 1 }
function wall_horiz (a, i) { return 1-(i & 1) }

function wall_sign(a, i) {
	let n = a.length
	let iX1 = mod(i-2, n)
	let iX2 = mod(i+0, n)
	return sign(a[iX2].to - a[iX1].to)
}

function wall_point(a, i, oX, oY) {
	oY = oY ?? oX
	let p = wall_point_direct(a, i)
	if (!(oX || oY))
		return p
	let h1 = wall_horiz(a, i)
	let s1 = wall_sign (a, i+0)
	let s0 = wall_sign (a, i-1)
	let sx = 0
	let sy = 0
	if (s1 == s0) {
		sx =  s1
		sy = -s1
	} else {
		sx = (s1 < s0) == h1 ? 1 : -1
		sy = sx
	}
	let ox = h1 ? oX : oY
	let oy = h1 ? oY : oX
	p[0] += sx * ox
	p[1] += sy * oy
	return p
}

function wall_offset_sign(a, i) {
	let h = wall_horiz(a, i)
	let s = wall_sign (a, i)
	return h ? -s : s
}

function overlap_segs(_a1, _a2, _b1, _b2) {
	let a1 = min(_a1, _a2)
	let a2 = max(_a1, _a2)
	let b1 = min(_b1, _b2)
	let b2 = max(_b1, _b2)
	return !(a2 <= b1 || b2 <= a1)
}

function wall_lines(a, i, o) { // lines in screen order, points in draw order
	let p1  = wall_point(a, i+0)
	let p2  = wall_point(a, i+1)
	let op1 = wall_point(a, i+0, o)
	let op2 = wall_point(a, i+1, o)
	if (wall_offset_sign(a, i) < 0)
		return [op1, op2, p1, p2]
	else
		return [p1, p2, op1, op2]
}

function wall_rect(a, i, o) {
	let p1  = wall_point(a, i+0)
	let p2  = wall_point(a, i+1)
	let op1 = wall_point(a, i+0, o)
	let op2 = wall_point(a, i+1, o)
	let h   = wall_horiz(a, i)
	let X = h ? 0 : 1
	let Y = h ? 1 : 0
	let r = [0, 0, 0, 0]
	r[X+0] = min(p1[X], op1[X], p2[X], op2[X])
	r[X+2] = max(p1[X], op1[X], p2[X], op2[X])
	r[Y+0] = min(p1[Y], op1[Y])
	r[Y+2] = max(p1[Y], op1[Y])
	return r
}

let comp = {}

comp.opening = {}

comp.opening.plan_rect = function(e, wall_run, i) {
	let t = wall_run.thickness ?? 5
	let r = [e.sx, e.sy || 0, e.w, t, 0]
	let a = wall_run.segments
	if (i != null) {
		let p1    = wall_point       (a, i)
		let horiz = wall_horiz       (a, i)
		let dir   = wall_sign        (a, i)
		let odir  = wall_offset_sign (a, i)
		let X = horiz ? 0 : 1
		let Y = horiz ? 1 : 0
		r[X] = p1[X] + (dir > 0 ? e.d : -(e.d + e.w))
		r[Y] = p1[Y] + (odir > 0 ? 0 : -t)
		if (!horiz) {
			r[4] = 90 * rad
			r[0] += t
		}
	}
	return r
}

comp.opening.face_rect = function(e, wall_run, wall_i) {
	let t = wall_run.thickness
	let r = [e.x, wall_run.h - e.h - (e.y || 0), e.w, e.h]
	let a = wall_run.segments
	if (wall_i != null) {
		let p1    = wall_point       (a, wall_i)
		let horiz = wall_horiz       (a, wall_i)
		let dir   = wall_sign        (a, wall_i)
		let odir  = wall_offset_sign (a, wall_i)
		let X = 1-horiz
		let Y = horiz
		r[0] = p1[X] + (dir > 0 ? e.d : -(e.d + e.w))
	}
	return r
}

function moving_ranges(plan, wall_run, ti1) {
	let o = wall_run.thickness
	let a = wall_run.segments
	let n = a.length
	let ti0 = mod(ti1-1, n)
	let ti2 = mod(ti1+1, n)
	let p1 = wall_point(a, ti1)
	let p2 = wall_point(a, ti2)
	let h  = wall_horiz(a, ti1)
	let X = h ? 0 : 1
	let Y = h ? 1 : 0
	let tl = wall_lines(a, ti1, o)

	// collision with other walls
	let rangeY = [-1/0, 1/0]
	for (let wall_run1 of plan.wall_runs) {
		let a = wall_run1.segments
		let n = a.length
		for (let i1 = 0; i1 < n; i1++) {
			if (wall_run1 == wall_run && (i1 == ti1 || i1 == ti0 || i1 == ti2))
				continue
			let r = wall_rect(a, i1, o)

			if (r[Y+2] <= tl[0][Y]) // rect bottom side < top of the wall
				if (overlap_segs(tl[0][X], tl[1][X], r[X], r[X+2])) {
					let minY = r[Y+2]+1
					if (tl[0][Y] < p1[Y]) // offset side up
						minY += o
					rangeY[0] = max(rangeY[0], minY)
				}

			if (r[Y+0] >= tl[2][Y]) // rect top side > bottom of the wall
				if (overlap_segs(tl[2][X], tl[3][X], r[X], r[X+2])) {
					let maxY = r[Y+0]-1
					if (tl[2][Y] > p1[Y]) // offset side down
						maxY -= o
					rangeY[1] = min(rangeY[1], maxY)
				}

		}
	}
	return [rangeY]
}

function begin_closed_wall_path(cx, a, t) {

	let n = a.length

	cx.beginPath()

	// draw offset path clockwise.
	for (let i = 0; i < n; i++) {
		let [x, y] = wall_point(a, i, t)
		if (i == 0)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()

	// draw inner path counterclockwise.
	for (let i = n-1; i >= 0; i--) {
		let x = wall_x(a, i)
		let y = wall_y(a, i)
		if (i == n-1)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()
}

function begin_open_wall_path(cx, a, t) {

	let n = a.length-1

	cx.beginPath()

	// draw non-offset path.
	for (let i = 0; i < n; i++) {
		let [x, y] = wall_point(a, i)
		if (i == 0)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}

	// draw offset path in reverse.
	for (let i = n-1; i >= 0; i--) {
		let [x, y] = wall_point(a, i, t, i == 0 || i == n-1 ? 0 : t)
		cx.lineTo(x, y)
	}

	cx.closePath()
}

function draw_wall_openings(cx, wall_run, hs) {
	let wall_i = 0
	for (let wall of wall_run.segments) {
		if (wall.openings) {
			for (let op of wall.openings) {
				let [x, y, w, h, rotation] = comp.opening.plan_rect(op, wall_run, wall_i)

				cx.save()
				cx.translate(x, y)
				cx.rotate(rotation)

				cx.beginPath()
				cx.rect(0, 0, w, h)
				cx.fillStyle = ui.bg_color('bg')
				cx.fill()

				if (op.type == 'window') {
					cx.beginPath()
					cx.rect(.5, .5 - 4.5, w, h + 4.5)
					cx.moveTo(    .5, round(h / 3) - .5)
					cx.lineTo(w - .5, round(h / 3) - .5)
				} else if (op.type == 'door') {
					cx.beginPath()
					cx.arc(.5, round(h / 2) + .5, w - .5, 0, (op.swing ?? 90) * rad)
					cx.lineTo(.5, round(h / 2) - .5)
				}
				cx.strokeStyle = ui.fg_color('text', hs && hs.get('opening') == op ? 'hover' : null)
				cx.stroke()

				cx.restore()
			}
		}
		wall_i++
	}
}

function draw_walls(cx, plan, hs) {

	// draw walls
	for (let wall_run of plan.wall_runs) {
		let t = wall_run.thickness * (wall_run.offset_sign ?? 1)
		let a = wall_run.segments
		if (wall_run.closed)
			begin_closed_wall_path(cx, a, t)
		else
			begin_open_wall_path(cx, a, t)

		//cx.lineWidth = 1
		// cx.strokeStyle = ui.fg_color('text')
		// cx.stroke()
		cx.fillStyle = ui.bg_color('bg3')
		cx.fill()

		draw_wall_openings(cx, wall_run, hs)

	}
}

function draw_facade(cx, plan, horiz, sign, hs) {

	// sort walls by depth.
	let walls = []
	for (let wall_run of plan.wall_runs) {
		if (!wall_run.exterior)
			continue
		let a = wall_run.segments
		for (let i = 0, n = a.length; i < n; i++) {
			if (wall_horiz(a, i) != horiz)
				continue
			if (wall_sign(a, i) != sign)
				continue
			walls.push([wall_run, i])
		}
	}
	walls.sort(function(e1, e2) {
		let y1 = wall_Y(e1[0].segments, e1[1])
		let y2 = wall_Y(e2[0].segments, e2[1])
		return y1 < y2 ? sign : y1 > y2 ? -sign : 0
	})

	// draw walls in depth order.
	let X = horiz ? 0 : 1
	let Y = horiz ? 1 : 0
	for (let [wall_run, i] of walls) {
		let a = wall_run.segments
		let t = wall_run.thickness
		let p1 = wall_point(a, i+0, t)
		let p2 = wall_point(a, i+1, t)
		let x1 = p1[X]
		let x2 = p2[X]
		let x = min(x1, x2)
		let w = max(x1, x2) - x
		let y = p1[Y]
		let h = wall_run.h

		cx.beginPath()
		cx.rect(x, 0, w, h)
		cx.fillStyle = ui.hsl_adjust(ui.bg_color_hsl('bg3'), 1, 1, p1[Y] / 500)
		cx.fill()

		cx.beginPath()
		cx.rect(x + .5, .5, w, h)
		cx.strokeStyle = ui.fg_color('text')
		cx.stroke()

		// draw openings.
		let wall = a[i]
		let ops = wall.openings
		if (ops) {
			for (let op of ops) {

				let [x, y, w, h] = comp.opening.face_rect(op, wall_run, i)

				cx.save()
				cx.translate(x, y)

				cx.beginPath()
				cx.rect(0, 0, w, h)
				cx.fillStyle = ui.bg_color('bg')
				cx.fill()

				if (op.type == 'window') {
					cx.beginPath()
					cx.rect(.5, .5, w, h)
				} else if (op.type == 'door') {
					cx.beginPath()
					cx.rect(.5, .5, w, h)
				}
				cx.strokeStyle = ui.fg_color('text', hs && hs.get('opening') == op ? 'hover' : null)
				cx.stroke()

				cx.restore()
			}
		}

	}

}

function hit_opening(wall_run, x00, y00, id) {
	let wall_i = -1
	for (let wall of wall_run.segments) {
		wall_i++
		if (!wall.openings)
			continue
		for (let op of wall.openings) {
			let [x, y, w, h, rotation] = comp.opening.plan_rect(op, wall_run, wall_i)

			let cx = ui.cx
			cx.save()
			cx.translate(x00 + x, y00 + y)
			cx.rotate(rotation)
			ui.update_mouse()
			let hit = ui.hit_rect(- 5, - 5, w + 10, h + 10)
			cx.restore()
			ui.update_mouse()

			if (hit) {
				let hs = ui.hover(id)
				hs.set('opening', op)
				return true
			}
		}
	}
}

function hit_walls(wall_run, x00, y00, id) {
	let a = wall_run.segments
	for (let i = 0, n = a.length; i < n; i++) {
		let x  = x00 + wall_x(a, i+0)
		let y  = y00 + wall_y(a, i+0)
		let x2 = x00 + wall_x(a, i+1)
		let y2 = y00 + wall_y(a, i+1)
		let h = y2 == y
		if (
			(!h && abs(ui.mx - x) < 5 && ui.my >= min(y, y2) && ui.my <= max(y, y2)) ||
			( h && abs(ui.my - y) < 5 && ui.mx >= min(x, x2) && ui.mx <= max(x, x2))
		) {
			let hs = ui.hover(id)
			hs.set('wall_run', wall_run)
			hs.set('pi', i)
			hs.set('side', h ? 'y' : 'x')
			return true
		}
	}
}

let PLAN_ID     = ui.S-1
let PLAN_STRUCT = ui.S+0

ui.box_widget('plan', {

	create: function(cmd, id, fr, align, valign, min_w, min_h, plan) {

		let [dstate, dx, dy] = ui.drag(id)

		let hs = ui.hovers(id)
		let cs = ui.captured(id)
		let cursors = {x: 'ew-resize', y: 'ns-resize'}

		if (dstate == 'hover') {
			let side = hs.get('side')
			if (side)
				ui.set_cursor(cursors[side])
			let opening = hs.get('opening')
			if (opening) {
				ui.set_cursor('move')
			}
		}
		if (dstate == 'drag') {
			let side = hs.get('side')
			if (side) {
				let wall_run = hs.get('wall_run')
				let pi = hs.get('pi')
				let a = wall_run.segments
				ui.set_cursor(cursors[side])
				cs.set('side', side)
				cs.set('pi'  , pi)
				cs.set('px0' , wall_x(a, pi))
				cs.set('py0' , wall_y(a, pi))
				cs.set('rs'  , moving_ranges(plan, wall_run, pi))
			}
			let opening = hs.get('opening')
			if (opening) {
				cs.set('opening', opening)
			}
		}
		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {
			let side = cs.get('side')
			if (side) {
				let a  = cs.get('wall_run').segments
				let pi = cs.get('pi')
				let rs = cs.get('rs')
				ui.set_cursor(cursors[side])
				let X = side == 'x' ? 0 : 1
				let dX = X ? dy : dx
				let pX = cs.get(X ? 'py0' : 'px0') + dX
				let r = rs[0]
				pX = clamp(pX, r[0], r[1])
				wall_set_X(a, pi-1, pX)
			}
			let opening = cs.get('opening')
			if (opening) {
				//
			}
		}

		return ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
				id, plan
			)
	},

	draw: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+PLAN_ID]
		let plan = a[i+PLAN_STRUCT]

		let hs = ui.hit(id)

		let cx = ui.cx

		cx.beginPath()

		cx.translate(x00, y00)

		draw_walls(cx, plan, hs)

		cx.translate(0,  500)
		draw_facade(cx, plan, 1, -1, hs)
		cx.translate(0, -500)

		cx.translate(0,  600)
		draw_facade(cx, plan, 1, 1, hs)
		cx.translate(0, -600)

		cx.translate( 500, 0)
		draw_facade(cx, plan, 0, 1, hs)
		cx.translate(-500, 0)

		cx.translate(500 ,  100)
		draw_facade(cx, plan, 0, -1, hs)
		cx.translate(-500, -100)

		cx.translate(-x00, -y00)

	},

	hit: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+PLAN_ID]
		let plan = a[i+PLAN_STRUCT]

		let hs = ui.hovers(id)
		let cs = ui.captured(id)

		if (!cs) {

			for (let wall_run of plan.wall_runs)
				if (hit_opening(wall_run, x00, y00, id))
					return

			for (let wall_run of plan.wall_runs)
				if (hit_walls(wall_run, x00, y00, id))
					return

		}

	},

})

let plan = {
	wall_runs: [
		{
			h: 80,
			exterior: true,
			closed: true,
			thickness: 5,
			segments: [
				{to: 100,},
				{to: 100,},
				{to: 200,},
				{to: 200,},
				{to: 100, openings: [
					{type: 'door', d: 20, w: 50, h: 70},
				]},
				{to: 300,},
				{to: 150,},
				{to: 400,},
				{to:   0,},
				{to:   0, openings: [
					{type: 'window', d: 50, w: 150, h: 50, y: 20},
				]},
			],
		},
		{
			h: 80,
			thickness: 3,
			offset_sign: 1,
			segments: [
				{to: 100}, // "null" horizontal wall because we always start horizontal
				{to: 150},
				{to: 0, openings: [
					{type: 'door', d: 10, w: 40, h: 70, swing: 45},
				]},
				{to: 100}, // y0
				{to: 100}, // x0
			],
		},
	],
}

ui.main = function() {

	ui.m(100)
	ui.v()
		ui.plan('p1', 1, null, null, null, null, plan)
	ui.end_v()

}

</script>
</body>
</html>
