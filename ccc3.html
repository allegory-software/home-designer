<!DOCTYPE html>
<html theme=dark>
<head>
<base href="www2/">
<link rel="icon" href="../www/favicon1.ico">
<link rel="preload" href="icons/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="icons/fa-solid-900.woff2"   as="font" type="font/woff2" crossorigin>
</head>
<body>
<script src=glue.js global extend></script>
<script src=ui.js></script>
<script src=ui_validation.js></script>
<script src=ui_nav.js></script>
<script src=ui_grid.js></script>
<script src=../www/earcut.js></script>
<script src=../www/3d.js global></script>
<script src=../www/2d.js></script>
<script src=../www/gl.js></script>
<script src=../www/gl-renderer.js></script>
<script src=../www/model3.js></script>
<script src=../www/suncalc.js></script>
<script src=../www/modeleditor.js></script>
<script>

(function () {
"use strict"
const G = window

let out = []

DEBUG('DEBUG_PLAN')

let floor_names = [
	'GROUND FLOOR',
	'1ˢᵗ FLOOR',
	'2ⁿᵈ FLOOR',
	'3ʳᵈ FLOOR',
]

function seg_is_v(p1, p2) { return near(p1[0], p2[0]) }

function seg_x1(seg) { return min(seg[0][0], seg[1][0]) }
function seg_y1(seg) { return min(seg[0][1], seg[1][1]) }
function seg_x2(seg) { return max(seg[0][0], seg[1][0]) }
function seg_y2(seg) { return max(seg[0][1], seg[1][1]) }

function set_seg_x1(seg, x) { let x1i = seg[0][0] < seg[1][0] ? 0 : 1; seg[x1i][0] = x }
function set_seg_y1(seg, y) { let y1i = seg[0][1] < seg[1][1] ? 0 : 1; seg[y1i][1] = y }
function set_seg_x2(seg, x) { let x2i = seg[0][0] < seg[1][0] ? 1 : 0; seg[x2i][0] = x }
function set_seg_y2(seg, y) { let y2i = seg[0][1] < seg[1][1] ? 1 : 0; seg[y2i][1] = y }

function seg_axis(seg) { return seg_is_v(seg[0], seg[1]) ? seg_x1(seg) : seg_y1(seg) }
function seg_m1  (seg) { return seg_is_v(seg[0], seg[1]) ? seg_y1(seg) : seg_x1(seg) }
function seg_m2  (seg) { return seg_is_v(seg[0], seg[1]) ? seg_y2(seg) : seg_x2(seg) }

function set_seg_axis(seg, a) {
	if (seg_is_v(seg[0], seg[1])) {
		seg[0][0] = a
		seg[1][0] = a
	} else {
		seg[0][1] = a
		seg[1][1] = a
	}
}

function seg_pi(seg, p) {
	assert(seg[0] == p || seg[1] == p)
	return seg[0] == p ? 0 : 1
}

function seg_i1(seg) { let mi = seg_is_v(seg[0], seg[1]) ? 1 : 0; return seg[0][mi] < seg[1][mi] ? 0 : 1 }
function seg_i2(seg) { let mi = seg_is_v(seg[0], seg[1]) ? 1 : 0; return seg[0][mi] < seg[1][mi] ? 1 : 0 }

function seg_p1(seg) { return seg[seg_i1(seg)] }
function seg_p2(seg) { return seg[seg_i2(seg)] }

function seg_center(seg) {
	return line_middle(seg[0], seg[1])
}

let NEAR = 1e-5

function near(a, b) { return abs(a - b) < NEAR }

// face plan model utils -----------------------------------------------------

// NOTE: face is 0,1,2,3 going clockwise from the bottom-side face.
let face_is_v = i => i & 1                   // 0,1,2,3 ->  0,1,0,1
let face_sign = i => (i & 2) - 1             // 0,1,2,3 -> -1,-1,1,1
let face_axis_sign = i => ((i + 3) & 2) - 1  // 0,1,2,3 -> 1,-1,-1,1

// view utils ----------------------------------------------------------------

let format_length = d => format_kcount(d / 1e2, 2)+'m'
let format_area = a => format_kcount(a / 1e4, 2)+'m²'

// house model ---------------------------------------------------------------

let defaults = {
	floor_h: 250,
	int_wall_thickness: 8,
	ext_wall_thickness: 18,
}

function poly_get_point(i, out) {
	out[0] = this[i][0]
	out[1] = this[i][1]
	return out
}

function house(house) {

	for (let k in defaults)
		if (!(k in house))
			house[k] = defaults[k]

	let next_id = {}
	function gen_id(k) {
		if (!next_id[k])
			next_id[k] = 1
		else
			next_id[k]++
		return next_id[k]
	}

	function house_bb() {
		let bb = bbox2()
		for (let floor of house.floors)
			bb.add_bbox2(...floor.bb)
		return bb
	}

	function create_floor(t, floor_i) {

		t.gen_id = gen_id
		t.house = house
		t.i = floor_i
		t.h ??= house.floor_h
		t.fixed_h = t.h
		t.bb = bbox2()

		t.orthogonal = true
		let floor = plane_graph(t)

		let ps = floor.ps
		let segs = floor.segs
		let comps = floor.comps
		let root_comps = floor.root_comps
		let add_point = floor.add_point
		let add_seg = floor.add_seg
		let set_seg_point = floor.set_seg_point
		let fix = floor.fix
		let roofs = floor.roofs
		let next_adj = floor.next_adj

		floor.snap_lines = []

		floor.after_fix = function() {
			create_edges()
			fix_roofs()
			floor.snap_lines[0] = snap_lines_for(1)
			floor.snap_lines[1] = snap_lines_for(0)
			for (let face of house.faces)
				face.fix()
		}

		function fix_areas_for(comp) {
			for (let c of comp.cycles) {
				if (c.outer)
					continue
				let a0 = c.edges.area()
				for (let icomp of c.islands) {
					fix_areas_for(icomp)
					c.edges._area -= icomp.outer_cycle.edges.area()
				}
				let a1 = c.edges.area()
				if (0 && a1 != a0)
					log('cycle', c.i, 'area fixed:', a1, '+', a0-a1, '=', a0)
			}
		}

		function create_edges() {

			for (let p of ps)
				p.max_offset = 0

			let t_int = house.int_wall_thickness
			let t_ext = house.ext_wall_thickness
			let o_int = t_int / 2
			let o_ext = t_ext - o_int

			for (let comp of comps) {
				for (let c of comp.cycles) {
					let edges = poly2()
					edges.get_point = poly_get_point
					c.edges = c.offset(c.outer ? (c.comp.inside ? -o_int : -o_ext) : -o_int, edges)
				}
			}

			for (let c of root_comps)
				fix_areas_for(c)

			// compute the level plan bbox now that we have outer skins.
			floor.bb.reset()
			for (let co of comps)
				floor.bb.add_bbox2(...co.outer_cycle.edges.bbox())

			// recompute house plan bbox.
			if (house.bb) // not in init
				house.bb = house_bb()

		}

		// roofs ---------------------------------------------------------------

		function roof_ridge_is_v(roof) { return roof.axis == 'v' }

		function gable_roof_ridge_axis(roof) {
			let M1 = roof_ridge_is_v(roof) ? 0 : 1
			let m1 = roof.bb[M1]
			let m2 = roof.bb[M1+2]
			return (m1 + m2) / 2
		}

		function gable_roof_height_at(m, roof) {
			let a = roof.pitch * rad
			let M1 = roof_ridge_is_v(roof) ? 0 : 1
			let m1 = roof.bb[M1]
			let m2 = roof.bb[M1+2]
			let mc = (m2 + m1) / 2
			return round(tan(a) * ((m2 - mc) - abs(m - mc)))
		}

		function gable_roof_height_at_point(px, py, roof) {
			let m = roof_ridge_is_v(roof) ? px : py
			return gable_roof_height_at(m, roof)
		}

		function roof_section() {

		}

		function init_roofs() {
			if (!roofs)
				return
			push_log('init roofs')

			for (let roof of roofs) {
				roof.box = bbox2(...roof.box)
				fix_roof(roof)
			}

			pop_log()
		}

		function fix_roof(roof) {
			//
		}

		function fix_roofs() {
			if (!roofs)
				return
			for (let roof of roofs)
				fix_roof(roof)
		}

		// plan view UI ops ----------------------------------------------------

		// Find and fix the the cycles that contain the sequence (p0,p1,p2) or (p2,p1,p0).
		// If (p0,p1,p2) is found then the cycle is to the left of the sequence if it's an inner cycle.
		// If (p2,p1,p0) is found then the cycle is to the right of the sequence if it's an inner cycle.
		// It's the opposite if it's an outer cycle.
		// The same cycle will contain the sequence twice (once as is once in reverse)
		// if the sequence is (part of) a filament.
		// NOTE: replacing a point in the cycle (instead of always adding one) makes the cycle
		// technically invalid (as it's skipping a point) but we do it to keep the offset edge
		// stable at that corner while dragging the segment.
		function fix_cycle(c, i, fw, action, new_p, p0, p1, p2) {
			if (action == 'replace') {
				log('cycle point replaced:', c.i, '/', i, ':', c[i].i, '->', new_p.i)
				c[i] = new_p
			} else if (action == 'insert') {
				i = fw ? i : i+1 // insert point in the cycle array
				log('cycle point inserted:', c.i, '/', i, '(before ', c[i] ? c[i].i : 'end','):', new_p.i)
				insert(c, i, new_p)
			}
		}
		function fix_cycles_containing(p0, p1, p2, action, new_p) {
			push_log('fix all cycles containing (', p0.i, p1.i, p2.i, ':', action, 'with', new_p.i)
			for (let comp of comps)
				for (let c of comp.cycles) {
					let i0 = 0
					while (1) {
						let i = c.indexOf(p1, i0)
						if (i == -1)
							break
						let fp0 = c[mod(i-1, c.length)]
						let fp2 = c[mod(i+1, c.length)]
						if (fp0 == p0 && fp2 == p2) fix_cycle(c, i, 1, action, new_p, p0, p1, p2)
						if (fp0 == p2 && fp2 == p0) fix_cycle(c, i, 0, action, new_p, p2, p1, p0)
						i0 = i+1
					}
				}
			pop_log()
		}

		// colinear segs directly end-to-end tied to the segment we want to move
		// must be separated by addidng a _|_ seg in between so they're not dragged along.
		// NOTE: do not deduplicate points after this!
		function detach_seg_at(seg, i, p00) {
			push_log('detach seg:', seg.i)
			let p  = seg[i]
			let p0 = seg[1-i]
			let new_p = add_point(p[0], p[1])

			// each side of (p0,p) needs a different kind of fixing depending on
			// whether there's a _|_ seg at the separation point on that side or not.
			if (p.adj.length > 2) {
				for (let cw = 0; cw <= 1; cw++) {
					let p1 = next_adj(p0, p, cw, 1)
					fix_cycles_containing(p0, p, p1 ?? p00, p1 ? 'replace' : 'insert', new_p)
				}
			} else { // no _|_ segs on the sides.
				fix_cycles_containing(p0, p, p00, 'insert', new_p)
			}

			set_seg_point(seg, i, new_p, 1)
			let new_seg = add_seg(p, new_p)
			pop_log()
		}
		function points_equal(p1, p2) { return p1[0] == p2[0] && p1[1] == p2[1] }
		function opposite_seg(seg, i) {
			let v = seg_is_v(seg[0], seg[1])
			let p = seg[i]
			for (let seg1 of p.segs) { // each segment connected to that end-point
				if (seg1 == seg) // itself
					continue
				if (seg_is_v(seg1[0], seg1[1]) != v) // not colinear
					continue
				if (points_equal(seg1[0], seg1[1])) // just added
					continue
				return seg1
			}
		}
		function detach_opposite_seg(seg, i) {
			let seg1 = opposite_seg(seg, i)
			if (!seg1) return
			let p = seg[i]
			if (seg1[0] == p) detach_seg_at(seg1, 0, seg[1-i])
			else
			if (seg1[1] == p) detach_seg_at(seg1, 1, seg[1-i])
		}
		function detach_colinear_segs(seg) {
			detach_opposite_seg(seg, 0)
			detach_opposite_seg(seg, 1)
		}

		function segs_overlap(am1, am2, bm1, bm2) { // check if two segments overlap
			return !(am2 <= bm1 || bm2 <= am1)
		}

		function snap_lines_for(v, exclude_seg) {
			let mi = v ? 0 : 1
			let ms = []
			for (let floor of house.floors) {
				for (let p of floor.ps) {
					if (exclude_seg && (exclude_seg[0] == p || exclude_seg[1] == p))
						continue
					let m = p[mi]
					ms.push(m)
				}
			}
			ms.sort()
			uniq_sorted(ms)

			ms.snap = function(m, snap_d) {
				let min_d = 1/0
				let min_m
				for (let m1 of ms) {
					let d = abs(m - m1)
					if (d <= snap_d && d < min_d) {
						min_d = d
						min_m = m1
					}
				}
				return min_m // ?? snap(m, 10)
			}

			ms.v = v

			return ms
		}

		function snap_x(x, nosnap) {
			let snap_d = nosnap ? 2 : 20
			return floor.snap_lines[0].snap(x, snap_d)
		}
		function snap_y(y, nosnap) {
			let snap_d = nosnap ? 2 : 20
			return floor.snap_lines[1].snap(y, snap_d)
		}
		floor.snap_x = snap_x
		floor.snap_y = snap_y

		function seg_move_bump_limit(seg, sign) {
			let v = seg_is_v(seg[0], seg[1])
			let a = seg_axis(seg)
			let min_a1 = sign * 1/0
			let s_m1 = seg_m1(seg)
			let s_m2 = seg_m2(seg)
			for (let seg1 of segs) {
				let s1_m1 = seg_m1(seg1)
				let s1_m2 = seg_m2(seg1)
				let a1 = seg_axis(seg1)
				if (seg_is_v(seg1[0], seg1[1]) != v) {
					let closest_m = sign < 0 ? max(s1_m1, s1_m2) : min(s1_m1, s1_m2)
					s1_m1 = a1
					s1_m2 = a1
					a1 = closest_m
				}
				if (sign * a1 > sign * a && sign * a1 < sign * min_a1) {
					if (segs_overlap(s_m1, s_m2, s1_m1, s1_m2)) {
						min_a1 = a1
					}
				}
			}
			return min_a1
		}
		function seg_move_ranges(seg) {
			let min_a = seg_move_bump_limit(seg, -1)
			let max_a = seg_move_bump_limit(seg,  1)
			let ranges = [
				[min_a, max_a],
			]
			return ranges
		}
		function seg_resize_bump_limit(seg, p, sign) {
			let v = seg_is_v(seg[0], seg[1])
			let a = p[v ? 1 : 0]
			let m = p[v ? 0 : 1]
			let min_a1 = sign * 1/0
			for (let seg1 of segs) {
				if (seg_is_v(seg1[0], seg1[1]) != v) {
					let a1 = seg_axis(seg1)
					if (sign * a1 > sign * a && sign * a1 < sign * min_a1) {
						let m1 = seg_m1(seg1)
						let m2 = seg_m2(seg1)
						if (m >= m1 && m <= m2)
							min_a1 = a1
					}
				}
			}
			return min_a1
		}
		function seg_resize_ranges(seg, p) {
			let min_a = seg_resize_bump_limit(seg, p, -1)
			let max_a = seg_resize_bump_limit(seg, p,  1)
			let ranges = [
				[min_a, max_a],
			]
			return ranges
		}
		function closest_range(a, ranges) {
			let min_range
			let min_d = 1/0
			for (let range of ranges) {
				let [a1, a2] = range
				if (a >= a1 && a <= a2) { // in range
					min_range = range
					break
				}
				let d = max(0, min(abs(a1 - a), abs(a2 - a))) // distance to range's closest end-point
				if (d < min_d) {
					min_range = range
					min_d = d
				}
			}
			return min_range
		}
		function snap_seg(a, ranges, snap_lines, draw_state, snap_d) {
			let snap_range = closest_range(a, ranges)
			let [min_a, max_a] = snap_range
			a = clamp(a, min_a, max_a)
			let sa = snap_lines.snap(a, ui.key('shift') ? 2 : snap_d)
			draw_state.snap_lines.length = 0
			if (sa != null)
				draw_state.snap_lines.push(sa, snap_lines.v)
			return sa
		}

		// find the seg in the left, right, top, bottom side around p.
		function seg_around_point(p, sdx, sdy) {
			let p0 = [p[0] + sdx, p[1] + sdy]
			let p1 = next_adj(p0, p, 1, 0)
			// find the seg of (p, p1)
			for (let seg of p.segs)
				if (seg[0] == p && seg[1] == p1 || seg[1] == p && seg[0] == p1)
					return seg
		}

		function start_move_seg(seg, draw_state) {

			push_log('START MOVE SEG:', seg.i)

			detach_colinear_segs(seg)

			pop_log()

			let move_freely = seg[0].segs.length == 1 && seg[1].segs.length == 1
			let seg0 = [[...seg[0]], [...seg[1]]]
			let ranges = seg_move_ranges(seg)
			let snap_lines = snap_lines_for(seg_is_v(seg[0], seg[1]), move_freely && seg)
			let v = seg_is_v(seg0[0], seg0[1])
			let m_snap_lines = move_freely && snap_lines_for(!seg_is_v(seg[0], seg[1]), seg)

			// find all affected _|_ edges so we can show their lengths as we move the seg
			{
			let perp_edges = []
			// find the farthest edge point from `c.edges[i0]` going in `dir` direction
			// in the array, which has the same spatial direction `v` with the previous point.
			function last_perp_edge_point(c, i, n, dir, v) {
				let ep0 = c.edges[mod(i, n)]
				while (1) {
					let ep1 = c.edges[mod(i, n)]
					let ep2 = c.edges[mod(i+dir, n)]
					if (ep2.p == ep0.p) // end-cap, don't measure
						return
					if (seg_is_v(ep1, ep2) != v) // changed direction, return last edge point
						return ep1
					i += dir
				}
			}
			let sp1 = seg[0]
			let sp2 = seg[1]
			let v = seg_is_v(seg[0], seg[1])
			for (let co of comps) {
				for (let c of co.cycles) {
					for (let i = 0, n = c.edges.length; i <= n; i++) {
						let ep1 = c.edges[mod(i+0, n)]
						let ep2 = c.edges[mod(i+1, n)]
						if (!(ep1.p == sp1 && ep2.p == sp2 || ep1.p == sp2 && ep2.p == sp1)) // not seg's edge
							continue
						let ep0 = last_perp_edge_point(c, i+0, n, -1, !v)
						let ep3 = last_perp_edge_point(c, i+1, n,  1, !v)
						if (!(ep0 || ep3))
							continue
						if (0) {
							// remove measurement of parallel wall of the same length
							let A = v ? 0 : 1 // index of cross axis of perp segs
							let dupe = ep0 && ep3 && ep0.p[A] == ep3.p[A]
							if (dupe)
								ep3 = null
						}
						if (ep0) perp_edges.push([ep0, ep1])
						if (ep3) perp_edges.push([ep2, ep3])
					}
				}
			}
			draw_state.measure_edges = perp_edges
			}

			let s = {}

			s.move = function(dx, dy, draw_state) {

				let dm = v ? dy : dx
				let da = v ? dx : dy

				if (move_freely) {

					let a = seg_axis(seg0) + da
					let sa = snap_lines.snap(a) ?? a
					a = sa ?? a

					// snap both end-points on main-axis.
					let m1 = seg_m1(seg0) + dm
					let m2 = seg_m2(seg0) + dm
					let m1s = m_snap_lines.snap(m1)
					let m2s = m_snap_lines.snap(m2)
					if (m1s != null && m2s != null) // both ends snapped
						if (abs(m1s - m1) <= abs(m2s - m2)) // pick the one closer to snap line
							m2s = null
						else
							m1s = null
					if (m1s != null)
						m2s = m1s + (seg_m2(seg0) - seg_m1(seg0))
					else if (m2s != null)
						m1s = m2s - (seg_m2(seg0) - seg_m1(seg0))

					seg[0][0] =  v ? a : m1s ?? m1
					seg[1][0] =  v ? a : m2s ?? m2
					seg[0][1] = !v ? a : m1s ?? m1
					seg[1][1] = !v ? a : m2s ?? m2

				} else { // move on cross axis

					let a = seg_axis(seg0) + (v ? dx : dy)
					let sa = snap_seg(a, ranges, snap_lines, draw_state, 20)
					a = sa ?? a
					set_seg_axis(seg, a)
					create_edges()

				}

			}

			s.stop = function(draw_state, remove_seg) {
				push_log('STOP MOVE SEG:', seg.i)
				if (remove_seg)
					rem_seg(seg)
				fix()
				pop_log()
				draw_state.snap_lines.length = 0
				draw_state.measure_edges.length = 0
			}

			return s
		}
		floor.start_move_seg = start_move_seg

		function start_resize_seg(p, mx0, my0, dx, dy, sdx, sdy, draw_state) {

			// based on direction of drag, either detach a seg or add a seg, and start resizing it.
			push_log('START RESIZE SEG')

			let seg
			if (p) {
				// find seg in the drag direction around p.
				if (p.segs.length == 1 && seg_is_v(p.segs[0][0], p.segs[0][1]) == !!sdy) {
					// p is a free end-point and we're dragging along its main axis: resize it.
					seg = p.segs[0]
				} else {
					// find the seg around p in the direction of drag: that's the segment we want to detach and resize.
					seg = seg_around_point(p, sdx, sdy)
					if (seg) {
						// detach seg at branch point p so we can then resize it by its free end-point.
						let x = p[0] + dx * abs(sdx)
						let y = p[1] + dy * abs(sdy)
						let new_p = add_point(x, y)
						set_seg_point(seg, seg_pi(seg, p), new_p)
						p = new_p
					}
				}
			}

			if (!seg) { // create new seg, anchored to "hovered point" or to "mouse pos when clicked"
				let x1, y1
				if (p) {
					[x1, y1] = p
				} else {
					x1 = mx0
					y1 = my0
				}
				let x2 = x1 + dx * abs(sdx)
				let y2 = y1 + dy * abs(sdy)
				let p1 = add_point(x1, y1)
				let p2 = add_point(x2, y2)
				seg = add_seg(p1, p2)
				p = p2
			}

			log('resizing seg:', seg.i)

			let p0 = [...p]

			fix()

			pop_log()

			let ranges = seg_resize_ranges(seg, p)
			let snap_lines = snap_lines_for(!seg_is_v(seg[0], seg[1]), seg)

			let s = {seg: seg}

			s.resize = function(dx, dy, draw_state, hs) {
				let x1 = p0[0] + dx * abs(sdx)
				let y1 = p0[1] + dy * abs(sdy)

				let a = sdx ? x1 : y1
				let sa = snap_seg(a, ranges, snap_lines, draw_state, 30)
				if (sa != null)
					a = sa
				if (sdx)
					x1 = a
				else
					y1 = a
				p[0] = x1
				p[1] = y1
				hs.set('x', x1)
				hs.set('y', y1)
				create_edges()
			}

			s.stop = function(draw_state) {
				push_log('STOP RESIZE SEG:', seg.i)
				fix()
				pop_log()
				draw_state.snap_lines.length = 0
				draw_state.measure_edges.length = 0
			}

			return s
		}
		floor.start_resize_seg = start_resize_seg

		// init ----------------------------------------------------------------

		push_log('LOADING LEVEL', floor.i)
		floor.init()
		init_roofs()
		pop_log()

		return floor
	}

	// face -------------------------------------------------------------------

	// returns x1, y1, x2, y2, min_depth, max_depth
	function face_bb(vert) {
		let [x1, y1, x2, y2] = house.bb
		let h = house.h
		if (vert)
			return [y1, 0, y2, h, x1, x2]
		else
			return [x1, 0, x2, h, y1, y2]
	}

	function p_x(p) { return p[0] }
	function p_y(p) { return p[1] }

	function create_face(face_i) {

		let fv = face_is_v(face_i)
		let fs = face_sign(face_i)
		let fas = face_axis_sign(face_i)

		let bb = bbox2()

		let ep_m    = fv ? p_y : p_x
		let ep_axis = fv ? p_x : p_y

		function ep_h(ep) {
			return ep.p.h ?? 0
		}

		function edge_sign(ep1, ep2) {
			return ep_m(ep1) < ep_m(ep2) ? 1 : -1
		}

		let walls = [] // exterior wall horizontal measurements
		let planes = []

		let face = {house: house, i: face_i, bb: bb, planes: planes}

		function create_face_planes() {

			face.bb = face_bb(fv) // TODO: reuse bb

			walls.length = 0
			planes.length = 0

			// find outer edges that are projecting in the face's direction.
			for (let floor of house.floors) {
				for (let comp of floor.comps) {
					if (comp.inside)
						continue
					let eps = comp.outer_cycle.edges
					for (let i = 0, n = eps.length; i < n; i++) {
						let ep1 = eps[mod(i  , n)]
						let ep2 = eps[mod(i+1, n)]
						if (seg_is_v(ep1, ep2) != fv) // _|_ edge: invisible
							continue
						if (edge_sign(ep1, ep2) != fs) // back-face edge: obscured: cull it
							continue
						let last_wall = walls[walls.length-1]
						let last_ep2 = last_wall && last_wall[1]
						if (last_ep2 == ep1) // in-wall point: skip (i.e. merge segs)
							last_wall[1] = ep2
						else
							walls.push([ep1, ep2, floor, comp])
					}
					// merge first and last segs if necessary.
					let first_wall = walls[0]
					let last_wall  = walls[walls.length-1]
					if (last_wall[1] == first_wall[0]) {
						first_wall[0] = last_wall[0]
						walls.pop()
					}
				}
			}

			// pr(face, walls.map(w => w[2].i+':'+w[0].p.i+'-'+w[1].p.i).join(' '))

			// sort walls by depth.
			walls.sort(function(w1, w2) {
				// 1st level grouping: by depth (asc order).
				let y1 = ep_axis(w1[0])
				let y2 = ep_axis(w2[0])
				let dy = fas * (y1 - y2)
				if (dy) return dy
				// 2nd level grouping: by floor (desc order).
				let l1 = w1[2].i
				let l2 = w2[2].i
				return l2 - l1
			})

			let eq_depth = (w1, w2) => ep_axis(w1[0]) == ep_axis(w2[0])
			let eq_floor = (w1, w2) => w1[2] == w2[2]

			// create face polygons by merging the faces that are on the same vertical plane.
			for (let [j1, j2] of group_sorted(walls, eq_depth)) {

				// 1st level grouping: j1,j2 is all walls of a single depth plane.
				push_log('FACE PLANE', 'face=', face_i, 'plane=', planes.length, 'depth=', ep_axis(walls[j1][0]), 'i=', j1, '..', j2)

				let segs = []

				function add_seg(x1, y1, x2, y2, ep1, ep2, ...log_args) {
					let p1 = [x1, y1]
					let p2 = [x2, y2]
					let seg = [p1, p2]
					segs.push(seg)
					// set back refs to origin eps for quick updating
					p1.ep1 = ep1
					p2.ep2 = ep2
					log(...log_args, ':', x1, y1, '-', x2, y2)
				}

				let last_i1, last_i2, last_floor_i
				for (let [i1, i2] of group_sorted(walls, eq_floor, j1, j2)) {

					// 2nd level grouping: i1,i2 is all walls of a single floor of this depth plane.

					let floor = walls[i1][2]
					let h = floor.h
					let y = floor.y
					let y1 = y
					let y2 = y + h

					for (let i = i1; i < i2; i++) {

						// make vertical segments (these are just constructed, no merging).
						let [ep1, ep2] = walls[i]
						let x1 = ep_m(ep1)
						let x2 = ep_m(ep2)
						let y11 = y1 - ep_h(ep1)
						let y12 = y1 - ep_h(ep2)
						// pr(face_i, floor.i, x1, x2, ep_h(ep1), ep_h(ep2))
						add_seg(x1, y11, x1, y2, ep1, ep2, 'vertical of floor', floor.i)
						add_seg(x2, y12, x2, y2, ep1, ep2, 'vertical of floor', floor.i)

						// for top and bottom floors whichever they are in this particular
						// depth plane (might not be all floors), make top and bottom segments.
						if (last_floor_i != floor.i+1) // top line
							add_seg(x1, y11, x2, y12, ep1, ep2, 'top of floor', floor.i)
						if (i2 == j2 || last_floor_i != null && last_floor_i != floor.i+1) // bottom line
							add_seg(x1, y2, x2, y2, ep1, ep2, 'bottom of floor', floor.i)
					}

					// merge segments between this floor and the last floor.
					// adding all end-points from the segments of both floors
					// and sorting them gives us exactly the segments we want,
					// no analyzing intersections necessary.
					if (last_floor_i == floor.i+1) {

						let a = []

						for (let i = i1; i < i2; i++)
							a.push(walls[i][0], walls[i][1])
						for (let i = last_i1; i < last_i2; i++)
							a.push(walls[i][0], walls[i][1])

						a.sort((ep1, ep2) => ep_m(ep1) - ep_m(ep2))

						for (let i = 0, n = a.length; i < n; i += 2) {
							let ep1 = a[i]
							let ep2 = a[i+1]
							let x1 = ep_m(ep1)
							let x2 = ep_m(ep2)
							if (x1 != x2)
								add_seg(x1, y1, x2, y1, ep1, ep2, 'between floors', last_floor_i, 'and', floor.i)
						}

					}

					last_i1 = i1
					last_i2 = i2
					last_floor_i = floor.i
				}

				let plan = plane_graph({lines: [segs], gen_id: gen_id})
				plan.depth = ep_axis(walls[j1][0])
				plan.init()
				plan.fix()
				planes.push(plan)

				pop_log()

			}

		}

		function wall_face_rect(plan, lv, wr, i, scale) {
			let h = pix(lv.h, scale)
			let v  = wall_vert(wr, i)
			let p1 = wall_p1(wr, i+0, true, null, scale)
			let p2 = wall_p1(wr, i+1, true, null, scale)
			let X = v ? 1 : 0
			let Y = v ? 0 : 1
			let x1 = p1[X]
			let x2 = p2[X]
			let x = min(x1, x2)
			let w = max(x1, x2) - x
			let y = 0
			return [x, y, w, h, p1[Y]] // (x, y, w, h, z)
		}

		face.fix = create_face_planes

		return face
	}

	// init -------------------------------------------------------------------

	function init() {
		let t0 = clock()
		push_log('LOADING PLAN')

		let floors = house.floors
		house.floors = []
		house.faces = []

		for (let n = floors.length, i = n-1; i >= 0; i--) {
			let floor = create_floor(floors[i], i)
			house.floors[i] = floor
		}

		for (let floor of house.floors)
			floor.fix()

		let y = 0
		for (let n = house.floors.length, i = n-1; i >= 0; i--) {
			let floor = house.floors[i]
			floor.y = y
			y += floor.h
		}
		house.h = y

		for (let i = 0; i <= 3; i++)
			house.faces.push(create_face(i))

		house.bb = house_bb()

		for (let face of house.faces)
			face.fix()

		let dt = round((clock() - t0) * 1000)
		pr('TIME', ('*').repeat(dt), dt, 'ms')

		pop_log()
	}
	init()

	return house

}

// shared scale --------------------------------------------------------------

function scaler(name) {
	let s = {}
	let line_width = 2 // thickness of wall line stroke in pixels at 1:1 scale
	let scale, margin
	s.d = d => round(d * scale)
	s.x = x => round(x * scale)
	s.y = y => round(y * scale)
	s.plan_x = x => x / scale
	s.plan_y = y => y / scale
	s.plan_d = d => d / scale
	s.transform = function(cx, w, h) {
		if (s.rotation) {
			let xc = round(w / 2)
			let yc = round(h / 2)
			cx.translate(xc, yc)
			cx.rotate(s.rotation)
			cx.translate(-xc, -yc)
		}
		cx.translate(s.x0, s.y0)
	}
	function set_scale(sc) {
		scale = sc
		s.scale = sc
		// snap line width to an even number for sharpness
		s.line_width = snap(line_width * sc, 2)
	}
	let bb = bbox2()
	s.scale_to_fit = function(bb1, w, h) {
		if (s.zoomed) return
		let margin = ceil(ui.em(2) + line_width)
		w -= 2 * margin
		h -= 2 * margin
		array_set(bb, bb1)
		bb.rotate(s.rotation)
		let [x1, y1, x2, y2] = bb
		let bw = x2 - x1
		let bh = y2 - y1
		set_scale(min(
			scale,
			w / bw,
			h / bh
		))
		if (!s.panned) {
			// in pixels from widget's origin
			s.x0 = -s.x(x1) + margin + round((w - s.d(x2 - x1)) / 2)
			s.y0 = -s.y(y1) + margin + round((h - s.d(y2 - y1)) / 2)
		}
	}
	s.set_scale = function(sc) {
		if (s.zoomed) return
		set_scale(sc)
	}
	s.zoom = function(d, xc, yc) { // zoom around (xc,yc) pixels from widget's origin
		if (!d) return
		d /= 150
		d *= 1.2

		let plan_xt = s.plan_x(-s.x0 + xc)
		let plan_yt = s.plan_y(-s.y0 + yc)

		set_scale(clamp(abs(scale * (d < 0 ? 1 / d : d)), 0.1, 10))

		// TODO: rotate

		let xt = s.x(plan_xt)
		let yt = s.y(plan_yt)

		s.x0 = -(xt - xc)
		s.y0 = -(yt - yc)

		s.zoomed = true
	}
	s.reset_zoom = function() {
		s.zoomed = false
		s.panned = false
	}
	return s
}

let scale_group = memoize(scaler)

// floor view ----------------------------------------------------------------

function draw_grid(cx, sg, x0, y0, w, h, step, dark_color, light_color) {
	if (!sg.show_grid)
		return
	if (sg.d(step) < 7)
		return
	let color = ui.dark() ? dark_color : light_color
	cx.strokeStyle = color
	for (let i = mod(sg.plan_x(x0), step), n = sg.plan_d(w); i < n; i += step) {
		cx.beginPath()
		cx.moveTo(sg.x(i), 0)
		cx.lineTo(sg.y(i), h-1)
		cx.stroke()
	}
	for (let i = mod(sg.plan_y(y0), step), n = sg.plan_d(h); i < n; i += step) {
		cx.beginPath()
		cx.moveTo(0, sg.x(i))
		cx.lineTo(w-1, sg.y(i))
		cx.stroke()
	}
	return true
}

function draw_grids(cx, sg, x0, y0, w, h) {
	// fixed grid
	cx.save()
	cx.translate(.5, .5)
	// TODO: make this dynamic; show at most 3-levels based on zoom level
	// with dynamic lightness based on level.
	if (0) {
	for (let i = 0; i < 3; i++) {
		let step = (i == 0 ? 1 : i == 1 ? 5 : 10)
		let L = ui.dark() ? 1 : 0
		draw_grid(cx, sg, x0, y0, w, h,  10, hsl(0, 0, L))
	}
	}
	let g1 =
	draw_grid(cx, sg, x0, y0, w, h,  10, '#222'   , '#eee')
	draw_grid(cx, sg, x0, y0, w, h,  50, g1 ? '#2a2a2a' : '#222', '#ddd')
	draw_grid(cx, sg, x0, y0, w, h, 100, '#333'   , '#ccc')
	cx.restore()
}

function draw_edges(cx, sg, eps) {
	for (let ep of eps) {
		let x = sg.x(ep[0])
		let y = sg.y(ep[1])
		if (ep == eps[0])
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()
}

function draw_walls(cx, sg, comps, segs) {
	for (let comp of comps) {

		cx.beginPath()

		for (let c of comp.cycles) {
			if (!c.edges)
				continue
			draw_edges(cx, sg, c.edges)
		}

		if (!cx.wall_pattern) {
			let w = 100
			let c = new OffscreenCanvas(w, w)
			let x = c.getContext('2d')
			let g = x.createLinearGradient(0, 0, w, 2*w)
			for (let i = 0, n = 2*w; i <= n; i += 4) {
				g.addColorStop(clamp((i - 1) / n, 0, 1), 'white')
				g.addColorStop(clamp((i + 0) / n, 0, 1), 'gray')
				g.addColorStop(clamp((i + 1) / n, 0, 1), 'white')
			}
			x.rect(0, 0, w, w)
			x.fillStyle = g
			x.fill()
			cx.wall_pattern = cx.createPattern(c, 'repeat')
		}
		if (sg.scale > 0.4) {
			cx.fillStyle = DEBUG_PLAN ? '#333' : cx.wall_pattern
			cx.fill('nonzero')
			cx.lineWidth = DEBUG_PLAN ? 2 : sg.line_width
			cx.strokeStyle = 'black' //ui.fg_color('text')
			cx.lineJoin = 'round'
			cx.stroke()
			cx.lineJoin = 'miter'
			cx.lineWidth = 1
		} else if (sg.scale > 0.2) { // too small to stroke
			cx.fillStyle = ui.fg_color('text')
			cx.fill()
		} else { // to small to even show edges
			for (let seg of segs) {
				let x1 = sg.x(seg[0][0]) + .5
				let y1 = sg.y(seg[0][1]) + .5
				let x2 = sg.x(seg[1][0]) + .5
				let y2 = sg.y(seg[1][1]) + .5
				cx.beginPath()
				cx.moveTo(x1, y1)
				cx.lineTo(x2, y2)
				cx.strokeStyle = ui.fg_color('text')
				cx.stroke()
			}
		}
	}
}

function draw_length(cx, sg, x1, y1, x2, y2) {

	let d = distance(x1, y1, x2, y2)
	if (sg.d(d) < 20)
		return

	let s = format_length(d)

	x1 = sg.x(x1)
	y1 = sg.y(y1)
	x2 = sg.x(x2)
	y2 = sg.y(y2)

	if (x1 > x2) {
		let x3 = x1
		let y3 = y1
		x1 = x2
		y1 = y2
		x2 = x3
		y2 = y3
	}
	let a = atan2(y2 - y1, x2 - x1)

	cx.save()

	cx.font = 'bold 14px sans-serif'
	let m = ui.measure_text(cx, '0.00m')
	let w = m.width

	let t1 = clamp((sg.d(d) - (w + 10)) / 2 / sg.d(d), 0, 1)
	let t2 = clamp((sg.d(d) + (w + 10)) / 2 / sg.d(d), 0, 1)

	if (!(t1 > 0 && t2 < 1)) {
		s = '...'
		w = 10
	}

	cx.translate(.5, .5)

	cx.beginPath()

	// left arrow
	let [x1a1, y1a1] = point_around(x1, y1, 8, a + 45*rad)
	let [x1a2, y1a2] = point_around(x1, y1, 8, a - 45*rad)
	let [x1e, y1e] = line2.at(t1, x1, y1, x2, y2, out)

	cx.moveTo(x1  , y1)
	cx.lineTo(x1a1, y1a1)
	cx.moveTo(x1  , y1)
	cx.lineTo(x1a2, y1a2)
	cx.moveTo(x1  , y1)
	cx.lineTo(x1e , y1e)

	// right arrow
	let [x2a1, y2a1] = point_around(x2, y2, 8, a + (90+45)*rad)
	let [x2a2, y2a2] = point_around(x2, y2, 8, a - (90+45)*rad)
	let [x2e, y2e] = line2.at(t2, x1, y1, x2, y2, out)
	cx.moveTo(x2  , y2)
	cx.lineTo(x2a1, y2a1)
	cx.moveTo(x2  , y2)
	cx.lineTo(x2a2, y2a2)
	cx.moveTo(x2  , y2)
	cx.lineTo(x2e , y2e)

	cx.strokeStyle = ui.fg_color('text')
	cx.stroke()

	let [xc, yc] = line2.at(.5, x1, y1, x2, y2, out)
	cx.translate(xc, yc)
	cx.rotate(a)
	let tx = round(-w / 2)
	let ty = round((m.fontBoundingBoxAscent - m.fontBoundingBoxDescent) / 2)
	cx.translate(tx, ty)
	cx.fillStyle = ui.fg_color('text')
	cx.fillText(s, 0, 0)

	cx.restore()
}

let FLOOR_VIEW_ID         = ui.S-1
let FLOOR_VIEW_DRAW_STATE = ui.S+0

ui.box_widget('floor_view', {

	create: function(cmd, id, plan, fr, align, valign, min_w, min_h) {

		let s = ui.state(id)
		let draw_state = s.get('draw_state')
		if (!draw_state) {
			draw_state = {snap_lines: [], measure_edges: [], above_floors: [], below_floors: []}
			s.set('draw_state', draw_state)
		}
		s.set('plan', plan)

		let [dstate, dx, dy] = ui.drag(id)

		let sg = scale_group('editor')

		dx /= sg.scale
		dy /= sg.scale

		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {

			let hs = ui.hover(id)
			let cs = ui.captured(id)

			if (dstate == 'drag') {

				let action = hs.get('action')
				let seg    = hs.get('seg')
				let p      = hs.get('p')

				if (action == 'move_seg') { // move seg
					cs.set('move_seg', plan.start_move_seg(seg, draw_state))
				} else if (action == 'pan') {
					sg.pan_x0 = sg.x0
					sg.pan_y0 = sg.y0
					cs.set('action', action)
				}
			}

			let action = cs.get('action')

			if (!action && (abs(dx) >= 10 || abs(dy) >= 10)) { // dragged far enough to assume intent to drag.

				// establish direction of drag on x and y axis.
				let sdx = abs(dx) > 1.5 * abs(dy) ? sign(dx) : 0 // straight enough
				let sdy = abs(dy) > 1.5 * abs(dx) ? sign(dy) : 0 // straight enough
				if (sdx || sdy) {
					action = 'resize_seg'
					cs.set('action', action)
					let p   = cs.get('p')
					let mx0 = cs.get('x')
					let my0 = cs.get('y')
					let s = plan.start_resize_seg(p, mx0, my0, dx, dy, sdx, sdy, draw_state)
					cs.set('resize_seg', s)
				}

			}

			if (action == 'move_seg')
				cs.get('move_seg').move(dx, dy, draw_state)

			if (action == 'resize_seg')
				cs.get('resize_seg').resize(dx, dy, draw_state, hs)

			if (action == 'pan') {
				sg.x0 = sg.pan_x0 + sg.d(dx)
				sg.y0 = sg.pan_y0 + sg.d(dy)
				sg.panned = true
			}

			if (dstate == 'drop') {
				if (action == 'move_seg') {
					cs.get('move_seg').stop(draw_state, ui.dblclick)
				} else if (action == 'resize_seg') {
					cs.get('resize_seg').stop(draw_state)
				}
			}

		}

		ui.stack()

			ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
					id, draw_state,
				)

			ui.m(ui.sp())
			ui.v(1, ui.sp())

				ui.h(0, ui.sp05(), 's', 't')

					ui.bold()
					ui.text('', floor_names[plan.i] ?? S(plan.i+'_floor', '{0}ᵗʰ FLOOR', plan.i))

					if (!ui.window_focused) {
						ui.p(ui.sp05(), 0)
						ui.stack('', 0, '[')
							ui.font('far')
							ui.nobold()
							ui.xlarge()
							ui.color('text')
							ui.text('', '\uf11c', 0, 'c', 'c')
							ui.polyline('', '0 5  35 20', 1, null, null, 'text', null, 2)
						ui.end_stack()
					}

					ui.v(1); ui.end()

					if (sg.zoomed) {
						if (ui.icon_button(id+'.zoom_button', 'fas', sg.scale > 1 ? '\uf00e' : '\uf010', 0, ']')) {
							sg.reset_zoom()
							ui.redraw()
						}
					}

					if (ui.icon_button(id+'.rotate_button', 'fas', '\uf2f1', 0)) {
						sg.rotation = ((sg.rotation ?? 0) + 90*rad) % (360*rad)
						ui.animate()
					}

					if (ui.icon_button(id+'.grid_button', 'fas', '\uf00a', 0)) {
						sg.show_grid = !sg.show_grid
						ui.animate()
					}

				ui.end_h()

				ui.button_stack('', 0, ']')
				ui.button_bb()

					ui.v(0, ui.sp())

						{
						let state = ui.button_state(id+'.c1')
						ui.button_icon('fas', '\uf245', state)
						}

						{
						let state = ui.button_state(id+'.c2')
						ui.button_icon('fas', '\uf0b2', state)
						}

					ui.end_v()

				ui.end_button_stack()

			ui.end_v()

		ui.end_stack()

	},

	after_position: function(a, i, axis)	{
		let sg = scale_group('editor')
		if (!axis) {
			sg.set_scale(1/0)
			return
		}
		let w  = a[i+2]
		let h  = a[i+3]
		let id = a[i+FLOOR_VIEW_ID]
		let plan = ui.state(id).get('plan')
		sg.scale_to_fit(plan.house.bb, w, h)
	},

	after_translate: function(a, i) {
		let x00 = a[i+0]
		let y00 = a[i+1]
		let id = a[i+FLOOR_VIEW_ID]
		let draw_state = a[i+FLOOR_VIEW_DRAW_STATE]

		let sg = scale_group('editor')
		let plan = ui.state(id).get('plan')

		draw_state.x0 = sg.x0
		draw_state.y0 = sg.y0
		draw_state.scale = sg.scale
		draw_state.rotation = sg.rotation

		// pick what parts of the plan to send over the network for drawing
		// and in which format. note that the plan has arrays with props but
		// the props will not be sent over because of how json works.
		draw_state.comps = plan.comps
		draw_state.segs = plan.segs // TODO: remove this from draw stream
		draw_state.ps = plan.ps // TODO: remove this from draw stream
		draw_state.plan_snap_lines = plan.snap_lines

		draw_state.above_floors.length = 0
		draw_state.below_floors.length = 0
		for (let plan1 of plan.house.floors) {
			if (plan1 == plan)
				continue
			let t = {comps: plan1.comps, segs: plan1.segs}
			let a = plan1.i > plan.i ? draw_state.above_floors : draw_state.below_floors
			a.push(t)
		}
	},

	draw: function(a, i) {

		let x00   = a[i+0]
		let y00   = a[i+1]
		let w     = a[i+2]
		let h     = a[i+3]
		let id    = a[i+FLOOR_VIEW_ID]
		let draw_state = a[i+FLOOR_VIEW_DRAW_STATE]
		let x0 = draw_state.x0
		let y0 = draw_state.y0

		x00 += ui.focused(id) ? 100 : 0

		let hs = ui.hit(id)
		let cs = ui.captured(id)
		let hit_action  = hs?.get('action')
		let hit_seg     = hs?.get('seg')
		let hit_p       = hs?.get('p')
		let hit_cycle   = hs?.get('cycle')
		let hit_x       = hs?.get('x')
		let hit_y       = hs?.get('y')
		let drag_action = cs?.get('action')
		let drag_seg    = cs?.get('seg')

		let sg = scale_group('editor')
		sg.set_scale(draw_state.scale)
		sg.rotation = draw_state.rotation

		let cx = ui.cx
		cx.save()

		cx.beginPath()
		cx.rect(x00, y00, w, h)
		cx.clip()

		cx.translate(x00, y00)
		cx.font = 'bold 14px sans-serif'

		// fixed grid
		draw_grids(cx, sg, x0, y0, w, h)

		// legend
		{
		let m = ui.em()
		let cm = 100
		let d = sg.d(cm)
		while (d > w - 2*m) {
			cm /= 5
			d = sg.d(cm)
		}
		cx.beginPath()
		let t = 4
		let x = w - d - m - t
		let y = h - m - t
		cx.rect(x, y, d, t)
		cx.fillStyle = ui.fg_color('label')
		cx.fill()
		let s = format_length(cm)
		let tw = ui.measure_text(cx, s).width
		cx.fillText(s, x + d - tw, y - 2)
		}

		// help
		{
		let m = ui.em()
		cx.fillStyle = ui.fg_color('label')
		let s = 'CTRL=No Snap  SHIFT=Pan'
		cx.fillText(s, m, h - m)
		}

		sg.transform(cx, w, h)

		// below floors
		cx.globalAlpha = .1
		for (let plan1 of draw_state.below_floors)
			draw_walls(cx, sg, plan1.comps, plan1.segs)
		cx.globalAlpha = 1

		// snap lines
		cx.setLineDash([5, 8])
		cx.strokeStyle = ui.dark() ? '#555' : '#999'
		for (let i = 0, sl = draw_state.snap_lines, n = sl.length; i < n; i += 2) {
			let sa   = sl[i]
			let is_v = sl[i+1]
			let x1, y1, x2, y2
			if (is_v) {
				x1 = sg.x(sa)
				x2 = sg.x(sa)
				y1 = -draw_state.y0
				y2 = -draw_state.y0 + h
			} else {
				y1 = sg.y(sa)
				y2 = sg.y(sa)
				x1 = -draw_state.x0
				x2 = -draw_state.x0 + w
			}
			cx.beginPath()
			cx.moveTo(x1+.5, y1+.5)
			cx.lineTo(x2+.5, y2+.5)
			cx.stroke()
		}
		cx.setLineDash([])

		// room backgrounds
		for (let co of draw_state.comps) {
			for (let c of co.cycles) {
				if (c.outer)
					continue
				if (!c.edges)
					continue

				cx.beginPath()

				draw_edges(cx, sg, c.edges)

				// island outer cycles are clockwise so they draw as holes.
				for (let icomp of c.islands)
					draw_edges(cx, sg, icomp.outer_cycle.edges)

				cx.fillStyle = ui.alpha_adjust(ui.bg_color_hsl('bg1', hit_cycle == c ? 'hover' : null), .5)
				cx.fill()
			}
		}

		// walls of this floor
		draw_walls(cx, sg, draw_state.comps, draw_state.segs)

		// walls of above floor
		cx.globalAlpha = .1
		for (let plan1 of draw_state.above_floors)
			draw_walls(cx, sg, plan1.comps, plan1.segs)
		cx.globalAlpha = 1

		// cycles area
		if (sg.scale > 0.4)
			for (let co of draw_state.comps) {
				for (let c of co.cycles) {
					if (c.outer)
						continue
					let [x, y] = c.area_pos
					x = sg.x(x)
					y = sg.y(y)
					cx.fillStyle = ui.fg_color('label')
					let s = format_area(c.edges.area())
					if (DEBUG_PLAN) s = co.i + '/' + c.i + ' ' + s
					cx.fillText(s, x, y+5)
				}
			}

		// edge measurements
		let me = draw_state.measure_edges
		if (me) {
			for (let [ep1, ep2] of me) {
				let x1 = ep1[0]
				let y1 = ep1[1]
				let x2 = ep2[0]
				let y2 = ep2[1]
				;[x1, y1, x2, y2] = line2.offset(-10, x1, y1, x2, y2, [])
				draw_length(cx, sg, x1, y1, x2, y2)
			}
		}

		// hit point
		if (hit_x != null && hit_y != null) {
			let x = sg.x(hit_x)
			let y = sg.y(hit_y)
			cx.beginPath()
			cx.arc(x, y, 3, 0, 2*PI)
			cx.strokeStyle = 'black'
			cx.lineWidth = 3
			cx.stroke()
			cx.lineWidth = 1
			cx.fillStyle = 'white'
			cx.fill()
		}

		// orthogonal measurements
		if (0)
		for (let i = 0; i < 2; i++) {
			for (let m of draw_state.plan_snap_lines[i]) {
				let x = sg.x(i == 0 ? m : -50)
				let y = sg.y(i == 1 ? m : -20)
				cx.save()
				cx.translate(x, y)
				//if (i == 0)
					cx.rotate(-PI/4)
				cx.fillStyle = 'white' //ui.fg_color('label')
				cx.strokeStyle = 'black'
				cx.shadowBlur = 4
				cx.shadowColor = 'black'
				let s = format_length(m)
				cx.fillText(s, 0, 0)
				cx.restore()
			}
		}

		// cursor
		let seg = drag_action == 'move_seg' && drag_seg || (hit_action == 'move_seg' && hit_seg)
		if (seg) {
			if (seg[0].segs.length == 1 && seg[1].segs.length == 1)
				ui.set_cursor('move')
			else
				ui.set_cursor(seg_is_v(seg[0], seg[1]) ? 'ew-resize' : 'ns-resize')
		} else if (hit_p)
			ui.set_cursor('copy')
		else if (drag_action == 'pan')
			ui.set_cursor('grabbing')
		else if (hs) {
			if (hit_action == 'pan')
				ui.set_cursor('grab')
			else
				ui.set_cursor('copy')
		}

		// DEBUG ---------------------------------------------------------------

		// segment lines and segment numbers
		if (DEBUG_PLAN)
		for (let seg of draw_state.segs) {
			let p1 = seg[0]
			let p2 = seg[1]
			cx.beginPath()
			let x1 = sg.x(p1[0])
			let y1 = sg.y(p1[1])
			let x2 = sg.x(p2[0])
			let y2 = sg.y(p2[1])
			cx.moveTo(x1, y1)
			cx.lineTo(x2, y2)
			cx.strokeStyle = hit_seg == seg ? 'white' : '#666'
			cx.stroke()

			let [x0, y0] = seg_center(seg)
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = '#f66'
			cx.fillText(seg.i, x, y)
		}

		// point numbers
		if (DEBUG_PLAN)
		for (let p of draw_state.ps) {
			let [x0, y0] = p
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = 'white'
			cx.fillText(p.i, x, y)
		}

		// edge point numbers
		if (0 && DEBUG_PLAN)
		for (let c of draw_state.comps) {
			let co = c // no var shadowing because langauge designers are dumb
			for (let c of co.cycles) {
				for (let ep of c.edges) {
					let x = sg.x(ep[0]) - 5
					let y = sg.y(ep[1]) + 15
					cx.fillStyle = '#0f0'
					cx.fillText(c.i+'/'+ep.ci, x, y)
				}
			}
		}

		cx.restore()
	},

	/*	sets in hovers(id):
		action=pan                 shift pressed, pan, don't hit anything
		p                          hit joint
		seg, action=move_seg       hit segment
		seg, x or y                hit around segment along its length
		x and/or y                 hit vert and/or horiz snap line
		cycle                      inside inner cycle
	*/
	hit: function(a, i) {

		let x00 = a[i+0]
		let y00 = a[i+1]
		let w   = a[i+2]
		let h   = a[i+3]
		let id  = a[i+FLOOR_VIEW_ID]
		let draw_state = a[i+FLOOR_VIEW_DRAW_STATE]

		if (ui.captured_id != null && !ui.clickup)
			return

		if (!ui.hit_box(a, i))
			return

		let hs = ui.hover(id)
		if (!hs)
			return

		let sl = draw_state.snap_lines
		sl.length = 0

		let sg = scale_group('editor')

		let cx = ui.cx

		let pan    = ui.key('shift')
		let nosnap = ui.key('control')

		sg.zoom(ui.wheel_dy,
			ui.mx - x00,
			ui.my - y00
		)

		if (pan) {
			hs.set('action', 'pan')
			return
		}

		let plan = ui.state(id).get('plan')

		cx.save()
		cx.translate(x00, y00)
		sg.transform(cx, w, h)
		ui.update_mouse()

		let mx = sg.plan_x(ui.mx)
		let my = sg.plan_y(ui.my)

		let snap_margin = 15

		let hit_p, hit_seg, hit_action, hit_cycle

		for (let p of draw_state.ps) {
			let dx = ui.mx - sg.x(p[0])
			let dy = ui.my - sg.y(p[1])
			let snap_d = nosnap ? 2 : sg.d(p.max_offset) + sg.line_width + snap_margin
			if (abs(dx) <= snap_d && abs(dy) <= snap_d) {
				hit_p = p
				hs.set('p', p) // point to start new seg from
				hs.set('x', p[0])
				hs.set('y', p[1])
				sl.push(p[0], 1, p[1], 0)
				break
			}
		}

		if (!hit_p)
			for (let seg of draw_state.segs) {

				let x1 = seg[0][0]
				let y1 = seg[0][1]
				let x2 = seg[1][0]
				let y2 = seg[1][1]
				let v = seg_is_v(seg[0], seg[1])

				let sx1, sy1, sx2, sy2 // screen hit box

				// test over the seg's area between its offset edges.
				let m = sg.line_width
				if (v) {
					let x = x1
					sx1 = sg.x(x + seg[y1 < y2 ? -2 : -1]) - m
					sx2 = sg.x(x - seg[y1 < y2 ? -1 : -2]) + m
					sy1 = sg.y(seg_y1(seg))
					sy2 = sg.y(seg_y2(seg))
				} else if (y1 == y2) {
					let y = y1
					sy1 = sg.y(y + seg[x1 > x2 ? -2 : -1]) - m
					sy2 = sg.y(y - seg[x1 > x2 ? -1 : -2]) + m
					sx1 = sg.x(seg_x1(seg))
					sx2 = sg.x(seg_x2(seg))
				} else {
					continue
				}
				if (ui.hit_bb(sx1, sy1, sx2, sy2)) {
					hit_seg = seg
					hit_action = 'move_seg'
					hs.set('seg', seg)
					hs.set('action', hit_action)
					break
				}

				// try a wider area and compute the point of the mouse projected on the seg.
				if (v) {
					sx1 -= snap_margin
					sx2 += snap_margin
				} else {
					sy1 -= snap_margin
					sy2 += snap_margin
				}
				if (ui.hit_bb(sx1, sy1, sx2, sy2)) {
					hit_seg = seg
					hs.set('seg', seg)
					let sx = !v ? plan.snap_x(mx, nosnap) ?? mx : null
					let sy = v  ? plan.snap_y(my, nosnap) ?? my : null
					hs.set('x', sx ?? x1)
					hs.set('y', sy ?? y1)
					if (sx != null) sl.push(sx, 1)
					if (sy != null) sl.push(sy, 0)
					break
				}

			}

		// hit snapping point
		if (!hit_p && !hit_seg) {
			let sx = plan.snap_x(mx, nosnap)
			let sy = plan.snap_y(my, nosnap)
			hs.set('x', sx ?? mx)
			hs.set('y', sy ?? my)
			if (sx != null) sl.push(sx, 1)
			if (sy != null) sl.push(sy, 0)
		}

		// hit inner cycle
		if (!hit_p && !hit_seg) {
			hit_cycle = plan.hit_cycles(mx, my)
			if (hit_cycle)
				hs.set('cycle', hit_cycle)
		}

		cx.restore()
		ui.update_mouse()

	},

})

// roof plan view ------------------------------------------------------------


let ROOF_PLAN_VIEW_ID         = ui.S-1
let ROOF_PLAN_VIEW_DRAW_STATE = ui.S+0

ui.box_widget('roof_plan_view', {

	create: function(cmd, id, plan, fr, align, valign, min_w, min_h) {

		let s = ui.state(id)
		let draw_state = s.get('draw_state')
		if (!draw_state) {
			draw_state = {snap_lines: [], measure_edges: [], above_floors: [], below_floors: []}
			s.set('draw_state', draw_state)
		}
		s.set('plan', plan)

		let [dstate, dx, dy] = ui.drag(id)

		let sg = scale_group('editor')

		dx /= sg.scale
		dy /= sg.scale

		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {

			let hs = ui.hover(id)
			let cs = ui.captured(id)

			if (dstate == 'drag') {

				let action = hs.get('action')
				let seg    = hs.get('seg')
				let p      = hs.get('p')

				if (action == 'move_seg') { // move seg
					cs.set('move_seg', plan.start_move_seg(seg, draw_state))
				} else if (action == 'pan') {
					sg.pan_x0 = sg.x0
					sg.pan_y0 = sg.y0
					cs.set('action', action)
				}
			}

			let action = cs.get('action')

			if (!action && (abs(dx) >= 10 || abs(dy) >= 10)) { // dragged far enough to assume intent to drag.

				// establish direction of drag on x and y axis.
				let sdx = abs(dx) > 1.5 * abs(dy) ? sign(dx) : 0 // straight enough
				let sdy = abs(dy) > 1.5 * abs(dx) ? sign(dy) : 0 // straight enough
				if (sdx || sdy) {
					action = 'resize_seg'
					cs.set('action', action)
					let p   = cs.get('p')
					let mx0 = cs.get('x')
					let my0 = cs.get('y')
					let s = plan.start_resize_seg(p, mx0, my0, dx, dy, sdx, sdy, draw_state)
					cs.set('resize_seg', s)
				}

			}

			if (action == 'move_seg')
				cs.get('move_seg').move(dx, dy, draw_state)

			if (action == 'resize_seg')
				cs.get('resize_seg').resize(dx, dy, draw_state, hs)

			if (action == 'pan') {
				sg.x0 = sg.pan_x0 + sg.d(dx)
				sg.y0 = sg.pan_y0 + sg.d(dy)
				sg.panned = true
			}

			if (dstate == 'drop') {
				if (action == 'move_seg') {
					cs.get('move_seg').stop(draw_state, ui.dblclick)
				} else if (action == 'resize_seg') {
					cs.get('resize_seg').stop(draw_state)
				}
			}

		}

		ui.stack()

			ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
					id, draw_state,
				)

			ui.m(ui.sp())
			ui.v(1, ui.sp())

				ui.h(0, ui.sp05(), 's', 't')

					ui.bold()
					ui.text('', floor_names[plan.i] ?? S(plan.i+'_floor', '{0}ᵗʰ FLOOR', plan.i))

					if (!ui.window_focused) {
						ui.p(ui.sp05(), 0)
						ui.stack('', 0, '[')
							ui.font('far')
							ui.nobold()
							ui.xlarge()
							ui.color('text')
							ui.text('', '\uf11c', 0, 'c', 'c')
							ui.polyline('', '0 5  35 20', 1, null, null, 'text', null, 2)
						ui.end_stack()
					}

					ui.v(1); ui.end()

					if (sg.zoomed) {
						if (ui.icon_button(id+'.zoom_button', 'fas', sg.scale > 1 ? '\uf00e' : '\uf010', 0, ']')) {
							sg.reset_zoom()
							ui.redraw()
						}
					}

					if (ui.icon_button(id+'.rotate_button', 'fas', '\uf2f1', 0)) {
						sg.rotation = ((sg.rotation ?? 0) + 90*rad) % (360*rad)
						ui.animate()
					}

					if (ui.icon_button(id+'.grid_button', 'fas', '\uf00a', 0)) {
						sg.show_grid = !sg.show_grid
						ui.animate()
					}

				ui.end_h()

				ui.button_stack('', 0, ']')
				ui.button_bb()

					ui.v(0, ui.sp())

						{
						let state = ui.button_state(id+'.c1')
						ui.button_icon('fas', '\uf245', state)
						}

						{
						let state = ui.button_state(id+'.c2')
						ui.button_icon('fas', '\uf0b2', state)
						}

					ui.end_v()

				ui.end_button_stack()

			ui.end_v()

		ui.end_stack()

	},

	after_position: function(a, i, axis)	{
		let sg = scale_group('editor')
		if (!axis) {
			sg.set_scale(1/0)
			return
		}
		let w  = a[i+2]
		let h  = a[i+3]
		let id = a[i+FLOOR_VIEW_ID]
		let plan = ui.state(id).get('plan')
		sg.scale_to_fit(plan.house.bb, w, h)
	},

	after_translate: function(a, i) {
		let x00 = a[i+0]
		let y00 = a[i+1]
		let id = a[i+FLOOR_VIEW_ID]
		let draw_state = a[i+FLOOR_VIEW_DRAW_STATE]

		let sg = scale_group('editor')
		let plan = ui.state(id).get('plan')

		draw_state.x0 = sg.x0
		draw_state.y0 = sg.y0
		draw_state.scale = sg.scale
		draw_state.rotation = sg.rotation

		// pick what parts of the plan to send over the network for drawing
		// and in which format. note that the plan has arrays with props but
		// the props will not be sent over because of how json works.
		draw_state.comps = plan.comps
		draw_state.segs = plan.segs // TODO: remove this from draw stream
		draw_state.ps = plan.ps // TODO: remove this from draw stream
		draw_state.plan_snap_lines = plan.snap_lines

		draw_state.above_floors.length = 0
		draw_state.below_floors.length = 0
		for (let plan1 of plan.house.floors) {
			if (plan1 == plan)
				continue
			let t = {comps: plan1.comps, segs: plan1.segs}
			let a = plan1.i > plan.i ? draw_state.above_floors : draw_state.below_floors
			a.push(t)
		}

	},

	draw: function(a, i) {

		let x00   = a[i+0]
		let y00   = a[i+1]
		let w     = a[i+2]
		let h     = a[i+3]
		let id    = a[i+FLOOR_VIEW_ID]
		let draw_state = a[i+FLOOR_VIEW_DRAW_STATE]
		let x0 = draw_state.x0
		let y0 = draw_state.y0

		x00 += ui.focused(id) ? 100 : 0

		let hs = ui.hit(id)
		let cs = ui.captured(id)
		let hit_action  = hs?.get('action')
		let hit_seg     = hs?.get('seg')
		let hit_p       = hs?.get('p')
		let hit_cycle   = hs?.get('cycle')
		let hit_x       = hs?.get('x')
		let hit_y       = hs?.get('y')
		let drag_action = cs?.get('action')
		let drag_seg    = cs?.get('seg')

		let sg = scale_group('editor')
		sg.set_scale(draw_state.scale)
		sg.rotation = draw_state.rotation

		let cx = ui.cx
		cx.save()

		cx.beginPath()
		cx.rect(x00, y00, w, h)
		cx.clip()

		cx.translate(x00, y00)
		cx.font = 'bold 14px sans-serif'

		// fixed grid
		draw_grids(cx, sg, x0, y0, w, h)

		// legend
		{
		let m = ui.em()
		let cm = 100
		let d = sg.d(cm)
		while (d > w - 2*m) {
			cm /= 5
			d = sg.d(cm)
		}
		cx.beginPath()
		let t = 4
		let x = w - d - m - t
		let y = h - m - t
		cx.rect(x, y, d, t)
		cx.fillStyle = ui.fg_color('label')
		cx.fill()
		let s = format_length(cm)
		let tw = ui.measure_text(cx, s).width
		cx.fillText(s, x + d - tw, y - 2)
		}

		// help
		{
		let m = ui.em()
		cx.fillStyle = ui.fg_color('label')
		let s = 'CTRL=No Snap  SHIFT=Pan'
		cx.fillText(s, m, h - m)
		}

		sg.transform(cx, w, h)

		// below floors
		cx.globalAlpha = .1
		for (let plan1 of draw_state.below_floors)
			draw_walls(cx, sg, plan1.comps, plan1.segs)
		cx.globalAlpha = 1

		// snap lines
		cx.setLineDash([5, 8])
		cx.strokeStyle = ui.dark() ? '#555' : '#999'
		for (let i = 0, sl = draw_state.snap_lines, n = sl.length; i < n; i += 2) {
			let sa   = sl[i]
			let is_v = sl[i+1]
			let x1, y1, x2, y2
			if (is_v) {
				x1 = sg.x(sa)
				x2 = sg.x(sa)
				y1 = -draw_state.y0
				y2 = -draw_state.y0 + h
			} else {
				y1 = sg.y(sa)
				y2 = sg.y(sa)
				x1 = -draw_state.x0
				x2 = -draw_state.x0 + w
			}
			cx.beginPath()
			cx.moveTo(x1+.5, y1+.5)
			cx.lineTo(x2+.5, y2+.5)
			cx.stroke()
		}
		cx.setLineDash([])

		// room backgrounds
		for (let co of draw_state.comps) {
			for (let c of co.cycles) {
				if (c.outer)
					continue
				if (!c.edges)
					continue

				cx.beginPath()

				draw_edges(cx, sg, c.edges)

				// island outer cycles are clockwise so they draw as holes.
				for (let icomp of c.islands)
					draw_edges(cx, sg, icomp.outer_cycle.edges)

				cx.fillStyle = ui.alpha_adjust(ui.bg_color_hsl('bg1', hit_cycle == c ? 'hover' : null), .5)
				cx.fill()
			}
		}

		// walls of this floor
		draw_walls(cx, sg, draw_state.comps, draw_state.segs)

		// walls of above floor
		cx.globalAlpha = .1
		for (let plan1 of draw_state.above_floors)
			draw_walls(cx, sg, plan1.comps, plan1.segs)
		cx.globalAlpha = 1

		// cycles area
		if (sg.scale > 0.4)
			for (let co of draw_state.comps) {
				for (let c of co.cycles) {
					if (c.outer)
						continue
					let [x, y] = c.area_pos
					x = sg.x(x)
					y = sg.y(y)
					cx.fillStyle = ui.fg_color('label')
					let s = format_area(c.edges.area())
					if (DEBUG_PLAN) s = co.i + '/' + c.i + ' ' + s
					cx.fillText(s, x, y+5)
				}
			}

		// edge measurements
		let me = draw_state.measure_edges
		if (me) {
			for (let [ep1, ep2] of me) {
				let x1 = ep1[0]
				let y1 = ep1[1]
				let x2 = ep2[0]
				let y2 = ep2[1]
				;[x1, y1, x2, y2] = line_offset(-10, x1, y1, x2, y2, [])
				draw_length(cx, sg, x1, y1, x2, y2)
			}
		}

		// hit point
		if (hit_x != null && hit_y != null) {
			let x = sg.x(hit_x)
			let y = sg.y(hit_y)
			cx.beginPath()
			cx.arc(x, y, 3, 0, 2*PI)
			cx.strokeStyle = 'black'
			cx.lineWidth = 3
			cx.stroke()
			cx.lineWidth = 1
			cx.fillStyle = 'white'
			cx.fill()
		}

		// orthogonal measurements
		if (0)
		for (let i = 0; i < 2; i++) {
			for (let m of draw_state.plan_snap_lines[i]) {
				let x = sg.x(i == 0 ? m : -50)
				let y = sg.y(i == 1 ? m : -20)
				cx.save()
				cx.translate(x, y)
				//if (i == 0)
					cx.rotate(-PI/4)
				cx.fillStyle = 'white' //ui.fg_color('label')
				cx.strokeStyle = 'black'
				cx.shadowBlur = 4
				cx.shadowColor = 'black'
				let s = format_length(m)
				cx.fillText(s, 0, 0)
				cx.restore()
			}
		}

		// cursor
		let seg = drag_action == 'move_seg' && drag_seg || (hit_action == 'move_seg' && hit_seg)
		if (seg) {
			if (seg[0].segs.length == 1 && seg[1].segs.length == 1)
				ui.set_cursor('move')
			else
				ui.set_cursor(seg_is_v(seg[0], seg[1]) ? 'ew-resize' : 'ns-resize')
		} else if (hit_p)
			ui.set_cursor('copy')
		else if (drag_action == 'pan')
			ui.set_cursor('grabbing')
		else if (hs) {
			if (hit_action == 'pan')
				ui.set_cursor('grab')
			else
				ui.set_cursor('copy')
		}

		// DEBUG ---------------------------------------------------------------

		// segment lines and segment numbers
		if (DEBUG_PLAN)
		for (let seg of draw_state.segs) {
			let p1 = seg[0]
			let p2 = seg[1]
			cx.beginPath()
			let x1 = sg.x(p1[0])
			let y1 = sg.y(p1[1])
			let x2 = sg.x(p2[0])
			let y2 = sg.y(p2[1])
			cx.moveTo(x1, y1)
			cx.lineTo(x2, y2)
			cx.strokeStyle = hit_seg == seg ? 'white' : '#666'
			cx.stroke()

			let [x0, y0] = seg_center(seg)
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = '#f66'
			cx.fillText(seg.i, x, y)
		}

		// point numbers
		if (DEBUG_PLAN)
		for (let p of draw_state.ps) {
			let [x0, y0] = p
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = 'white'
			cx.fillText(p.i, x, y)
		}

		// edge point numbers
		if (0 && DEBUG_PLAN)
		for (let c of draw_state.comps) {
			let co = c // no var shadowing because langauge designers are dumb
			for (let c of co.cycles) {
				for (let ep of c.edges) {
					let x = sg.x(ep[0]) - 5
					let y = sg.y(ep[1]) + 15
					cx.fillStyle = '#0f0'
					cx.fillText(c.i+'/'+ep.ci, x, y)
				}
			}
		}

		cx.restore()
	},

	/*	sets in hovers(id):
		action=pan                 shift pressed, pan, don't hit anything
		p                          hit joint
		seg, action=move_seg       hit segment
		seg, x or y                hit around segment along its length
		x and/or y                 hit vert and/or horiz snap line
		cycle                      inside inner cycle
	*/
	hit: function(a, i) {

		let x00 = a[i+0]
		let y00 = a[i+1]
		let w   = a[i+2]
		let h   = a[i+3]
		let id  = a[i+FLOOR_VIEW_ID]
		let draw_state = a[i+FLOOR_VIEW_DRAW_STATE]

		if (ui.captured_id != null && !ui.clickup)
			return

		if (!ui.hit_box(a, i))
			return

		let hs = ui.hover(id)
		if (!hs)
			return

		let sl = draw_state.snap_lines
		sl.length = 0

		let sg = scale_group('editor')

		let cx = ui.cx

		let pan    = ui.key('shift')
		let nosnap = ui.key('control')

		sg.zoom(ui.wheel_dy,
			ui.mx - x00,
			ui.my - y00
		)

		if (pan) {
			hs.set('action', 'pan')
			return
		}

		let plan = ui.state(id).get('plan')

		cx.save()
		cx.translate(x00, y00)
		sg.transform(cx, w, h)
		ui.update_mouse()

		let mx = sg.plan_x(ui.mx)
		let my = sg.plan_y(ui.my)

		let snap_margin = 15

		let hit_p, hit_seg, hit_action, hit_cycle

		for (let p of draw_state.ps) {
			let dx = ui.mx - sg.x(p[0])
			let dy = ui.my - sg.y(p[1])
			let snap_d = nosnap ? 2 : sg.d(p.max_offset) + sg.line_width + snap_margin
			if (abs(dx) <= snap_d && abs(dy) <= snap_d) {
				hit_p = p
				hs.set('p', p) // point to start new seg from
				hs.set('x', p[0])
				hs.set('y', p[1])
				sl.push(p[0], 1, p[1], 0)
				break
			}
		}

		if (!hit_p)
			for (let seg of draw_state.segs) {

				let x1 = seg[0][0]
				let y1 = seg[0][1]
				let x2 = seg[1][0]
				let y2 = seg[1][1]
				let v = seg_is_v(seg[0], seg[1])

				let sx1, sy1, sx2, sy2 // screen hit box

				// test over the seg's area between its offset edges.
				let m = sg.line_width
				if (v) {
					let x = x1
					sx1 = sg.x(x + seg[y1 < y2 ? -2 : -1]) - m
					sx2 = sg.x(x - seg[y1 < y2 ? -1 : -2]) + m
					sy1 = sg.y(seg_y1(seg))
					sy2 = sg.y(seg_y2(seg))
				} else if (y1 == y2) {
					let y = y1
					sy1 = sg.y(y + seg[x1 > x2 ? -2 : -1]) - m
					sy2 = sg.y(y - seg[x1 > x2 ? -1 : -2]) + m
					sx1 = sg.x(seg_x1(seg))
					sx2 = sg.x(seg_x2(seg))
				} else {
					continue
				}
				if (ui.hit_bb(sx1, sy1, sx2, sy2)) {
					hit_seg = seg
					hit_action = 'move_seg'
					hs.set('seg', seg)
					hs.set('action', hit_action)
					break
				}

				// try a wider area and compute the point of the mouse projected on the seg.
				if (v) {
					sx1 -= snap_margin
					sx2 += snap_margin
				} else {
					sy1 -= snap_margin
					sy2 += snap_margin
				}
				if (ui.hit_bb(sx1, sy1, sx2, sy2)) {
					hit_seg = seg
					hs.set('seg', seg)
					let sx = !v ? plan.snap_x(mx, nosnap) ?? mx : null
					let sy = v  ? plan.snap_y(my, nosnap) ?? my : null
					hs.set('x', sx ?? x1)
					hs.set('y', sy ?? y1)
					if (sx != null) sl.push(sx, 1)
					if (sy != null) sl.push(sy, 0)
					break
				}

			}

		// hit snapping point
		if (!hit_p && !hit_seg) {
			let sx = plan.snap_x(mx, nosnap)
			let sy = plan.snap_y(my, nosnap)
			hs.set('x', sx ?? mx)
			hs.set('y', sy ?? my)
			if (sx != null) sl.push(sx, 1)
			if (sy != null) sl.push(sy, 0)
		}

		// hit inner cycle
		if (!hit_p && !hit_seg) {
			hit_cycle = plan.hit_cycles(mx, my)
			if (hit_cycle)
				hs.set('cycle', hit_cycle)
		}

		cx.restore()
		ui.update_mouse()

	},

})

// face view -----------------------------------------------------------------

let FACE_VIEW_ID         = ui.S-1
let FACE_VIEW_FACE       = ui.S+0
let FACE_VIEW_DRAW_STATE = ui.S+1

function draw_cycle(cx, sg, ps) {
	for (let p of ps) {
		let x = sg.x(p[0])
		let y = sg.y(p[1])
		if (p == ps[0])
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()
}

function draw_face_plane(cx, sg, plane, min_depth, max_depth) {
	for (let comp of plane.comps) {
		if (0) {
		for (let seg of comp.segs) {
			let [p1, p2] = seg
			let [x1, y1] = p1
			let [x2, y2] = p2
			cx.moveTo(sg.x(x1), sg.y(y1))
			cx.lineTo(sg.x(x2), sg.y(y2))
		}
		} else {
		cx.beginPath()
		for (let c of comp.cycles) {
			if (c.outer)
				continue
			draw_cycle(cx, sg, c)
		}
		cx.fillStyle = ui.hsl_adjust(ui.bg_color_hsl('bg3'), 1, 1, lerp(plane.depth, min_depth, max_depth, 0.5, 1))
		cx.fill()
		}
		cx.strokeStyle = ui.fg_color('text')
		cx.stroke()
	}
}

function draw_face_planes(cx, sg, planes, min_depth, max_depth) {
	for (let plane of planes)
		draw_face_plane(cx, sg, plane, min_depth, max_depth)
}

function face_view_scale_group(face_i) {
	return scale_group('face_view_'+(face_is_v(face_i) ? 'v' : 'h'))
}

ui.box_widget('face_view', {

	create: function(cmd, id, house, face_i, fr, align, valign, min_w, min_h) {

		let s = ui.state(id)
		let draw_state = s.get('draw_state')
		if (!draw_state) {
			draw_state = {snap_lines: [], measure_edges: []}
			s.set('draw_state', draw_state)
		}
		let face = house.faces[face_i]
		s.set('face', face)
		draw_state.planes = face.planes
		draw_state.min_depth = face.bb[4]
		draw_state.max_depth = face.bb[5]

		let [dstate, dx, dy] = ui.drag(id)

		let sg = face_view_scale_group(face_i)

		dx /= sg.scale
		dy /= sg.scale

		return ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
				id, face_i, draw_state,
			)
	},

	after_position: function(a, i, axis)	{
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let face_i = a[i+FACE_VIEW_FACE]
		let sg = face_view_scale_group(face_i)
		if (!axis) {
			sg.set_scale(1/0)
		} else {
			let face = ui.state(id).get('face')
			sg.scale_to_fit(face.bb, w, h)
		}
	},

	after_translate: function(a, i) {
		let x00  = a[i+0]
		let y00  = a[i+1]
		let id   = a[i+FACE_VIEW_ID]
		let face_i = a[i+FACE_VIEW_FACE]
		let draw_state = a[i+FACE_VIEW_DRAW_STATE]

		let sg = face_view_scale_group(face_i)
		let face = ui.state(id).get('face')

		draw_state.x0 = sg.x0
		draw_state.y0 = sg.y0
		draw_state.scale = sg.scale
	},

	draw: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let face_i = a[i+FACE_VIEW_FACE]
		let draw_state = a[i+FACE_VIEW_DRAW_STATE]
		let x0 = draw_state.x0
		let y0 = draw_state.y0

		let hs = ui.hit(id)

		let sg = face_view_scale_group(face_i)
		sg.set_scale(draw_state.scale)

		let cx = ui.cx

		cx.beginPath()

		cx.save()

		cx.translate(x00, y00)

		cx.beginPath()
		cx.rect(0, 0, w, h)
		cx.clip()

		cx.save()

		// fixed grid
		sg.show_grid = true
		draw_grids(cx, sg, x0, y0, w, h)

		sg.transform(cx, w, h)

		//sg.transform(cx, w, h)

		draw_face_planes(cx, sg,
			draw_state.planes,
			draw_state.min_depth,
			draw_state.max_depth)

		cx.restore()

		let m = ui.sp()
		cx.fillStyle = ui.fg_color('text')
		cx.fillText(((['SOUTH','WEST','NORTH','EAST'])[face_i])+' FACE', m, m + 14)

		cx.restore()

	},

	hit: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let face_i = a[i+FACE_VIEW_FACE]

		return

	},

})

// test UI -------------------------------------------------------------------

if (0)
G.test_plan = house({

	floor_h: 250,
	floors: [
		{
			lines: [
				// outside rect
				[[0,0],[500,0]],
				[[500,0],[500,500]],
				[[500,500],[0,500]],
				[[0,500],[0,0]],

				[[0,300],[500,300]],
				[[0,200],[300,200]],
				[[200,0],[200,400]],

				// peninsula
				[[300,200],[300,100]],
				[[300,100],[400,100]],
				[[400,100],[400,200]],
				[[400,200],[300,200]],

				[[200,400],[300,400]],

				[[500,300],[600,300]],
				[[600,300],[600,400],],
				[[600,300],[700,300]],

				// brick-like-layout for testing seg detach on seg move

				// [[700,500],[700,1000]],
				// [[700,1000],[1200,1000]],
				// [[1200,1000],[1200,500]],
				// [[1200,500],[700,500]],
				// [[900,500],[900,1000]],
				// [[700,600],[900,600]],
				// [[700,800],[900,800]],
				// [[900,700],[1200,700]],
			],
		},
		{
			lines: [
				[[100,300],[600,300]],
				[[100,300],[100,100]],

				// second volume

				[[0,600],[600,600]],
				[[600,600],[600,1000]],
				[[600,1000],[0,1000]],
				[[0,1000],[0,600]],

				// TODO: remove
				[[0,800],[50,800]],
				[[600,800],[500,800]],

				// island for testing inside check

				[[100,650],[350,650]],
				[[350,650],[350,900]],
				[[350,900],[100,900]],
				[[100,900],[100,650]],

				[[150,700],[200,700]],
				[[200,700],[200,800]],
				[[200,800],[150,800]],
				[[150,800],[150,700]],

				[[300,700],[250,700]],
				[[250,700],[250,800]],
				[[250,800],[300,800]],
				[[300,800],[300,700]],

			],

			roofs: [
				{type: 'gable', pitch: 45, eaves: 50, axis: 'h', h: 200, box: [0,600,600,1000]},
			],

		},

	],

})

G.test_plan = house({

	floor_h: 250,
	floors: [
		{
			points: [
				[200,  0, 'cl'],
				[200,400, 'cr'],
			],
			lines: [
				['draw',0,0, 'tr',600, 'br',400, 'bl',-600, 'tl',-400],
				['connect','cl','cr'],
			],
			roofs: [
				{type: 'gable', pitch: 45, eaves: 50, axis: 'h', h: 200, box: [0,0,600,400]},
			],
		},
	],

})

ui.main = function() {

	ui.m(20)

	ui.v()

		ui.h(0, ui.sp05())

			if (ui.button('debug_plan_button', 'DEBUG', 0))
				DEBUG_PLAN = !DEBUG_PLAN

			if (ui.button('btn_light', 'lights', 0))
				ui.default_theme = ui.default_theme == 'light' ? 'dark' : 'light'

		ui.end_h()

		ui.h()

			ui.v()

				ui.h()

					for (let floor of test_plan.floors) {
						ui.m(10)
						ui.stack()
							ui.bb('', null, null, 1, 'light')
							ui.floor_view('floor_view_'+floor.i, floor)
						ui.end_stack()
					}

				ui.end_h()

				if (0) {
				ui.h()

					for (let floor of test_plan.floors) {
						ui.m(10)
						ui.stack()
							ui.bb('', null, null, 1, 'light')
							// ui.roof_view('rv'+floor.i, floor)
						ui.end_stack()
					}

				ui.end_h()
				}

			ui.end_v()

			ui.modeleditor('test_medit', test_plan)

			if (0) {
			ui.v()

				for (let face of test_plan.faces) {
					ui.m(10)
					ui.stack()
						ui.bb('', null, null, 1, 'light')
						ui.face_view('face_view_'+face.i, test_plan, face.i)
					ui.end_stack()
				}

			ui.end_v()
			}

		ui.end_h()

	ui.end_v()

}

DEBUG_PLAN = 0

}()) // module function

</script>
</body>
</html>
