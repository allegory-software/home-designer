<!DOCTYPE html>
<html theme=dark>
<body>
<base href="www2/">
<link rel="preload" href="fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="fa-solid-900.woff2"   as="font" type="font/woff2" crossorigin>
<script src=glue.js global extend></script>
<script src=ui.js></script>
<script src=ui_validation.js></script>
<script src=ui_nav.js></script>
<script src=ui_grid.js></script>
<script>

(function () {
"use strict"
const G = window

DEBUG('DEBUG_PLAN')

let clone = structuredClone

// debugging -----------------------------------------------------------------

let errs = []
let log_stack = []
function log(err, ...args) {
	errs.push(isstr(err) ? subst(err, ...args) : err)
}
function log_push() {
	log_stack.push(errs)
	errs = []
	errs.t0 = clock()
}
function log_pop(err, ...args) {
	let errs1 = errs
	let dt = (clock() - errs1.t0) * 1000
	errs1.dt = dt
	errs = log_stack.pop()
	if (err !== undefined && errs1.length) {
		log(err, ...args)
		log(errs1)
		if (dt > 3)
			log('{0} TIME {1} ms', ('*').repeat(dt), dec(dt))
	} else {
		return errs1
	}
}
function check(v, ...args) {
	if (!v) log(...args)
	return v
}
function pr_errs(es, level) {
	let indent = ('  ').repeat(level)
	for (let s of es)
		if (isarray(s))
			pr_errs(s, level+1)
		else
			pr(indent + s)
}
function pr_log() {
	assert(!log_stack.length)
	pr_errs(errs, 0)
	errs.length = 0
}

// house plan model ----------------------------------------------------------

let ps = [
	[0,0],
	[500,0],
	[500,500],
	[0,500],
	[0,300],
	[500,300],
	[0,200],
	[300,200],
	[200,0],
	[200,400],

	[300,200],
	[300,100],
	[400,100],
	[400,200],

	[200,400],
	[300,400],

	[-100,0],

	[600,300],
	[600,400],
	[700,300],

	[0,600+0],
	[300,600+0],
	[300,600+300],
	[0,600+300],

	[100,650],
	[200,650],
	[200,800],
	[100,800],

]

let segs = [
	[[0,0],[500,0]],
	[1,2],
	[2,3],
	[3,0],
	[4,5],
	[6,7],
	[8,9],

	[10,11],
	[11,12],
	[12,13],
	[13,10],

	[14,15],

	[16,0],

	[5,17],
	[17,18],
	[17,19],

	[20,21],
	[21,22],
	[22,23],
	[23,20],

	[24,25],
	[25,26],
	[26,27],
	[27,24],

	[[700,500],[700,1000]],
	[[700,1000],[1200,1000]],
	[[1200,1000],[1200,500]],
	[[1200,500],[700,500]],
	[[900,500],[900,1000]],
	[[700,600],[900,600]],
	[[700,800],[900,800]],
	[[900,700],[1200,700]],
]

let cycles = []

G.ps = ps
G.segs = segs
G.cycles = cycles

// model editing -------------------------------------------------------------

function is_h(seg) { return seg[0][1] == seg[1][1] }
function is_v(seg) { return seg[0][0] == seg[1][0] }
function is_null(seg) { return is_h(seg) && is_v(seg) }

function seg_x1(seg) { return min(seg[0][0], seg[1][0]) }
function seg_y1(seg) { return min(seg[0][1], seg[1][1]) }
function seg_x2(seg) { return max(seg[0][0], seg[1][0]) }
function seg_y2(seg) { return max(seg[0][1], seg[1][1]) }

function set_seg_x1(seg, x) { let x1i = seg[0][0] < seg[1][0] ? 0 : 1; seg[x1i][0] = x }
function set_seg_y1(seg, y) { let y1i = seg[0][1] < seg[1][1] ? 0 : 1; seg[y1i][1] = y }
function set_seg_x2(seg, x) { let x2i = seg[0][0] < seg[1][0] ? 1 : 0; seg[x2i][0] = x }
function set_seg_y2(seg, y) { let y2i = seg[0][1] < seg[1][1] ? 1 : 0; seg[y2i][1] = y }

function seg_axis(seg) { return is_v(seg) ? seg_x1(seg) : seg_y1(seg) }
function seg_m1  (seg) { return is_v(seg) ? seg_y1(seg) : seg_x1(seg) }
function seg_m2  (seg) { return is_v(seg) ? seg_y2(seg) : seg_x2(seg) }

function set_seg_m1  (seg, m) { if (is_v(seg)) set_seg_y1(seg, m); else set_seg_x1(seg, m) }
function set_seg_m2  (seg, m) { if (is_v(seg)) set_seg_y2(seg, m); else set_seg_x2(seg, m) }
function set_seg_axis(seg, a) {
	if (is_v(seg)) {
		seg[0][0] = a
		seg[1][0] = a
	} else {
		seg[0][1] = a
		seg[1][1] = a
	}
}

function points_equal(p1, p2) { return p1[0] == p2[0] && p1[1] == p2[1] }

function adj_point_index(seg, p) {
	return seg[0] == p ? 1 : seg[1] == p ? 0 : null
}
function adj_point(seg, p) {
	return assert(seg[adj_point_index(seg, p)])
}

function normalize_seg(seg) {
	let M = is_v(seg) ? 1 : 0
	let p1 = seg[0]
	let p2 = seg[1]
	if (p1[M] > p2[M]) {
		seg[0] = p2
		seg[1] = p1
	}
}

function init_point(p, i) {
	p.segs = []
	p.adj = []
	p.i = i
}

function add_point(x, y) {
	let p = [x, y]
	init_point(p, ps.length)
	ps.push(p)
	log('point added: {0}', p.i)
	return p
}

function rem_point(p) {
	remove_value(ps, p)
	log('point removed: {0}', p.i)
}

function rem_points(cond, msg) {
	let a = []
	remove_values(ps, function(p) {
		if (!cond(p)) return
		a.push(p.i)
		return true
	})
	if (a.length)
		log('{0} removed: {1}', msg ?? 'points', a.join(' '))
}

function add_seg_ref(p, seg) {
	p.segs.push(seg)
}

function rem_seg_ref(p, seg) {
	remove_value(p.segs, seg)
}

function add_seg_refs(seg) {
	add_seg_ref(seg[0], seg)
	add_seg_ref(seg[1], seg)
}

function rem_seg_refs(seg) {
	rem_seg_ref(seg[0], seg)
	rem_seg_ref(seg[1], seg)
}

function add_seg(p1, p2) {
	let seg = [p1, p2]
	seg.i = segs.length
	normalize_seg(seg)
	segs.push(seg)
	add_seg_refs(seg)
	log('seg added: {0}: {1} {2}', seg.i, seg[0].i, seg[1].i)
	return seg
}

function rem_seg(seg) {
	rem_seg_refs(seg)
	remove_value(segs, seg)
	log('seg removed: {0}', seg.i)
}

function rem_segs(cond, msg) {
	let a = []
	remove_values(segs, function(seg) {
		if (!cond(seg)) return
		rem_seg_refs(seg)
		a.push(seg.i)
		return true
	})
	if (log && a.length)
		log('{0} removed: {1}', msg ?? 'segs', a.join(','))
}

function rem_marked_segs(msg) {
	rem_segs(seg => seg.removed, msg)
}

function set_seg_point(seg, i, p) {
	let old_p = seg[i]
	rem_seg_ref(old_p, seg)
	seg[i] = p
	add_seg_ref(p, seg)
	log('seg end moved: {0}/{1}: {2}->{3}', seg.i, i, old_p.i, p.i)
	return old_p
}

function rebuild_seg_refs() {
	for (let p of ps)
		p.segs.length = 0
	for (let seg of segs)
		add_seg_refs(seg)
}

function remove_isolated_points() {
	rem_points(p => p.segs.length == 0, 'isolated points')
}

function remove_null_segs() {
	rem_segs(is_null, 'null segs')
}

function remove_angled_segs() {
	rem_segs(seg => !is_v(seg) && !is_h(seg), 'angled segs')
}

// NOTE: assumes segs are sorted, null segs removed, points deduplicated
function merge_colinear_segs() {
	for (let p of ps) {
		if (p.segs.length == 2) {
			let s1 = p.segs[0]
			let s2 = p.segs[1]
			if (is_v(s1) == is_v(s2)) { // colinear
				let p1i = adj_point_index(s2, p)
				let p2  = adj_point(s2, p)
				log_push()
				set_seg_point(s1, p1i, p2)
				rem_seg(s2)
				log_pop('segs merged: {0} + {1} => {0}', s1.i, s2.i, s1.i)
			}
		}
	}
}

// shortens seg at m with new point and adds new seg without detaching the original seg's end-points.
function split_seg_at(seg, m) {
	log_push()
	normalize_seg(seg)
	let m1 = seg_m1(seg)
	let m2 = seg_m2(seg)
	let x = is_v(seg) ? seg_x1(seg) : m
	let y = is_v(seg) ? m : seg_y1(seg)
	let new_p = add_point(x, y)
	let old_p = set_seg_point(seg, 1, new_p)
	let new_seg = add_seg(new_p, old_p)
	log_pop('seg split: {0} {4}>{1}<{5} => {2} {3}', seg.i, m, seg.i, new_seg.i, m1, m2)
}

// NOTE: only works for h and v segs.
function split_intersecting_segs_on(v) {
	log_push()
	for (let seg1 of segs) {
		if (is_v(seg1) == v) {
			for (let seg2 of segs) {
				if (is_v(seg2) != v) {
					let m1  = seg_m1(seg1)
					let m2  = seg_m2(seg1)
					let bm1 = seg_m1(seg2)
					let bm2 = seg_m2(seg2)
					let a   = seg_axis(seg1)
					let ba  = seg_axis(seg2)
					if (bm1 <= a && bm2 >= a && ba > m1 && ba < m2) {
						// splitting adds a seg at the end of segs array which will
						// be also tested in the outer loop and possibly split further.
						// the shortened seg is potentially split multiple times
						// in this inner loop.
						split_seg_at(seg1, ba)
					}
				}
			}
		}
	}
	rem_marked_segs('unsplit segs')
	log_pop('split all intersecting segs')
}
function split_intersecting_segs() {
	split_intersecting_segs_on(0)
	split_intersecting_segs_on(1)
}

function points_cmp(p1, p2) {
	if (p1[0] < p2[0]) return -1
	if (p1[0] > p2[0]) return  1
	if (p1[1] < p2[1]) return -1
	if (p1[1] > p2[1]) return  1
	if (p1.i < p2.i) return -1
	if (p1.i > p2.i) return  1
	return 0
}

// NOTE: leaves isolated points behind.
function deduplicate_points() {
	log_push()
	ps.sort(points_cmp)
	let p0
	for (let i = 0; i < ps.length; i++) {
		let p = ps[i]
		if (p0 && points_equal(p, p0)) {
			for (let j = 0; j < p.segs.length; j++) { // each connected seg
				let seg = p.segs[j]
				for (let i = 0; i < 2; i++) // each seg end
					if (seg[i] == p) {
						set_seg_point(seg, i, p0, 'seg end point dedup')
						j-- // because seg was just removed from p.segs
					}
			}
			continue
		}
		p0 = p
	}
	log_pop('deduplicate all points')
}

// NOTE: requires no intersecting segments.
function break_overlapping_segs() {
	log_push()
	segs.sort(function(s1, s2) {
		let v1 = is_v(s1)
		let v2 = is_v(s2)
		// level 1 grouping by direction
		if (v1 < v2) return -1
		if (v1 > v2) return  1
		let m1 = seg_axis(s1)
		let m2 = seg_axis(s2)
		// level 2 grouping by axis
		if (m1 < m2) return -1
		if (m1 > m2) return  1
		// level 3 grouping by starting point because most segments are
		// non-overlapping and we sant to skip those quickly.
		let i = v1 ? 1 : 0
		let c1 = min(s1[0][i], s1[1][i])
		let c2 = min(s2[0][i], s2[1][i])
		if (c1 < c2) return -1
		if (c1 > c2) return  1
		return 0
	})
	let i0, v0, m0
	for (let i = 0, n = segs.length; i <= n; i++) {
		let seg = segs[i]
		let v = seg ? is_v(seg) : null
		let m = seg ? seg_axis(seg) : null
		if (v0 == null) {
			i0 = i
			v0 = v
			m0 = m
		} else if (v != v0 || m != m0) {
			if (i >= i0 + 2) { // there's at least 2 segments on this axis
				for (let j = i0+1; j < i; j++) {
					let seg1 = segs[j]
					let seg0 = segs[j-1]
					let m1_1 = seg_m1(seg1)
					let m2_0 = seg_m2(seg0)
					if (m1_1 < m2_0) {
						// seg points that are overlapping segs have no _|_ joints
						// or they wouldn't be overlapping the seg, so it's safe
						// to remove the overlapping seg as long as we elongate
						// the overlapped seg.
						log('segs overlap: {0} {1}: {2}<={3}: seg {1} removed, seg {0}.m2 set to {4}',
							seg0.i, seg1.i, m1_1, m2_0, seg_m2(seg1))
						seg1.removed = true
						set_seg_m2(seg0, max(seg_m2(seg1), seg_m2(seg0)))
					}
				}
			}
			i0 = i
			v0 = v
			m0 = m
		}
	}
	rem_marked_segs()
	log_pop('breaking overlapping colinear segs')
}

function rebuild_adj_refs() {
	for (let p of ps)
		p.adj.length = 0
	for (let p of ps)
		for (let seg of p.segs)
			p.adj.push(adj_point(seg, p))
}

// finding graph components --------------------------------------------------

let comps = []
G.comps = comps

// NOTE: needs adj refs
function find_comps() {

	for (let p of ps)
		p.visited = false

	comps.length = 0

	function dfs(p, ps, segs) {
		p.visited = true
		ps.push(p)
		for (let seg of p.segs)
			segs.add(seg)
		for (p of p.adj)
			if (!p.visited)
				dfs(p, ps, segs)
	}

	for (let p of ps) {
		if (!p.visited) {
			let comp = []
			comp.i = comps.length
			let segs = set()
			comps.push(comp)
			dfs(p, comp, segs)
			comp.segs = set_toarray(segs)
			log('comp {0}: {1}', comp.i, comp.map(p=>p.i).join(' '))
		}
	}

}

function comp_bbox(comp) {
	let bx1 =  inf
	let by1 =  inf
	let bx2 = -inf
	let by2 = -inf
	for (let seg of comp.segs) {
		let [x1, y1] = seg[0]
		let [x2, y2] = seg[1]
		bx1 = min(bx1, x1, x2)
		bx2 = max(bx2, x1, x2)
		by1 = min(by1, y1, y2)
		by2 = max(by1, y1, y2)
	}
	return [bx1, by1, bx2, by2]
}

function bbox_inside(cbb, pbb) {
	let [px1, py1, px2, py2] = pbb
	let [cx1, cy1, cx2, cy2] = cbb
	return cx1 >= px1 && cx2 <= px2 && cy1 >= py1 && cy2 <= py2
}

function find_inside_comps() {
	for (let c of comps) {
		c.inside = false
		c.bb = comp_bbox(c)
	}
	for (let c of comps) {
		if (c.inside)
			continue
		for (let p of comps) {
			if (p == c)
				continue
			if (bbox_inside(c.bb, p.bb)) {
				c.inside = true
				log('comp {0} is inside', c.i)
			}
		}
	}
}

/* ---------------------------------------------------------------------------
	Algorithm for extracting all base cycles from an unidirected planar graph.
	- input: no null segs, no isolated points, no overlapping or intersecting segs allowed.
	- points can be: end-points (#adj=1), joints (#adj=2) or branch points (#adj > 2).
	- output: cycles and filaments.
	Paper : https://www.geometrictools.com/Documentation/MinimalCycleBasis.pdf
	Code  : https://github.com/vbichkovsky/min-cycles/blob/master/src/cycles.js
*/

function rem_edge(p1, p2, ps) {
	remove_value(p1.adj, p2)
	remove_value(p2.adj, p1)
	if (p1.adj == 0) remove_value(ps, p1)
	if (p2.adj == 0) remove_value(ps, p2)
}

function rem_filament(p, ps) {
	while (p && p.adj.length < 2) {
		remove_value(ps, p)
		let pa = p.adj[0]
		if (pa)
			rem_edge(p, pa, ps)
		p = pa
	}
}

function is_cw(ps) {
	let s = 0
	for (let i = 0, n = ps.length; i < n; i++) {
		let [x1, y1] = ps[mod(i-1, n)]
		let [x2, y2] = ps[i]
		s += (x2-x1)*(y2+y1)
	}
	return s < 0
}

function left_bottom_point(ps) {
	return ps.reduce((p0, p1) => {
		let x1 = p1[0]
		let x0 = p0[0]
		if (x1 < x0) return p1
		if (x0 < x1) return p0
		let y1 = p1[1]
		let y0 = p0[1]
		if (y1 > y0) return p1
		return p0
	})
}

// return a number from the range [0..4) which is monotonically increasing
// with the clockwise angle that the input vector makes against the x axis.
function pseudo_angle(dx, dy) {
	let p = dx / (abs(dx) + abs(dy))  // -1..0 (x <= 0) or 0..1 (x >= 0)
	return dy < 0 ? 3 + p : 1 - p     //  2..4 (y <= 0) or 0..2 (y >= 0)
}

// return the angle sweep from angle a1 to a2 in cw (+) or ccw (-) dir.
function angle_sweep(a1, a2, clockwise, circle_sweep) {
	circle_sweep ??= 4
	let d = a2 - a1
	if (d < 0 && clockwise)
		d += circle_sweep
	else if (d > 0 && !clockwise)
		d -= circle_sweep
	return d
}

// return p1 from p.adj where the angle at p on (p0,p,p1) is smallest in cw or ccw direction.
function next_adj(p0, p, clockwise, max_a) {
	max_a ??= inf
	if (p.adj.length == 1) // end-point, go back (or forward if first)
		return 2 <= max_a ? p.adj[0] : null
	let x0 = p0 ? p0[0] - p[0] : 0
	let y0 = p0 ? p0[1] - p[1] : 1
	let a0 = pseudo_angle(x0, y0)
	let min_a = inf // min angle
	let min_p // point with min angle to (p0,p)
	for (let p1 of p.adj) {
		if (p1 == p0)
			continue
		let x1 = p1[0] - p[0]
		let y1 = p1[1] - p[1]
		let a1 = pseudo_angle(x1, y1)
		let a = abs(angle_sweep(a1, a0, clockwise))
		if (a < min_a && a <= max_a) {
			min_a = a
			min_p = p1
		}
	}
	return min_p
}

function closed_walk(first, outer_edge) {
	let walk = []
	let curr = first
	let prev
	do {
		walk.push(curr)
		let next = next_adj(prev, curr, !prev || outer_edge)
		prev = curr
		curr = next
	} while (curr != first) // TODO: fix |_ bug
	return walk
}

function extract_cycles_for(comp) {
	let ps = [...comp]
	while (ps.length > 0) {
		let p = left_bottom_point(ps)
		let c = closed_walk(p)
		if (c[1] != c[c.length-1]) { // not started with a filament
			c.i = cycles.length
			c.comp = comp
			c.area = abs(polygon_area(c))
			cycles.push(c)
		}
		// the first edge is always safe to remove because starting from the leftmost
		// point means that there cannot be a cycle to the right of that first edge
		// so that edge is part of at most one cycle: our cycle.
		rem_edge(c[0], c[1], ps)
		// the removed edge's end-points are now possibly end-points of filaments
		// that we must remove too.
		rem_filament(c[0], ps)
		rem_filament(c[1], ps)
	}
}

function extract_outer_edge_for(comp) {
	let p = left_bottom_point(comp)
	let c = closed_walk(p, true)
	c.i = cycles.length
	c.outer = true
	c.comp = comp
	c.area = abs(polygon_area(c))
	cycles.push(c)
	comp.outer_edge = c
}

function extract_cycles() {
	cycles.length = 0

	for (let comp of comps)
		extract_cycles_for(comp)
	rebuild_adj_refs()

	for (let comp of comps)
		extract_outer_edge_for(comp)
	rebuild_adj_refs()

	for (let c of cycles)
		log('cycle {0} {2} {3} {4}: {1}', c.i, c.map(p=>p.i).join(' '),
			is_cw(c) ? 'cw' : 'ccw',
			c.outer ? 'outer' : '',
			c.inside ? 'inside' : '',
		)
}

// polygon centroid algorithm ------------------------------------------------

function poly_center(ps) {
	let [x0, y0] = ps[0]
	let twicearea = 0
	let x = 0
	let y = 0
	for (let i = 0, n = ps.length, j = n-1; i < n; j = i++) {
		let [x1, y1] = ps[i]
		let [x2, y2] = ps[j]
		let f = (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0)
		twicearea += f
		x += (x1 + x2 - 2 * x0) * f
		y += (y1 + y2 - 2 * y0) * f
	}
	let f = twicearea * 3
	return [
		x / f + x0,
		y / f + y0
	]
}

// polygon offset algorithm --------------------------------------------------

// hypotenuse function: computes sqrt(a^2 + b^2) without underflow / overflow problems.
function hypot(a, b) {
	if (a == 0 && b == 0) return 0
	a = abs(a)
	b = abs(b)
	let M = max(a, b)
	let m = min(a, b)
	return M * sqrt(1 + (m / M)**2)
}

// distance between two points. avoids underflow and overflow.
function distance(x1, y1, x2, y2) {
	return hypot(x2-x1, y2-y1)
}

// parallel line segment at a distance on the right side of a segment.
// use a negative distance for the left side, or reflect the returned points
// against their respective initial points.
function line_offset(d, x1, y1, x2, y2, out) {
	// normal vector of the same length as original segment.
	let dx = -(y2-y1)
	let dy =   x2-x1
	let k = d / distance(x1, y1, x2, y2) // normal vector scale factor
	// normal vector scaled and translated to (x1,y1) and (x2,y2)
	out[0] = x1 + dx * k
	out[1] = y1 + dy * k
	out[2] = x2 + dx * k
	out[3] = y2 + dy * k
	return out
}

// evaluate a line at time t using linear interpolation.
// the time between 0..1 covers the segment interval.
function line_point(t, x1, y1, x2, y2, out) {
	out[0] = x1 + t * (x2 - x1)
	out[1] = y1 + t * (y2 - y1)
	return out
}

// intersect line segment (x1, y1, x2, y2) with line segment (x3, y3, x4, y4).
// returns the time on the first line where intersection occurs.
// if the intersection occurs outside the segments themselves, then t is
// outside the 0..1 range. if the lines are parallel then t is +/-inf.
// if they are coincidental, t is NaN.
function line_line_intersection(x1, y1, x2, y2, x3, y3, x4, y4) {
	let d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)
	return ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d
}

function next_non_null_point(ps, i, fw) {
	do {
		i += fw
		i = mod(i, ps.length)
	} while (is_null(ps[i]))
	return ps[i]
}

function offset_corner(p0, p1, p2, d, out) {
	let [x1, y1, x2, y2] = line_offset( d, p0[0], p0[1], p1[0], p1[1], out)
	let [x3, y3, x4, y4] = line_offset(-d, p2[0], p2[1], p1[0], p1[1], out)
	let t1 = line_line_intersection(x1, y1, x2, y2, x3, y3, x4, y4)
	if (abs(t1) == inf) { // parallel: make a line cap of 2 points
		out[0] = x2
		out[1] = y2
		out[2] = x4
		out[3] = y4
		return out
	} else if (t1 != t1) { // coincidental: use the offset point on the first line
		out[0] = x2
		out[1] = y2
		out[2] = null
		out[3] = null
		return out
	} else {
		out[2] = null
		out[3] = null
		return line_point(t1, x1, y1, x2, y2, out)
	}
}

function offset_poly(ps, d) {
	let ops = []
	let out = []
	for (let i = 0, n = ps.length; i < n; i++) {
		let p1 = ps[i]
		// skip over null segments that can't project a _|_.
		let i0 = i-1; let p0; do { p0 = ps[mod(i0--, n)] } while (points_equal(p0, p1))
		let i2 = i+1; let p2; do { p2 = ps[mod(i2++, n)] } while (points_equal(p2, p1))
		let [x1, y1, x2, y2] = offset_corner(p0, p1, p2, d, out)
		let op1 = [x1, y1]
		op1.p = p1
		op1.ci = i
		ops.push(op1)
		if (x2 != null) {
			let op2 = [x2, y2]
			op2.p = p1
			op2.ci = i
			ops.push(op2)
		}
	}
	return ops
}

// plan loading & validation -------------------------------------------------

function fix_plan() {
	split_intersecting_segs()
	break_overlapping_segs()
	remove_null_segs()
	deduplicate_points()
	merge_colinear_segs()
	remove_isolated_points()
	rebuild_adj_refs()
	find_comps()
	find_inside_comps()
	extract_cycles()
	create_edges()
}

function create_edges_for(c) {
	c.edges = offset_poly(c, (c.outer ? (c.comp.inside ? 10 : 20) : -10))
}

function create_edges() {
	for (let c of cycles)
		create_edges_for(c)
}

function load_plan() {

	log_push()

	for (let i = 0, n = ps.length; i < n; i++)
		init_point(ps[i], i)

	let seg_i = 0
	for (let seg of segs) {
		seg.i = seg_i++
		for (let k = 0; k < 2; k++) {
			let i = seg[k]
			let p
			if (isarray(i)) // inline point
				p = add_point(...i)
			else
				p = check(ps[i], 'seg {0}/{1} invalid index {2}', seg.i, k, i)
			seg[k] = p
		}
	}
	remove_values(segs, seg => !seg[0] || !seg[1])

	rebuild_seg_refs()
	remove_angled_segs()
	fix_plan()

	log_pop('PLAN LOADED')
}

function pr_plan() {
	pr('ps'    , ps.map(p=>p.i).join(' '))
	pr('segs'  , segs.map(s=>s.i+':'+s[0].i+'-'+s[1].i).join(' '))
	pr('cycles', cycles.map(c=>c.i+':'+c.map(p=>p.i).join(',')).join(' '))
}
G.pr_plan = pr_plan

// UI ------------------------------------------------------------------------

// Find and fix the the cycles that contain the sequence (p0,p1,p2) or (p2,p1,p0).
// If (p0,p1,p2) is found then the cycle is to the left of the sequence if it's an inner cycle.
// If (p2,p1,p0) is found then the cycle is to the right of the sequence if it's an inner cycle.
// It's the opposite if it's an outer cycle.
// The same cycle will contain the sequence twice (once as is once in reverse)
// if the sequence is (part of) a filament.
function fix_cycle(c, i, fw, action, new_p, p0, p1, p2) {
	if (action == 'replace') {
		log('cycle point replaced: {0}/{1}: {2}->{3}', c.i, i, c[i].i, new_p.i)
		c[i] = new_p
	} else if (action == 'insert') {
		i = fw ? i : i+1 // insert point in the cycle array
		log('cycle point inserted: {0}/{1} (before {2}): {3}', c.i, i, c[i] ? c[i].i : 'end', new_p.i)
		insert(c, i, new_p)
	}
}
function fix_cycles_containing(p0, p1, p2, action, new_p) {
	log_push()
	for (let c of cycles) {
		let i0 = 0
		while (1) {
			let i = c.indexOf(p1, i0)
			if (i == -1)
				break
			let fp0 = c[mod(i-1, c.length)]
			let fp2 = c[mod(i+1, c.length)]
			if (fp0 == p0 && fp2 == p2) fix_cycle(c, i, 1, action, new_p, p0, p1, p2)
			if (fp0 == p2 && fp2 == p0) fix_cycle(c, i, 0, action, new_p, p2, p1, p0)
			i0 = i+1
		}
	}
	log_pop('all cycles containing ({0},{1},{2}): {3} with {4}', p0.i, p1.i, p2.i, action, new_p.i)
}

// colinear segs directly end-to-end tied to the segment we want to move
// must be separated by addidng a _|_ seg in between so they're not dragged along.
// NOTE: do not deduplicate points after this!
function detach_seg_at(seg, i, p00) {
	log_push()
	let p  = seg[i]
	let p0 = seg[1-i]
	let new_p = add_point(p[0], p[1])

	// each side of (p0,p) needs a different kind of fixing depending on
	// whether there's a _|_ seg at the separation point on that side or not.
	if (p.adj.length > 2) {
		for (let cw = 0; cw <= 1; cw++) {
			let p1 = next_adj(p0, p, cw, 1)
			fix_cycles_containing(p0, p, p1 ?? p00, p1 ? 'replace' : 'insert', new_p)
		}
	} else { // no _|_ segs on the sides.
		fix_cycles_containing(p0, p, p00, 'insert', new_p)
	}

	set_seg_point(seg, i, new_p, 1)
	let new_seg = add_seg(p, new_p)
	log_pop('seg detached: {0}', seg.i)
}
function opposite_seg(seg, i) {
	let v = is_v(seg)
	let p = seg[i]
	for (let seg1 of p.segs) { // each segment connected to that end-point
		if (seg1 == seg) // itself
			continue
		if (is_v(seg1) != v) // not colinear
			continue
		if (is_null(seg1)) // just added
			continue
		return seg1
	}
}
function detach_opposite_seg(seg, i) {
	let seg1 = opposite_seg(seg, i)
	if (!seg1) return
	let p = seg[i]
	if (seg1[0] == p) detach_seg_at(seg1, 0, seg[1-i])
	if (seg1[1] == p) detach_seg_at(seg1, 1, seg[1-i])
}
function detach_colinear_segs(seg) {
	detach_opposite_seg(seg, 0)
	detach_opposite_seg(seg, 1)
}

function segs_overlap(am1, am2, bm1, bm2) { // check if two segments overlap
	return !(am2 <= bm1 || bm2 <= am1)
}

function bump_limit(seg, sign) {
	let v = is_v(seg)
	let a = seg_axis(seg)
	let min_a1 = sign * 1/0
	let s_m1 = seg_m1(seg)
	let s_m2 = seg_m2(seg)
	for (let seg1 of segs) {
		let s1_m1 = seg_m1(seg1)
		let s1_m2 = seg_m2(seg1)
		let a1 = seg_axis(seg1)
		if (is_v(seg1) != v) {
			let closest_m = sign < 0 ? max(s1_m1, s1_m2) : min(s1_m1, s1_m2)
			s1_m1 = a1
			s1_m2 = a1
			a1 = closest_m
 		}
		if (sign * a1 > sign * a && sign * a1 < sign * min_a1) {
			if (segs_overlap(s_m1, s_m2, s1_m1, s1_m2)) {
				min_a1 = a1
			}
		}
	}
	return min_a1
}
function seg_move_ranges(seg) {
	let min_a = bump_limit(seg, -1)
	let max_a = bump_limit(seg,  1)
	let bump_range = [min_a, max_a]
	let ranges = [bump_range]
	return ranges
}
function seg_move_snap_lines(seg) {
	let v = is_v(seg)
	let as = []
	for (let seg1 of segs) {
		if (is_v(seg1) == v) {
			let a = seg_axis(seg1)
			as.push(a)
		} else {
			//
		}
	}
	return as
}
function closest_move_range(a, ranges) {
	let min_range
	let min_d = 1/0
	for (let range of ranges) {
		let [a1, a2] = range
		if (a >= a1 && a <= a2) { // in range
			min_range = range
			break
		}
		let d = min(abs(a1 - a), abs(a2 - a)) // distance to range's closest end-point
		if (d < min_d) {
			min_range = range
			min_d = d
		}
	}
	return min_range
}
function snap_to_line(a, as) {
	for (let a1 of as)
		if (abs(a - a1) <= 5)
			return a1
}

function move_seg_start(seg) {
	log_push()
	detach_colinear_segs(seg)
	log_pop('START MOVE SEG: {0}', seg.i)
}

function move_seg(seg, seg0, ranges, snap_lines, dx, dy) {
	let a = seg_axis(seg0) + (is_v(seg) ? dx : dy)
	let snap_range = closest_move_range(a, ranges)
	let [min_a, max_a] = snap_range
	a = clamp(a, min_a, max_a)
	let sa = snap_to_line(a, snap_lines)
	if (sa != null)
		a = sa
	set_seg_axis(seg, a)
	create_edges()
	return sa
}

function move_seg_stop(seg) {
	log_push()
	fix_plan()
	log_pop('STOP MOVE SEG: {0}', seg.i)
}

// NOTE: do `ps.push(ps[0], ps[1])` before you call this!
function polygon_area(ps) {
	let area = 0
	for (let i = 1, n = ps.length; i <= n; i++)
		area += ps[mod(i, n)][0] * (ps[mod(i+1, n)][1] - ps[i-1][1])
	return area / 2
}

function seg_center(seg) {
	let [p1, p2] = seg
	let [x1, y1] = p1
	let [x2, y2] = p2
	return [
		(x2 + x1) / 2,
		(y2 + y1) / 2,
	]
}

// test UI -------------------------------------------------------------------

ui.widget('house_plan', {

	create: function(cmd, id) {

		let [dstate, dx, dy] = ui.drag(id)

		if (dstate == 'drag') {
			let hs = ui.hover(id)
			if (hs) {
				let seg = hs.get('seg')
				if (seg) {
					let cs = ui.captured(id)
					move_seg_start(seg)
					pr_log()
					cs.set('seg', seg)
					cs.set('seg0', clone(seg))
					cs.set('ranges', seg_move_ranges(seg))
					cs.set('snap_lines', seg_move_snap_lines(seg))
				}
			}
		}

		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {
			let cs = ui.captured(id)
			if (cs) {
				let seg        = cs.get('seg')
				let seg0       = cs.get('seg0')
				let ranges     = cs.get('ranges')
				let snap_lines = cs.get('snap_lines')
				let snap_line = move_seg(seg, seg0, ranges, snap_lines, dx, dy)
				cs.set('snap_line', snap_line)
			}
		}

		if (dstate == 'drop') {
			let cs = ui.captured(id)
			move_seg_stop(cs.get('seg'))
			pr_log()
		}

		ui.cmd(cmd, id)
	},

	draw: function(a, i) {

		let id = a[i+0]

		let hs = ui.hovers(id)
		let cs = ui.captured(id)

		let cx = ui.cx
		cx.save()
		cx.translate(120, 120)
		cx.translate(.5, .5)

		let sa = cs && cs.get('snap_line')
		if (sa != null) {
			let moving_seg = cs && cs.get('seg')
			let x1, y1, x2, y2
			if (is_v(moving_seg)) {
				x1 = sa
				x2 = sa
				y1 = 0
				y2 = 10000
			} else {
				y1 = sa
				y2 = sa
				x1 = 0
				x2 = 10000
			}
			cx.beginPath()
			cx.moveTo(x1, y1)
			cx.lineTo(x2, y2)
			cx.setLineDash([6, 3])
			cx.strokeStyle = '#555'
			cx.stroke()
			cx.setLineDash([])
		}

		let hit_seg = cs && cs.get('seg') || hs && hs.get('seg')
		for (let seg of segs) {
			let p1 = seg[0]
			let p2 = seg[1]
			cx.beginPath()
			cx.moveTo(...p1)
			cx.lineTo(...p2)
			cx.strokeStyle = hit_seg == seg ? 'white' : 'gray'
			cx.stroke()

			if (DEBUG_PLAN) {
			let [x,y] = seg_center(seg)
			cx.fillStyle = '#f66'
			cx.fillText(seg.i, x-5, y+5)
			}

		}

		for (let c of cycles) {
			cx.beginPath()
			for (let p of c.edges) {
				if (p == c.edges[0])
					cx.moveTo(...p)
				else
					cx.lineTo(...p)
			}
			cx.closePath()
			cx.strokeStyle = '#555'
			cx.stroke()

			if (DEBUG)
			for (let p of c.edges) {
				let [x, y] = p
				cx.fillStyle = '#0f0'
				cx.fillText(c.i+':'+p.ci, x-5, y+5)
			}

			if (DEBUG_PLAN)
			{
			let [x,y] = poly_center(c)
			cx.fillStyle = c.outer ? '#39f' : '#99f'
			cx.fillText(c.i + (c.area ? ' ('+format_kcount(c.area / 1e4)+'m²)' : ''), x, y+5)
			}

		}

		if (DEBUG_PLAN)
		for (let p of ps) {
			let [x, y] = p
			cx.fillStyle = 'white'
			cx.fillText(p.i, x-5, y+5)
		}

		cx.restore()
	},

	hit: function(a, i) {

		let id = a[i+0]

		let cx = ui.cx
		cx.save()
		cx.translate(120, 120)
		ui.update_mouse()

		for (let seg of segs) {
			let p1 = seg[0]
			let p2 = seg[1]
			let x1 = min(p1[0], p2[0])
			let y1 = min(p1[1], p2[1])
			let x2 = max(p1[0], p2[0])
			let y2 = max(p1[1], p2[1])
			if (y1 == y2) {
				y1 -= 5
				y2 += 5
			} else if (x1 == x2) {
				x1 -= 5
				x2 += 5
			} else {
				continue
			}
			if (ui.hit_rect(x1, y1, x2-x1, y2-y1)) {
				let hs = ui.hover(id)
				hs.set('seg', seg)
				break
			}
		}

		cx.restore()
		ui.update_mouse()

	},

})

DEBUG_PLAN = 1
load_plan()
pr_log()

ui.main = function() {

	ui.house_plan('p1')

}

}()) // module function

</script>
</body>
</html>
