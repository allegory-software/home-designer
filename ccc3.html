<!DOCTYPE html>
<html theme=dark>
<body>
<base href="www2/">
<link rel="preload" href="fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="fa-solid-900.woff2"   as="font" type="font/woff2" crossorigin>
<script src=glue.js global extend></script>
<script src=ui.js></script>
<script src=ui_validation.js></script>
<script src=ui_nav.js></script>
<script src=ui_grid.js></script>
<script>

(function () {
"use strict"
const G = window

DEBUG('DEBUG_PLAN')

let clone = structuredClone

let EPSILON = 1e-5

function near(a, b) { return abs(a - b) < EPSILON }

// debugging -----------------------------------------------------------------

let errs = []
let log_stack = []
function log(err, ...args) {
	errs.push(isstr(err) ? subst(err, ...args) : err)
}
function log_push() {
	log_stack.push(errs)
	errs = []
	errs.t0 = clock()
}
function log_pop(err, ...args) {
	let errs1 = errs
	let dt = (clock() - errs1.t0) * 1000
	errs1.dt = dt
	errs = log_stack.pop()
	if (err !== undefined && errs1.length) {
		log(err, ...args)
		log(errs1)
		if (dt > 3)
			log('{0} TIME {1} ms', ('*').repeat(dt), dec(dt))
	} else {
		return errs1
	}
}
function check(v, ...args) {
	if (!v) log(...args)
	return v
}
function pr_errs(es, level) {
	let indent = ('  ').repeat(level)
	for (let s of es)
		if (isarray(s))
			pr_errs(s, level+1)
		else
			pr(indent + s)
}
function pr_log() {
	assert(!log_stack.length)
	pr_errs(errs, 0)
	errs.length = 0
}

let next_id = {}
function gen_id(k) {
	if (!next_id[k])
		next_id[k] = 1
	else
		next_id[k]++
	return next_id[k]
}

// bbox ----------------------------------------------------------------------

function bbox() {
	return [inf, inf, -inf, -inf] // x1, y1, x2, y2
}

function bbox_add_bbox(bb, x1, y1, x2, y2) {
	bb[0] = min(bb[0], x1, x2)
	bb[1] = min(bb[1], y1, y2)
	bb[2] = max(bb[2], x1, x2)
	bb[3] = max(bb[3], y1, y2)
}

function bbox_add_point(bb, x, y) {
	bb[0] = min(bb[0], x)
	bb[1] = min(bb[1], y)
	bb[2] = max(bb[2], x)
	bb[3] = max(bb[3], y)
}

// polygon offset algorithm --------------------------------------------------

// hypotenuse function: computes sqrt(a^2 + b^2) without underflow / overflow problems.
function hypot(a, b) {
	if (a == 0 && b == 0) return 0
	a = abs(a)
	b = abs(b)
	let M = max(a, b)
	let m = min(a, b)
	return M * sqrt(1 + (m / M)**2)
}

// distance between two points. avoids underflow and overflow.
function distance(x1, y1, x2, y2) {
	return hypot(x2-x1, y2-y1)
}

// parallel line segment at a distance on the right side of a segment.
// use a negative distance for the left side, or reflect the returned points
// against their respective initial points.
function line_offset(d, x1, y1, x2, y2, out) {
	// normal vector of the same length as original segment.
	let dx = -(y2-y1)
	let dy =   x2-x1
	let k = d / distance(x1, y1, x2, y2) // normal vector scale factor
	// normal vector scaled and translated to (x1,y1) and (x2,y2)
	out[0] = x1 + dx * k
	out[1] = y1 + dy * k
	out[2] = x2 + dx * k
	out[3] = y2 + dy * k
	return out
}

// evaluate a line at time t using linear interpolation.
// the time between 0..1 covers the segment interval.
function line_point(t, x1, y1, x2, y2, out) {
	out[0] = x1 + t * (x2 - x1)
	out[1] = y1 + t * (y2 - y1)
	return out
}

// intersect line segment (x1, y1, x2, y2) with line segment (x3, y3, x4, y4).
// returns the time on the first line where intersection occurs.
// if the intersection occurs outside the segments themselves, then t is
// outside the 0..1 range. if the lines are parallel then t is +/-inf.
// if they are coincidental, t is NaN.
function line_line_intersection(x1, y1, x2, y2, x3, y3, x4, y4) {
	let d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)
	return ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d
}

function offset_corner(p0, p1, p2, d, out) {
	let [x1, y1, x2, y2] = line_offset( d, p0[0], p0[1], p1[0], p1[1], out)
	let [x3, y3, x4, y4] = line_offset(-d, p2[0], p2[1], p1[0], p1[1], out)
	let t1 = line_line_intersection(x1, y1, x2, y2, x3, y3, x4, y4)
	if (abs(t1) == inf) { // parallel: make a line cap of 2 points, 1*d thick
		let dx = x2 == x4 ? d * sign(x1 - x2) : 0
		let dy = y2 == y4 ? d * sign(y1 - y2) : 0
		out[0] = x2 + dx
		out[1] = y2 + dy
		out[2] = x4 + dx
		out[3] = y4 + dy
		return out
	} else if (t1 != t1) { // coincidental: use the offset point on the first line
		out[0] = x2
		out[1] = y2
		out[2] = null
		out[3] = null
		return out
	} else {
		out[2] = null
		out[3] = null
		return line_point(t1, x1, y1, x2, y2, out)
	}
}

function offset_poly(ps, d) {
	let ops = []
	let out = []
	if (ps.length == 2 && points_equal(ps[0], ps[1])) { // single null seg: make a square
		let i = 0
		for (let op of [[-d, -d], [d, -d], [d, d], [-d, d]]) {
			op.p = ps[0]
			op.ci = i++
			ops.push(op)
		}
	} else {
		for (let i = 0, n = ps.length; i < n; i++) {
			let p1 = ps[i]
			// skip over null segments that can't project a _|_.
			let i0 = i-1; let p0; do { p0 = ps[mod(i0--, n)] } while (points_equal(p0, p1))
			let i2 = i+1; let p2; do { p2 = ps[mod(i2++, n)] } while (points_equal(p2, p1))
			let [x1, y1, x2, y2] = offset_corner(p0, p1, p2, d, out)
			let [x0, y0] = p1
			let op1 = [x1 - x0, y1 - y0]
			op1.p = p1
			op1.ci = i
			ops.push(op1)
			if (x2 != null) {
				let op2 = [x2 - x0, y2 - y0]
				op2.p = p1
				op2.ci = i
				ops.push(op2)
			}
		}
	}
	return ops
}

/* ---------------------------------------------------------------------------
	Algorithm for extracting all base cycles from an unidirected planar graph.
	- input: no null segs, no isolated points, no overlapping or intersecting segs allowed.
	- points can be: end-points (#adj=1), joints (#adj=2) or branch points (#adj > 2).
	- output: cycles and filaments.
	Paper : https://www.geometrictools.com/Documentation/MinimalCycleBasis.pdf
	Code  : https://github.com/vbichkovsky/min-cycles/blob/master/src/cycles.js
*/

function rebuild_adj_refs(ps) {
	for (let p of ps)
		p.adj.length = 0
	for (let p of ps)
		for (let seg of p.segs)
			p.adj.push(adj_point(seg, p))
}

function rem_edge(p1, p2, ps) {
	remove_value(p1.adj, p2)
	remove_value(p2.adj, p1)
	if (p1.adj == 0) remove_value(ps, p1)
	if (p2.adj == 0) remove_value(ps, p2)
}

function rem_filament(p, ps) {
	while (p && p.adj.length < 2) {
		remove_value(ps, p)
		let pa = p.adj[0]
		if (pa)
			rem_edge(p, pa, ps)
		p = pa
	}
}

function is_cw(ps) {
	let s = 0
	for (let i = 0, n = ps.length; i < n; i++) {
		let [x1, y1] = ps[mod(i-1, n)]
		let [x2, y2] = ps[i]
		s += (x2-x1)*(y2+y1)
	}
	return s < 0
}

function left_bottom_point(ps) {
	return ps.reduce((p0, p1) => {
		let x1 = p1[0]
		let x0 = p0[0]
		if (x1 < x0) return p1
		if (x0 < x1) return p0
		let y1 = p1[1]
		let y0 = p0[1]
		if (y1 > y0) return p1
		return p0
	})
}

// return a number from the range [0..4) which is monotonically increasing
// with the clockwise angle that the input vector makes against the x axis.
function pseudo_angle(dx, dy) {
	let p = dx / (abs(dx) + abs(dy))  // -1..0 (x <= 0) or 0..1 (x >= 0)
	return dy < 0 ? 3 + p : 1 - p     //  2..4 (y <= 0) or 0..2 (y >= 0)
}

// return the angle sweep from angle a1 to a2 in cw (+) or ccw (-) dir.
function angle_sweep(a1, a2, clockwise, circle_sweep) {
	circle_sweep ??= 4
	let d = a2 - a1
	if (d < 0 && clockwise)
		d += circle_sweep
	else if (d > 0 && !clockwise)
		d -= circle_sweep
	return d
}

// return p1 from p.adj where the angle at p on (p0,p,p1) is smallest in cw or ccw direction.
function next_adj(p0, p, clockwise, max_a) {
	max_a ??= inf
	if (p.adj.length == 1 && max_a >= 2) // end-point, go back (or forward if first)
		return p.adj[0]
	let x0 = p0 ? p0[0] - p[0] : 0
	let y0 = p0 ? p0[1] - p[1] : 1
	let a0 = pseudo_angle(x0, y0)
	let min_a = inf // min angle
	let min_p // point with min angle to (p0,p)
	for (let p1 of p.adj) {
		if (p1 == p0)
			continue
		let x1 = p1[0] - p[0]
		let y1 = p1[1] - p[1]
		let a1 = pseudo_angle(x1, y1)
		let a = abs(angle_sweep(a1, a0, clockwise))
		if (a < min_a && a <= max_a) {
			min_a = a
			min_p = p1
		}
	}
	return min_p
}

function closed_walk(first, outer_cycle) {
	let walk = []
	let curr = first
	let prev
	do {
		walk.push(curr)
		let next = next_adj(prev, curr, !prev || outer_cycle)
		prev = curr
		curr = next
	} while (curr != first) // TODO: fix |_ bug
	return walk
}

// NOTE: do `ps.push(ps[0], ps[1])` before you call this!
function polygon_area(ps) {
	let area = 0
	for (let i = 1, n = ps.length; i <= n; i++)
		area += ps[mod(i, n)][0] * (ps[mod(i+1, n)][1] - ps[i-1][1])
	return area / 2
}

function extract_cycles_for(comp) {
	let ps = [...comp.ps]
	while (ps.length > 0) {
		let p = left_bottom_point(ps)
		let c = closed_walk(p)
		if (c[1] != c[c.length-1]) { // not started with a filament
			c.i = gen_id('cycle')
			c.comp = comp
			c.area = abs(polygon_area(c))
			comp.cycles.push(c)
		}
		// the first edge is always safe to remove because starting from the leftmost
		// point means that there cannot be a cycle to the right of that first edge
		// so that edge is part of at most one cycle: our cycle.
		rem_edge(c[0], c[1], ps)
		// the removed edge's end-points are now possibly end-points of filaments
		// that we must remove too.
		rem_filament(c[0], ps)
		rem_filament(c[1], ps)
	}
}

function extract_outer_cycle_for(comp) {
	let p = left_bottom_point(comp.ps)
	let c = closed_walk(p, true)
	c.i = gen_id('cycle')
	c.outer = true
	c.comp = comp
	c.area = abs(polygon_area(c))
	c.reverse()
	comp.cycles.push(c)
	comp.outer_cycle = c
}

// house plan model ----------------------------------------------------------

function is_h(seg) { return seg[0][1] == seg[1][1] }
function is_v(seg) { return seg[0][0] == seg[1][0] }
function is_null(seg) { return is_h(seg) && is_v(seg) }
function seg_dir(seg) { return is_h(seg) ? '-' : is_v(seg) ? '|' : '/' }

function seg_x1(seg) { return min(seg[0][0], seg[1][0]) }
function seg_y1(seg) { return min(seg[0][1], seg[1][1]) }
function seg_x2(seg) { return max(seg[0][0], seg[1][0]) }
function seg_y2(seg) { return max(seg[0][1], seg[1][1]) }

function set_seg_x1(seg, x) { let x1i = seg[0][0] < seg[1][0] ? 0 : 1; seg[x1i][0] = x }
function set_seg_y1(seg, y) { let y1i = seg[0][1] < seg[1][1] ? 0 : 1; seg[y1i][1] = y }
function set_seg_x2(seg, x) { let x2i = seg[0][0] < seg[1][0] ? 1 : 0; seg[x2i][0] = x }
function set_seg_y2(seg, y) { let y2i = seg[0][1] < seg[1][1] ? 1 : 0; seg[y2i][1] = y }

function seg_axis(seg) { return is_v(seg) ? seg_x1(seg) : seg_y1(seg) }
function seg_m1  (seg) { return is_v(seg) ? seg_y1(seg) : seg_x1(seg) }
function seg_m2  (seg) { return is_v(seg) ? seg_y2(seg) : seg_x2(seg) }

function set_seg_m1  (seg, m) { if (is_v(seg)) set_seg_y1(seg, m); else set_seg_x1(seg, m) }
function set_seg_m2  (seg, m) { if (is_v(seg)) set_seg_y2(seg, m); else set_seg_x2(seg, m) }
function set_seg_axis(seg, a) {
	if (is_v(seg)) {
		seg[0][0] = a
		seg[1][0] = a
	} else {
		seg[0][1] = a
		seg[1][1] = a
	}
}

function points_equal(p1, p2) { return p1[0] == p2[0] && p1[1] == p2[1] }

function adj_point_index(seg, p) {
	return seg[0] == p ? 1 : seg[1] == p ? 0 : null
}
function adj_point(seg, p) {
	return assert(seg[adj_point_index(seg, p)])
}

function seg_p1(seg) { let mi = is_v(seg) ? 1 : 0; return seg[seg[0][mi] < seg[1][mi] ? 0 : 1] }
function seg_p2(seg) { let mi = is_v(seg) ? 1 : 0; return seg[seg[0][mi] < seg[1][mi] ? 1 : 0] }

function normalize_seg(seg) {
	let M = is_v(seg) ? 1 : 0
	let p1 = seg[0]
	let p2 = seg[1]
	if (p1[M] > p2[M]) {
		seg[0] = p2
		seg[1] = p1
	}
}

function seg_center(seg) {
	let [p1, p2] = seg
	let [x1, y1] = p1
	let [x2, y2] = p2
	return [
		(x2 + x1) / 2,
		(y2 + y1) / 2,
	]
}

function poly_center(ps) {
	let [x0, y0] = ps[0]
	let twicearea = 0
	let x = 0
	let y = 0
	for (let i = 0, n = ps.length, j = n-1; i < n; j = i++) {
		let [x1, y1] = ps[i]
		let [x2, y2] = ps[j]
		let f = (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0)
		twicearea += f
		x += (x1 + x2 - 2 * x0) * f
		y += (y1 + y2 - 2 * y0) * f
	}
	let f = twicearea * 3
	return [
		x / f + x0,
		y / f + y0
	]
}

function house_plan(t) {

	let levels = t.levels

	let house_plan = {levels: levels}

	function level_plan(level) {

		if (level.level_plan)
			return level.level_plan

		let ps = level.ps; if (!ps) { ps = []; level.ps = ps; }
		let segs = level.segs
		let comps = []

		let level_plan = {ps: ps, segs: segs, comps: comps, hose_plan: house_plan}
		level.level_plan = level_plan

		// model editing -------------------------------------------------------

		function init_point(p, i) {
			p.segs = []
			p.adj = []
			p.i = i
		}

		function add_point(x, y) {
			let p = [x, y]
			init_point(p, ps.length)
			ps.push(p)
			log('point added: {0}', p.i)
			return p
		}
		level_plan.add_point = add_point

		function rem_point(p) {
			remove_value(ps, p)
			log('point removed: {0}', p.i)
		}

		function rem_points(cond, msg) {
			let a = []
			remove_values(ps, function(p) {
				if (!cond(p)) return
				a.push(p.i)
				return true
			})
			if (a.length)
				log('{0} removed: {1}', msg ?? 'points', a.join(' '))
		}

		function add_seg_ref(p, seg) {
			p.segs.push(seg)
		}

		function rem_seg_ref(p, seg) {
			remove_value(p.segs, seg)
		}

		function add_seg_refs(seg) {
			add_seg_ref(seg[0], seg)
			add_seg_ref(seg[1], seg)
		}

		function rem_seg_refs(seg) {
			rem_seg_ref(seg[0], seg)
			rem_seg_ref(seg[1], seg)
		}

		function add_seg(p1, p2) {
			let seg = [p1, p2]
			seg.i = segs.length
			normalize_seg(seg)
			segs.push(seg)
			add_seg_refs(seg)
			log('seg added: {0}: {1} {2}', seg.i, seg[0].i, seg[1].i)
			return seg
		}
		level_plan.add_seg = add_seg

		function rem_seg(seg) {
			rem_seg_refs(seg)
			remove_value(segs, seg)
			log('seg removed: {0}', seg.i)
		}

		function rem_segs(cond, msg) {
			let a = []
			remove_values(segs, function(seg) {
				if (!cond(seg)) return
				rem_seg_refs(seg)
				a.push(seg.i)
				return true
			})
			if (log && a.length)
				log('{0} removed: {1}', msg ?? 'segs', a.join(','))
		}

		function rem_marked_segs(msg) {
			rem_segs(seg => seg.removed, msg)
		}

		function set_seg_point(seg, i, p) {
			let old_p = seg[i]
			rem_seg_ref(old_p, seg)
			seg[i] = p
			add_seg_ref(p, seg)
			log('seg end moved: {0}/{1}: {2}->{3}', seg.i, i, old_p.i, p.i)
			return old_p
		}

		// model fixing --------------------------------------------------------

		function rebuild_seg_refs() {
			for (let p of ps)
				p.segs.length = 0
			for (let seg of segs)
				add_seg_refs(seg)
		}

		function remove_isolated_points() {
			rem_points(p => p.segs.length == 0, 'isolated points')
		}

		function remove_null_segs() {
			rem_segs(is_null, 'null segs')
		}

		function remove_angled_segs() {
			rem_segs(seg => seg_dir(seg) == '/', 'angled segs')
		}

		// NOTE: assumes segs are sorted, null segs removed, points deduplicated
		function merge_colinear_segs() {
			for (let p of ps) {
				if (p.segs.length == 2) {
					let s1 = p.segs[0]
					let s2 = p.segs[1]
					if (is_v(s1) && is_v(s2) || is_h(s1) && is_h(s2)) { // colinear
						let p1i = adj_point_index(s2, p)
						let p2  = adj_point(s2, p)
						log_push()
						set_seg_point(s1, p1i, p2)
						rem_seg(s2)
						log_pop('segs merged: {0} + {1} => {0}', s1.i, s2.i, s1.i)
					}
				}
			}
		}

		// shortens seg at m with new point and adds new seg without detaching the original seg's end-points.
		function split_seg_at(seg, m) {
			log_push()
			normalize_seg(seg)
			let m1 = seg_m1(seg)
			let m2 = seg_m2(seg)
			let x = is_v(seg) ? seg_x1(seg) : m
			let y = is_v(seg) ? m : seg_y1(seg)
			let new_p = add_point(x, y)
			let old_p = set_seg_point(seg, 1, new_p)
			let new_seg = add_seg(new_p, old_p)
			log_pop('seg split: {0} {4}>{1}<{5} => {2} {3}', seg.i, m, seg.i, new_seg.i, m1, m2)
		}

		// NOTE: only works for h and v segs.
		function split_intersecting_segs_on(v) {
			log_push()
			for (let seg1 of segs) {
				if (is_v(seg1) == v) {
					for (let seg2 of segs) {
						if (is_v(seg2) != v) {
							let m1  = seg_m1(seg1)
							let m2  = seg_m2(seg1)
							let bm1 = seg_m1(seg2)
							let bm2 = seg_m2(seg2)
							let a   = seg_axis(seg1)
							let ba  = seg_axis(seg2)
							if (bm1 <= a && bm2 >= a && ba > m1 && ba < m2) {
								// splitting adds a seg at the end of segs array which will
								// be also tested in the outer loop and possibly split further.
								// the shortened seg is potentially split multiple times
								// in this inner loop.
								split_seg_at(seg1, ba)
							}
						}
					}
				}
			}
			rem_marked_segs('unsplit segs')
			log_pop('split all intersecting segs')
		}
		function split_intersecting_segs() {
			split_intersecting_segs_on(0)
			split_intersecting_segs_on(1)
		}

		// NOTE: leaves isolated points behind.
		function points_cmp(p1, p2) {
			if (p1[0] < p2[0]) return -1
			if (p1[0] > p2[0]) return  1
			if (p1[1] < p2[1]) return -1
			if (p1[1] > p2[1]) return  1
			if (p1.i < p2.i) return -1
			if (p1.i > p2.i) return  1
			return 0
		}
		function deduplicate_points() {
			log_push()
			ps.sort(points_cmp)
			let p0
			for (let i = 0; i < ps.length; i++) {
				let p = ps[i]
				if (p0 && points_equal(p, p0)) {
					for (let j = 0; j < p.segs.length; j++) { // each connected seg
						let seg = p.segs[j]
						for (let i = 0; i < 2; i++) // each seg end
							if (seg[i] == p) {
								set_seg_point(seg, i, p0, 'seg end point dedup')
								j-- // because seg was just removed from p.segs
							}
					}
					continue
				}
				p0 = p
			}
			log_pop('deduplicate all points')
		}

		// NOTE: requires no intersecting segments.
		function break_overlapping_segs() {
			log_push()
			segs.sort(function(s1, s2) {
				let v1 = is_v(s1)
				let v2 = is_v(s2)
				// level 1 grouping by direction
				if (v1 < v2) return -1
				if (v1 > v2) return  1
				let m1 = seg_axis(s1)
				let m2 = seg_axis(s2)
				// level 2 grouping by axis
				if (m1 < m2) return -1
				if (m1 > m2) return  1
				// level 3 grouping by starting point because most segments are
				// non-overlapping and we sant to skip those quickly.
				let i = v1 ? 1 : 0
				let c1 = min(s1[0][i], s1[1][i])
				let c2 = min(s2[0][i], s2[1][i])
				if (c1 < c2) return -1
				if (c1 > c2) return  1
				return 0
			})
			let i0, v0, m0
			for (let i = 0, n = segs.length; i <= n; i++) {
				let seg = segs[i]
				let v = seg ? is_v(seg) : null
				let m = seg ? seg_axis(seg) : null
				if (v0 == null) {
					i0 = i
					v0 = v
					m0 = m
				} else if (v != v0 || m != m0) {
					if (i >= i0 + 2) { // there's at least 2 segments on this axis
						for (let j = i0+1; j < i; j++) {
							let seg1 = segs[j]
							let seg0 = segs[j-1]
							let m1_1 = seg_m1(seg1)
							let m2_0 = seg_m2(seg0)
							if (m1_1 < m2_0) {
								// seg points that are overlapping segs have no _|_ joints
								// or they wouldn't be overlapping the seg, so it's safe
								// to remove the overlapping seg as long as we elongate
								// the overlapped seg.
								log('segs overlap: {0} {1}: {2}<={3}: seg {1} removed, seg {0}.m2 set to {4}',
									seg0.i, seg1.i, m1_1, m2_0, seg_m2(seg1))
								seg1.removed = true
								set_seg_m2(seg0, max(seg_m2(seg1), seg_m2(seg0)))
							}
						}
					}
					i0 = i
					v0 = v
					m0 = m
				}
			}
			rem_marked_segs()
			log_pop('breaking overlapping colinear segs')
		}

		// finding graph components --------------------------------------------

		function add_comp() {
			let comp = {}
			comp.i = comps.length
			comp.ps = []
			comp.cycles = []
			comp.segs = []
			comps.push(comp)
			return comp
		}

		// NOTE: needs adj refs
		function find_comps() {

			for (let p of ps)
				p.visited = false

			comps.length = 0

			function dfs(p, ps, segs) {
				p.visited = true
				ps.push(p)
				for (let seg of p.segs)
					segs.add(seg)
				for (p of p.adj)
					if (!p.visited)
						dfs(p, ps, segs)
			}

			for (let p of ps) {
				if (!p.visited) {
					let comp = add_comp()
					let segs = set()
					dfs(p, comp.ps, segs)
					comp.segs = set_toarray(segs)
					log('comp {0}: {1}', comp.i, comp.ps.map(p=>p.i).join(' '))
				}
			}

		}

		// finding which components are inside islands -------------------------

		function segs_bb(comp) {
			let bb = bbox()
			for (let seg of comp.segs) {
				let [x1, y1] = seg[0]
				let [x2, y2] = seg[1]
				bbox_add_bbox(bb, x1, y1, x2, y2)
			}
			return bb
		}

		function skin_bb(comp) {
			let bb = bbox()
			for (let dp of comp.outer_cycle.edges) {
				let [dx, dy] = dp
				let [x, y] = dp.p
				bbox_add_point(bb, x + dx, y + dy)
			}
			return bb
		}

		function plan_bb() {
			let bb = bbox()
			for (let c of comps) {
				bbox_add_bbox(bb, ...c.bb)
			}
			return bb
		}

		function bb_inside(cbb, pbb) {
			let [px1, py1, px2, py2] = pbb
			let [cx1, cy1, cx2, cy2] = cbb
			return cx1 >= px1 && cx2 <= px2 && cy1 >= py1 && cy2 <= py2
		}

		function point_inside(p, ps) {
			let [x, y] = p
			let inside = false
			for (let i = 0, j = ps.length - 1; i < ps.length; j = i++) {
				let xi = ps[i][0]
				let yi = ps[i][1]
				let xj = ps[j][0]
				let yj = ps[j][1]
				let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
				if (intersect)
					inside = !inside
			}
			return inside
		}

		function comp_inside(c, p) {
			if (!bb_inside(c.bb, p.bb))
				return false
			return point_inside(c.ps[0], p.outer_cycle)
		}

		function find_inside_comps() {

			// seg-based bbox: enough for computing inside flag.
			for (let c of comps) {
				c.inside = false
				c.bb = segs_bb(c)
			}
			level_plan.bb = plan_bb()

			for (let c of comps) {
				if (c.inside)
					continue
				for (let p of comps) {
					if (p == c)
						continue
					if (comp_inside(c, p)) {
						c.inside = true
						log('comp {0} is inside', c.i)
					}
				}
			}
		}

		// plan loading & validation -------------------------------------------

		function extract_cycles() {

			for (let c of comps)
				extract_outer_cycle_for(c)
			rebuild_adj_refs(ps)

			for (let c of comps)
				extract_cycles_for(c)
			rebuild_adj_refs(ps)

			if (0)
			for (let co of comps)
				for (let c of comp.cycles)
					log('cycle {0}/{1} {2} {3} {4}: {5}', co.i, c.i,
						is_cw(c) ? 'cw' : 'ccw',
						c.outer ? 'outer' : '',
						c.inside ? 'inside' : '',
						c.map(p=>p.i).join(' ')
					)
		}

		function create_edges_for(c) {
			c.edges = offset_poly(c, (c.outer ? (c.comp.inside ? -4 : -12) : -4))
		}
		function create_edges() {
			for (let comp of comps) {
				for (let c of comp.cycles) {
					create_edges_for(c)
					create_edges_for(comp.outer_cycle)
				}
			}

			// recompunte bbox now that we have the skin.
			for (let c of comps)
				c.bb = skin_bb(c)
			level_plan.bb = plan_bb()
		}

		level_plan.snap_lines = []

		function fix_level() {
			split_intersecting_segs()
			break_overlapping_segs()
			remove_null_segs()
			deduplicate_points()
			merge_colinear_segs()
			remove_isolated_points()
			rebuild_adj_refs(ps)
			find_comps()
			extract_cycles()
			find_inside_comps()
			create_edges()
			level_plan.snap_lines[0] = snap_lines_for(1)
			level_plan.snap_lines[1] = snap_lines_for(0)
		}

		// plan view UI ops ----------------------------------------------------

		// Find and fix the the cycles that contain the sequence (p0,p1,p2) or (p2,p1,p0).
		// If (p0,p1,p2) is found then the cycle is to the left of the sequence if it's an inner cycle.
		// If (p2,p1,p0) is found then the cycle is to the right of the sequence if it's an inner cycle.
		// It's the opposite if it's an outer cycle.
		// The same cycle will contain the sequence twice (once as is once in reverse)
		// if the sequence is (part of) a filament.
		function fix_cycle(c, i, fw, action, new_p, p0, p1, p2) {
			if (action == 'replace') {
				log('cycle point replaced: {0}/{1}: {2}->{3}', c.i, i, c[i].i, new_p.i)
				c[i] = new_p
			} else if (action == 'insert') {
				i = fw ? i : i+1 // insert point in the cycle array
				log('cycle point inserted: {0}/{1} (before {2}): {3}', c.i, i, c[i] ? c[i].i : 'end', new_p.i)
				insert(c, i, new_p)
			}
		}
		function fix_cycles_containing(p0, p1, p2, action, new_p) {
			log_push()
			for (let comp of comps)
				for (let c of comp.cycles) {
					let i0 = 0
					while (1) {
						let i = c.indexOf(p1, i0)
						if (i == -1)
							break
						let fp0 = c[mod(i-1, c.length)]
						let fp2 = c[mod(i+1, c.length)]
						if (fp0 == p0 && fp2 == p2) fix_cycle(c, i, 1, action, new_p, p0, p1, p2)
						if (fp0 == p2 && fp2 == p0) fix_cycle(c, i, 0, action, new_p, p2, p1, p0)
						i0 = i+1
					}
				}
			log_pop('all cycles containing ({0},{1},{2}): {3} with {4}', p0.i, p1.i, p2.i, action, new_p.i)
		}

		// colinear segs directly end-to-end tied to the segment we want to move
		// must be separated by addidng a _|_ seg in between so they're not dragged along.
		// NOTE: do not deduplicate points after this!
		function detach_seg_at(seg, i, p00) {
			log_push()
			let p  = seg[i]
			let p0 = seg[1-i]
			let new_p = add_point(p[0], p[1])

			// each side of (p0,p) needs a different kind of fixing depending on
			// whether there's a _|_ seg at the separation point on that side or not.
			if (p.adj.length > 2) {
				for (let cw = 0; cw <= 1; cw++) {
					let p1 = next_adj(p0, p, cw, 1)
					fix_cycles_containing(p0, p, p1 ?? p00, p1 ? 'replace' : 'insert', new_p)
				}
			} else { // no _|_ segs on the sides.
				fix_cycles_containing(p0, p, p00, 'insert', new_p)
			}

			set_seg_point(seg, i, new_p, 1)
			let new_seg = add_seg(p, new_p)
			log_pop('seg detached: {0}', seg.i)
		}
		function opposite_seg(seg, i) {
			let v = is_v(seg)
			let p = seg[i]
			for (let seg1 of p.segs) { // each segment connected to that end-point
				if (seg1 == seg) // itself
					continue
				if (is_v(seg1) != v) // not colinear
					continue
				if (is_null(seg1)) // just added
					continue
				return seg1
			}
		}
		function detach_opposite_seg(seg, i) {
			let seg1 = opposite_seg(seg, i)
			if (!seg1) return
			let p = seg[i]
			if (seg1[0] == p) detach_seg_at(seg1, 0, seg[1-i])
			if (seg1[1] == p) detach_seg_at(seg1, 1, seg[1-i])
		}
		function detach_colinear_segs(seg) {
			detach_opposite_seg(seg, 0)
			detach_opposite_seg(seg, 1)
		}

		function segs_overlap(am1, am2, bm1, bm2) { // check if two segments overlap
			return !(am2 <= bm1 || bm2 <= am1)
		}

		function snap_lines_for(v, exclude_seg) {
			let mi = v ? 0 : 1
			let ms = []
			for (let p of ps) {
				if (exclude_seg && (exclude_seg[0] == p || exclude_seg[1] == p))
					continue
				let m = p[mi]
				ms.push(m)
			}
			ms.sort()
			uniq_sorted(ms)

			ms.snap = function(m, snap_d) {
				let min_d = 1/0
				let min_m
				for (let m1 of ms) {
					let d = abs(m - m1)
					if (d <= snap_d && d < min_d) {
						min_d = d
						min_m = m1
					}
				}
				return min_m
			}

			ms.v = v

			return ms
		}

		function snap_point(x, y, snap_d) {
			let sx = level_plan.snap_lines[0].snap(x, snap_d)
			let sy = level_plan.snap_lines[1].snap(y, snap_d)
			return [sx, sy]
		}
		level_plan.snap_point = snap_point

		function seg_move_bump_limit(seg, sign) {
			let v = is_v(seg)
			let a = seg_axis(seg)
			let min_a1 = sign * 1/0
			let s_m1 = seg_m1(seg)
			let s_m2 = seg_m2(seg)
			for (let seg1 of segs) {
				let s1_m1 = seg_m1(seg1)
				let s1_m2 = seg_m2(seg1)
				let a1 = seg_axis(seg1)
				if (is_v(seg1) != v) {
					let closest_m = sign < 0 ? max(s1_m1, s1_m2) : min(s1_m1, s1_m2)
					s1_m1 = a1
					s1_m2 = a1
					a1 = closest_m
				}
				if (sign * a1 > sign * a && sign * a1 < sign * min_a1) {
					if (segs_overlap(s_m1, s_m2, s1_m1, s1_m2)) {
						min_a1 = a1
					}
				}
			}
			return min_a1
		}
		function seg_move_ranges(seg) {
			let min_a = seg_move_bump_limit(seg, -1)
			let max_a = seg_move_bump_limit(seg,  1)
			let ranges = [
				[min_a, max_a],
			]
			return ranges
		}
		function seg_resize_bump_limit(seg, p, sign) {
			let v = is_v(seg)
			let a = p[v ? 1 : 0]
			let m = p[v ? 0 : 1]
			let min_a1 = sign * 1/0
			for (let seg1 of segs) {
				if (is_v(seg1) != v) {
					let a1 = seg_axis(seg1)
					if (sign * a1 > sign * a && sign * a1 < sign * min_a1) {
						let m1 = seg_m1(seg1)
						let m2 = seg_m2(seg1)
						if (m >= m1 && m <= m2)
							min_a1 = a1
					}
				}
			}
			return min_a1
		}
		function seg_resize_ranges(seg, p) {
			let min_a = seg_resize_bump_limit(seg, p, -1)
			let max_a = seg_resize_bump_limit(seg, p,  1)
			let ranges = [
				[min_a, max_a],
			]
			return ranges
		}
		function closest_range(a, ranges) {
			let min_range
			let min_d = 1/0
			for (let range of ranges) {
				let [a1, a2] = range
				if (a >= a1 && a <= a2) { // in range
					min_range = range
					break
				}
				let d = max(0, min(abs(a1 - a), abs(a2 - a))) // distance to range's closest end-point
				if (d < min_d) {
					min_range = range
					min_d = d
				}
			}
			return min_range
		}
		function snap_seg(a, ranges, snap_lines, draw_state) {
			let snap_range = closest_range(a, ranges)
			let [min_a, max_a] = snap_range
			a = clamp(a, min_a, max_a)
			let sa = snap_lines.snap(a, ui.key('shift') ? 2 : 20)
			draw_state.snap_lines.length = 0
			if (sa != null)
				draw_state.snap_lines.push(sa, snap_lines.v)
			return sa
		}

		// find the seg in the left, right, top, bottom side around p.
		function seg_around_point(p, sdx, sdy) {
			let p0 = [p[0] + sdx, p[1] + sdy]
			let p1 = next_adj(p0, p, 1, 0)
			// find the seg of (p, p1)
			for (let seg of p.segs)
				if (seg[0] == p && seg[1] == p1 || seg[1] == p && seg[0] == p1)
					return seg
		}

		function start_move_seg(seg) {

			log_push()

			detach_colinear_segs(seg)

			log_pop('START MOVE SEG: {0}', seg.i)
			pr_log()

			let move_freely = seg[0].segs.length == 1 && seg[1].segs.length == 1
			let seg0 = [[...seg[0]], [...seg[1]]]
			let ranges = seg_move_ranges(seg)
			let snap_lines = snap_lines_for(is_v(seg), move_freely && seg)
			let v = is_v(seg0)
			let m_snap_lines = move_freely && snap_lines_for(!is_v(seg), seg)

			let s = {}

			s.move = function(dx, dy, draw_state) {

				let dm = v ? dy : dx
				let da = v ? dx : dy

				if (move_freely) {

					let a = seg_axis(seg0) + da
					let sa = snap_lines.snap(a) ?? a
					a = sa ?? a

					// snap both end-points on main-axis.
					let m1 = seg_m1(seg0) + dm
					let m2 = seg_m2(seg0) + dm
					let m1s = m_snap_lines.snap(m1)
					let m2s = m_snap_lines.snap(m2)
					if (m1s != null && m2s != null) // both ends snapped
						if (abs(m1s - m1) <= abs(m2s - m2)) // pick the one closer to snap line
							m2s = null
						else
							m1s = null
					if (m1s != null)
						m2s = m1s + (seg_m2(seg0) - seg_m1(seg0))
					else if (m2s != null)
						m1s = m2s - (seg_m2(seg0) - seg_m1(seg0))

					seg[0][0] =  v ? a : m1s ?? m1
					seg[1][0] =  v ? a : m2s ?? m2
					seg[0][1] = !v ? a : m1s ?? m1
					seg[1][1] = !v ? a : m2s ?? m2

					// TODO: we have 2 snap lines damn it
					s.snap_line = sa
					s.snap_line_is_v = v

				} else { // move on cross axis

					let a = seg_axis(seg0) + (v ? dx : dy)
					let sa = snap_seg(a, ranges, snap_lines, draw_state)
					a = sa ?? a
					set_seg_axis(seg, a)
					create_edges()
				}

			}

			s.stop = function(draw_state) {
				log_push()
				fix_level()
				log_pop('STOP MOVE SEG: {0}', seg.i)
				pr_log()
				draw_state.snap_lines.length = 0
			}

			return s
		}
		level_plan.start_move_seg = start_move_seg

		function start_resize_seg(p, mx0, my0, dx, dy, sdx, sdy, draw_state) {

			// based on direction of drag, either detach a seg or add a seg, and start resizing it.
			log_push()

			let seg
			if (p) {
				// find seg in the drag direction around p.
				if (p.segs.length == 1 && is_v(p.segs[0]) == !!sdy) {
					// p is a free end-point and we're dragging along its main axis: resize it.
					seg = p.segs[0]
				} else {
					// find the seg around p in the direction of drag: that's the segment we want to detach and resize.
					seg = seg_around_point(p, sdx, sdy)
					// detach seg at branch point p so we can then resize it by its free end-point.
					//
				}
			}

			if (!seg) { // create new seg, anchored to p or to mouse pos when clicked
				let x, y
				if (p) {
					[x, y] = p
				} else {
					x = mx0
					y = my0
				}
				let p1 = add_point(x, y)
				let p2 = add_point(
					x + dx * abs(sdx),
					y + dy * abs(sdy)
				)
				seg = add_seg(p1, p2)
				p = p2
			}

			let p0 = [...p]

			fix_level()

			log_pop('START RESIZE SEG: {0}', seg.i)
			pr_log()

			let ranges = seg_resize_ranges(seg, p)
			let snap_lines = snap_lines_for(!is_v(seg), seg)

			let s = {seg: seg}

			s.resize = function(dx, dy, draw_state) {
				let x1 = p0[0] + dx * abs(sdx)
				let y1 = p0[1] + dy * abs(sdy)

				let a = sdx ? x1 : y1
				let sa = snap_seg(a, ranges, snap_lines, draw_state)
				if (sa != null)
					a = sa
				if (sdx)
					x1 = a
				else
					y1 = a
				p[0] = x1
				p[1] = y1
				create_edges()
			}

			s.stop = function(draw_state) {
				log_push()
				fix_level()
				log_pop('STOP RESIZE SEG: {0}', seg.i)
				pr_log()
				draw_state.snap_lines.length = 0
			}

			return s
		}
		level_plan.start_resize_seg = start_resize_seg

		// init level ----------------------------------------------------------

		log_push()

		for (let i = 0, n = ps.length; i < n; i++)
			init_point(ps[i], i)

		let seg_i = 0
		for (let seg of segs) {
			seg.i = seg_i++
			for (let k = 0; k < 2; k++) {
				let i = seg[k]
				let p
				if (isarray(i)) // inline point
					p = add_point(...i)
				else
					p = check(ps[i], 'seg {0}/{1} invalid index {2}', seg.i, k, i)
				seg[k] = p
			}
		}
		remove_values(segs, seg => !seg[0] || !seg[1])

		rebuild_seg_refs()
		remove_angled_segs()
		fix_level()

		log_pop('PLAN LOADED')

		pr_log()

		// TODO: remove this
		G.p = level_plan

		return level_plan
	}

	house_plan.level_plan = level_plan

	// face view UI ops ----------------------------------------------------

	function face_bb(plan, vert) { // returns (x1, y1, x2, y2, min_depth, max_depth)
		let [x1, y1, x2, y2] = plan_bb(plan)
		let h = 0
		for (let lv of plan.levels)
			h += lv.h
		if (vert)
			return [y1, 0, y2, h, x1, x2]
		else
			return [x1, 0, x2, h, y1, y2]
	}

	let bb = bbox()
	for (let level of house_plan.levels) {
		let level_plan = house_plan.level_plan(level)
		bbox_add_bbox(bb, ...level_plan.bb)
	}
	house_plan.bb = bb

	return house_plan

}

// shared scale --------------------------------------------------------------

let scale_group = memoize(function(name) {
	let g = {}
	let st = 7 // thickness of wall line stroke at 1:1 scale
	let scale
	g.d = d => round(d * scale)
	g.x = x => round(x * scale)
	g.y = y => round(y * scale)
	g.plan_x = x => x/ scale
	g.plan_y = y => y / scale
	let out = []
	g.scale_to_fit = function(bb, w, h) {
		w -= 2*st
		h -= 2*st
		let [x1, y1, x2, y2] = bb
		let bw = x2 - x1
		let bh = y2 - y1
		scale = min(
			scale,
			w / bw,
			h / bh
		)
		g.scale = scale
		g.line_width = 1 + ((st * scale >> 1) * 2)
		out[0] = -round(x1 * scale) + st
		out[1] = -round(y1 * scale) + st
		return out
	}
	g.reset_scale = function() {
		scale = 1/0
		g.scale = scale
	}
	return g
})

// plan view -----------------------------------------------------------------

let PLAN_VIEW_ID         = ui.S-1
let PLAN_VIEW_DRAW_STATE = ui.S+0

ui.box_widget('plan_view', {

	create: function(cmd, id, plan, fr, align, valign, min_w, min_h) {

		let s = ui.state(id)
		let draw_state = s.get('draw_state')
		if (!draw_state) {
			draw_state = {snap_lines: []}
			s.set('draw_state', draw_state)
		}
		s.set('plan', plan)

		let [dstate, dx, dy] = ui.drag(id)

		let sg = scale_group('editor')

		dx /= sg.scale
		dy /= sg.scale

		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {

			let hs = ui.hover(id)
			let cs = ui.captured(id)

			if (dstate == 'drag') {

				let seg = hs.get('seg')
				let p   = hs.get('p')

				if (seg) { // move seg

					cs.set('action', 'move_seg')
					cs.set('move_seg', plan.start_move_seg(seg))

				}
			}

			let action = cs.get('action')

			if (!action && (abs(dx) >= 10 || abs(dy) >= 10)) { // dragged far enough to assume intent to drag.

				// establish direction of drag on x and y axis.
				let sdx = abs(dx) > 1.5 * abs(dy) ? sign(dx) : 0 // straight enough
				let sdy = abs(dy) > 1.5 * abs(dx) ? sign(dy) : 0 // straight enough
				if (sdx || sdy) {
					action = 'resize_seg'
					cs.set('action', action)
					let p = cs.get('p')
					let mx0 = cs.get('x')
					let my0 = cs.get('y')
					let s = plan.start_resize_seg(p, mx0, my0, dx, dy, sdx, sdy, draw_state)
					cs.set('resize_seg', s)
				}

			}

			if (action == 'move_seg')
				cs.get('move_seg').move(dx, dy, draw_state)

			if (action == 'resize_seg')
				cs.get('resize_seg').resize(dx, dy, draw_state)

			if (dstate == 'drop') {
				if (action == 'move_seg') {
					cs.get('move_seg').stop(draw_state)
				} else if (action == 'resize_seg') {
					cs.get('resize_seg').stop(draw_state)
				}
			}

		}

		return ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
				id, draw_state,
			)
	},

	after_position: function(a, i, axis)	{
		let x00 = a[i+0]
		let y00 = a[i+1]
		let w   = a[i+2]
		let h   = a[i+3]
		let id  = a[i+PLAN_VIEW_ID]
		let draw_state = a[i+PLAN_VIEW_DRAW_STATE]
		let sg = scale_group('editor')
		if (!axis) {
			sg.reset_scale()
		} else {
			let plan = ui.state(id).get('plan')
			let [x0, y0] = sg.scale_to_fit(plan.bb, w, h)
			draw_state.x0 = x0
			draw_state.y0 = y0
			// pick what parts of the plan to send over the network for drawing
			// and in which format (the plan has arrays with props which is not valid json).
			draw_state.comps = plan.comps
			draw_state.segs = plan.segs // TODO: remove this from draw stream
			draw_state.ps = plan.ps // TODO: remove this from draw stream
		}
	},

	draw: function(a, i) {

		let x00   = a[i+0]
		let y00   = a[i+1]
		let w     = a[i+2]
		let h     = a[i+3]
		let id    = a[i+PLAN_VIEW_ID]
		let draw_state = a[i+PLAN_VIEW_DRAW_STATE]

		let hs = ui.hovers(id)
		let cs = ui.captured(id)

		let sg = scale_group('editor')

		let cx = ui.cx
		cx.save()
		cx.translate(x00, y00)
		cx.translate(draw_state.x0, draw_state.y0)
		cx.translate(.5, .5)

		// allowed moving areas
		let ranges = cs?.get('ranges')
		if (ranges) {
			let moving_seg = cs?.get('seg')
			for (let [a1, a2] of ranges) {
				let x1, y1, x2, y2
				if (is_v(moving_seg)) {
					x1 = a1
					x2 = a2
					y1 = 0
					y2 = h
				} else {
					y1 = a1
					y2 = a2
					x1 = 0
					x2 = w
				}
				cx.beginPath()
				if (x2-x1 > 0 && y2-y1 > 0) {
					cx.rect(x1, y1, x2-x1, y2-y1)
				} else {
					cx.moveTo(x1, y1)
					cx.lineTo(x2, y2)
				}
				//cx.setLineDash([6, 3])
				//cx.strokeStyle = '#555'
				cx.fillStyle = '#ffffff03'
				cx.fill()
				//cx.setLineDash([])
			}
		}

		// snap line
		for (let i = 0, sl = draw_state.snap_lines, n = sl.length; i < n; i += 2) {
			let sa   = sl[i]
			let is_v = sl[i+1]
			let x1, y1, x2, y2
			if (is_v) {
				x1 = sg.x(sa)
				x2 = sg.x(sa)
				y1 = 0
				y2 = h
			} else {
				y1 = sg.y(sa)
				y2 = sg.y(sa)
				x1 = 0
				x2 = w
			}
			cx.beginPath()
			cx.moveTo(x1, y1)
			cx.lineTo(x2, y2)
			cx.setLineDash([5, 8])
			cx.strokeStyle = '#555'
			cx.stroke()
			cx.setLineDash([])
		}

		// walls
		for (let comp of draw_state.comps) {

			cx.beginPath()

			for (let c of comp.cycles) {
				if (c.edges) {
					for (let dp of c.edges) {
						let [dx, dy] = dp
						let [x0, y0] = dp.p
						let x = sg.x(x0) + sg.d(dx)
						let y = sg.y(y0) + sg.d(dy)
						if (dp == c.edges[0])
							cx.moveTo(x, y)
						else
							cx.lineTo(x, y)
					}
					cx.closePath()
				}
			}

			if (!cx.wall_pattern) {
				let w = 80
				let c = new OffscreenCanvas(w, w)
				let x = c.getContext('2d')
				let g = x.createLinearGradient(0, 0, w, 2*w)
				for (let i = 0, n = w; i <= n; i++)
					g.addColorStop(i / n, i % 2 == 0 ? 'gray' : 'white')
				x.rect(0, 0, w, w)
				x.fillStyle = g
				x.fill()
				cx.wall_pattern = cx.createPattern(c, 'repeat')
			}
			cx.lineWidth = DEBUG_PLAN ? 1 : sg.line_width
			cx.strokeStyle = '#fff'
			cx.stroke()
			cx.lineWidth = 1
			cx.fillStyle = DEBUG_PLAN ? '#333' : cx.wall_pattern
			cx.fill('nonzero')
		}

		if (DEBUG_PLAN)
		for (let c of draw_state.comps) {

			let [x,y] = poly_center(c.ps)
			cx.fillStyle = c.outer ? '#39f' : '#99f'
			cx.fillText(c.i + (c.area ? ' ('+format_kcount(c.area / 1e4)+'m²)' : ''), x, y+5)

			let co = c // no var shadowing because langauge designers are dumber than in the past
			for (let c of co.cycles) {
				for (let dp of c.edges) {
					let [dx, dy] = dp
					let [x0, y0] = dp.p
					let x = sg.x(x0) + sg.d(dx) - 5
					let y = sg.y(y0) + sg.d(dy) + 5
					cx.fillStyle = '#0f0'
					cx.fillText(c.i+'/'+dp.ci, x, y)
				}
			}

		}

		if (hs?.has('p')) {
			let p     = hs.get('p')
			let sdx   = hs.get('sdx')
			let sdy   = hs.get('sdy')
			let p_seg = hs.get('p_seg')
			let x = p[0] + sdx * 10
			let y = p[1] + sdy * 10
			cx.beginPath()
			for (let i = 0; i < 2; i++) {
				cx.arc(x + sdx * i * 15, y + sdy * i * 15, 5, 0, 2*PI)
				cx.closePath()
			}
			cx.fillStyle = 'red'
			cx.fill()
			// pr(p.i, sdx, sdy, p_seg && p_seg.i)
		}

		// cursor
		let action = cs?.get('action')
		let hit_seg = action == 'move_seg' && cs.get('seg') || hs?.get('seg')
		if (hit_seg) {
			if (hit_seg[0].segs.length == 1 && hit_seg[1].segs.length == 1)
				ui.set_cursor('move')
			else
				ui.set_cursor(is_v(hit_seg) ? 'ew-resize' : 'ns-resize')
		}
		else if (hs?.get('p'))
			ui.set_cursor(hs.get('p_seg') ? 'alias' : 'copy')
		else
			ui.set_cursor('copy')

		// segments
		if (DEBUG_PLAN)
		for (let seg of draw_state.segs) {
			let p1 = seg[0]
			let p2 = seg[1]
			cx.beginPath()
			let x1 = sg.x(p1[0])
			let y1 = sg.y(p1[1])
			let x2 = sg.x(p2[0])
			let y2 = sg.y(p2[1])
			cx.moveTo(x1, y1)
			cx.lineTo(x2, y2)
			cx.strokeStyle = hit_seg == seg ? 'white' : '#666'
			cx.stroke()

			let [x0, y0] = seg_center(seg)
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = '#f66'
			cx.fillText(seg.i, x, y)
		}

		// point numbers
		if (DEBUG_PLAN)
		for (let p of draw_state.ps) {
			let [x0, y0] = p
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = 'white'
			cx.fillText(p.i, x, y)
		}

		cx.restore()
	},

	hit: function(a, i) {

		let x00 = a[i+0]
		let y00 = a[i+1]
		let w   = a[i+2]
		let h   = a[i+3]
		let id  = a[i+PLAN_VIEW_ID]
		let draw_state = a[i+PLAN_VIEW_DRAW_STATE]

		if (ui.captured(id))
			return

		if (!ui.hit_box(a, i))
			return

		let hs = ui.hover(id)

		let sg = scale_group('editor')

		let cx = ui.cx

		let sl = draw_state.snap_lines
		sl.length = 0

		let snap_d = ui.key('shift') ? 1 : 10

		cx.save()
		cx.translate(x00, y00)
		cx.translate(draw_state.x0, draw_state.y0)
		ui.update_mouse()

		if (hs) {

			let hit_p
			for (let p of draw_state.ps) {
				let dx = ui.mx - sg.x(p[0])
				let dy = ui.my - sg.y(p[1])
				if (abs(dx) <= snap_d && abs(dy) <= snap_d) {
					hit_p = p
					hs.set('p', p) // point to start new seg from
					sl.push(p[0], 1, p[1], 0)
					break
				}
			}

			let hit_seg
			if (!hit_p)
				for (let seg of draw_state.segs) {
					let p1 = seg[0]
					let p2 = seg[1]
					let x1 = sg.x(min(p1[0], p2[0]))
					let y1 = sg.y(min(p1[1], p2[1]))
					let x2 = sg.x(max(p1[0], p2[0]))
					let y2 = sg.y(max(p1[1], p2[1]))
					if (y1 == y2) {
						y1 -= 5
						y2 += 5
					} else if (x1 == x2) {
						x1 -= 5
						x2 += 5
					} else {
						continue
					}
					if (ui.hit_rect(x1, y1, x2-x1, y2-y1)) {
						hit_seg = seg
						hs.set('seg', seg)
						break
					}
				}

			if (!hit_p && !hit_seg) {
				let x = sg.plan_x(ui.mx)
				let y = sg.plan_y(ui.my)
				let [sx, sy] = ui.state(id).get('plan').snap_point(x, y, snap_d)
				hs.set('x', sx ?? x)
				hs.set('y', sy ?? y)
				if (sx != null) sl.push(sx, 1)
				if (sy != null) sl.push(sy, 0)
			}

		}

		cx.restore()
		ui.update_mouse()

	},

})

// face view -----------------------------------------------------------------

let FACE_VIEW_ID   = ui.S-1
let FACE_VIEW_PLAN = ui.S+0
let FACE_VIEW_FACE = ui.S+1

ui.box_widget('face_view', {

	create: function(cmd, id, plan, face, fr, align, valign, min_w, min_h) {

		let [dstate, dx, dy] = ui.drag(id)

		return ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
				id, plan, face
			)
	},

	draw: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let plan = a[i+FACE_VIEW_PLAN]
		let face = a[i+FACE_VIEW_FACE]

		return

		// face is 1,2,3,4 going clockwise from the left-to-right face.
		let face_vert = (face-1) & 1
		let face_sign = face <= 2 ? 1 : -1

		let [scale, face_x, face_y, min_depth, max_depth] = face_scale(plan, face_vert, w, h)

		let hs = ui.hit(id)

		let cx = ui.cx

		cx.beginPath()

		cx.save()

		cx.translate(x00, y00)
		cx.translate(-face_x, -face_y)

		let walls = sort_face_walls(plan, face_vert, face_sign)

		for (let level_num = plan.levels.length-1; level_num >= 0; level_num--) {

			let lv = plan.levels[level_num]
			let h = pix(lv.h, scale)

			// draw walls (offset face) in depth order.
			let X = face_vert ? 1 : 0
			let Y = face_vert ? 0 : 1
			for (let [wr, i] of walls) {

				if ((wr.level ?? 0) != level_num)
					continue

				let [x, y, w, h, z] = wall_face_rect(plan, lv, wr, i, scale)

				let depth = lerp(z, min_depth * scale, max_depth * scale, 0, 1)

				cx.beginPath()
				cx.rect(x, y, w, h)
				cx.fillStyle = ui.hsl_adjust(ui.bg_color_hsl('bg3'), 1, 1, depth, 1 - depth/4)
				cx.fill()

				cx.beginPath()
				cx.rect(x + .5, .5, w, h)
				cx.strokeStyle = ui.fg_color('text')
				cx.stroke()

				// draw openings.
				let wall = wr.walls[i]
				let ops = wall.openings
				if (ops) {
					for (let op of ops) {

						let [x, y, w, h] = opening_face_rect(op, wr, i, lv, scale)

						cx.save()
						cx.translate(x, y)

						cx.beginPath()
						cx.rect(0, 0, w, h)
						cx.fillStyle = ui.bg_color('bg')
						cx.fill()

						let op_class = comp[op.type]
						op_class.draw_face(cx, op, w, h, hs)

						cx.restore()
					}
				}

			}

			cx.translate(0, h)

		}

		cx.restore()

	},

	hit: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let plan = a[i+FACE_VIEW_PLAN]
		let face = a[i+FACE_VIEW_FACE]

		return

		// face is 1,2,3,4 going clockwise from the left-to-right face.
		let face_vert = (face-1) & 1
		let face_sign = face <= 2 ? 1 : -1

		let hs = ui.hovers(id)
		let cs = ui.captured(id)

		if (!cs) {

			let [scale, face_x, face_y] = face_scale(plan, face_vert, w, h)

			let cx = ui.cx

			cx.save()
			cx.translate(x00, y00)
			cx.translate(-face_x, -face_y)
			ui.update_mouse()

			let walls = sort_face_walls(plan, face_vert, face_sign)
			walls.reverse()

			let y = 0
			for (let level_num = plan.levels.length-1; level_num >= 0; level_num--) {

				let lv = plan.levels[level_num]

				if (hit_face(plan, lv, level_num, walls, id, scale, true))
					break

				y += pix(lv.h, scale)
				cx.translate(0, y)
				ui.update_mouse()
			}

			cx.restore()
			ui.update_mouse()

		}

	},

})

// test UI -------------------------------------------------------------------

let test_plan = house_plan({

	levels: [
		{
			segs: [
				// outside rect
				[[0,0],[500,0]],
				[[500,0],[500,500]],
				[[500,500],[0,500]],
				[[0,500],[0,0]],

				[[0,300],[500,300]],
				[[0,200],[300,200]],
				[[200,0],[200,400]],

				// peninsula
				[[300,200],[300,100]],
				[[300,100],[400,100]],
				[[400,100],[400,200]],
				[[400,200],[300,200]],

				[[200,400],[300,400]],

				[[500,300],[600,300]],
				[[600,300],[600,400],],
				[[600,300],[700,300]],

				// island for testing inside check

				// [[0,600],[300,600]],
				// [[300,600],[300,900]],
				// [[300,900],[0,900]],
				// [[0,900],[0,600]],

				// [[100,650],[200,650]],
				// [[200,650],[200,800]],
				// [[200,800],[100,800]],
				// [[100,800],[100,650]],

				// brick-like-layout for testing seg detach on seg move

				// [[700,500],[700,1000]],
				// [[700,1000],[1200,1000]],
				// [[1200,1000],[1200,500]],
				// [[1200,500],[700,500]],
				// [[900,500],[900,1000]],
				// [[700,600],[900,600]],
				// [[700,800],[900,800]],
				// [[900,700],[1200,700]],
			],
		},
		{
			segs: [
				[[0,100],[800,100]],
			],
		},
	],

})

ui.main = function() {

	ui.m(100)
	ui.h()

		ui.v()

			for (let i = test_plan.levels.length-1; i >= 0; i--) {
				ui.m(10)
				ui.stack()
					ui.bb('', null, null, 1, 'light')
					ui.plan_view('pv'+i, test_plan.level_plan(test_plan.levels[i]))
				ui.end_stack()
			}

		ui.end_v()

		ui.v()

			for (let face = 1; face <= 4; face++) {
				ui.m(10)
				ui.stack()
					ui.bb('', null, null, 1, 'light')
					//ui.face_view('fv'+face, test_plan, face)
				ui.end_stack()
			}

		ui.end_v()

		//ui.comps()

	ui.end_h()

}

DEBUG_PLAN = 0

}()) // module function

</script>
</body>
</html>
