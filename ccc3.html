<!DOCTYPE html>
<html theme=dark>
<body>
<base href="www2/">
<link rel="preload" href="icons/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="icons/fa-solid-900.woff2"   as="font" type="font/woff2" crossorigin>
<script src=glue.js global></script>
<script src=ui.js></script>
<script src=ui_validation.js></script>
<script src=ui_nav.js></script>
<script src=ui_grid.js></script>
<script>

(function () {
"use strict"
const G = window

DEBUG('DEBUG_PLAN')

let clone = structuredClone

let EPSILON = 1e-5

function near(a, b) { return abs(a - b) < EPSILON }

let out = []

let floor_names = [
	'GROUND FLOOR',
	'1ˢᵗ FLOOR',
	'2ⁿᵈ FLOOR',
	'3ʳᵈ FLOOR',
]

// hierarchical buffered error logging ---------------------------------------

let errs = []
let log_stack = []
let log_on = true
function log(err, ...args) {
	if (!log_on) return
	errs.push(isstr(err) ? subst(err, ...args) : err)
}
function push_log() {
	log_stack.push(errs)
	errs = []
	errs.t0 = clock()
}
function pop_log(err, ...args) {
	let errs1 = errs
	let dt = (clock() - errs1.t0) * 1000
	errs1.dt = dt
	errs = log_stack.pop()
	if (err !== undefined && errs1.length) {
		log(err, ...args)
		log(errs1)
		if (dt > 3)
			log('{0} TIME {1} ms', ('*').repeat(dt), dec(dt))
	} else {
		return errs1
	}
}
function check(v, ...args) {
	if (!v) log(...args)
	return v
}
function pr_errs(es, level) {
	let indent = ('  ').repeat(level)
	for (let s of es)
		if (isarray(s))
			pr_errs(s, level+1)
		else
			pr(indent + s)
}
function pr_log() {
	assert(!log_stack.length)
	pr_errs(errs, 0)
	errs.length = 0
}

// bbox geometry -------------------------------------------------------------

function bbox() {
	return [inf, inf, -inf, -inf] // x1, y1, x2, y2
}

function bbox_reset(bbox) {
	bbox[0] =  inf
	bbox[1] =  inf
	bbox[2] = -inf
	bbox[3] = -inf
}

function bbox_add_bbox(bb, x1, y1, x2, y2) {
	bb[0] = min(bb[0], x1, x2)
	bb[1] = min(bb[1], y1, y2)
	bb[2] = max(bb[2], x1, x2)
	bb[3] = max(bb[3], y1, y2)
}

function bbox_add_point(bb, x, y) {
	bb[0] = min(bb[0], x)
	bb[1] = min(bb[1], y)
	bb[2] = max(bb[2], x)
	bb[3] = max(bb[3], y)
}

function bbox_rotate(bb, a) {
	let [x1, y1, x2, y2] = bb
	if (!a)
		return
	let cx = (x2 + x1) / 2
	let cy = (y2 + y1) / 2
	let [p1x, p1y] = rotate_point(x1, y1, cx, cy, a)
	let [p2x, p2y] = rotate_point(x1, y2, cx, cy, a)
	let [p3x, p3y] = rotate_point(x2, y1, cx, cy, a)
	let [p4x, p4y] = rotate_point(x2, y2, cx, cy, a)
	bbox_reset(bb)
	bbox_add_point(bb, p1x, p1y)
	bbox_add_point(bb, p2x, p2y)
	bbox_add_point(bb, p3x, p3y)
	bbox_add_point(bb, p4x, p4y)
}

function bbox_inside_bbox(cbb, pbb) {
	let [px1, py1, px2, py2] = pbb
	let [cx1, cy1, cx2, cy2] = cbb
	return cx1 >= px1 && cx2 <= px2 && cy1 >= py1 && cy2 <= py2
}

function hit_bbox(x, y, bb) {
	let [x1, y1, x2, y2] = bb
	return x >= x1 && x <= x2 && y >= y1 && y <= y2
}

// polygon geometry ----------------------------------------------------------

function poly_center(ps) {
	let [x0, y0] = ps[0]
	let twicearea = 0
	let x = 0
	let y = 0
	for (let i = 0, n = ps.length, j = n-1; i < n; j = i++) {
		let [x1, y1] = ps[i]
		let [x2, y2] = ps[j]
		let f = (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0)
		twicearea += f
		x += (x1 + x2 - 2 * x0) * f
		y += (y1 + y2 - 2 * y0) * f
	}
	let f = twicearea * 3
	return [
		x / f + x0,
		y / f + y0
	]
}

// TODO: remove or ignore filaments
function hit_poly(x, y, ps) {
	let inside = false
	for (let i = 0, j = ps.length - 1; i < ps.length; j = i++) {
		let xi = ps[i][0]
		let yi = ps[i][1]
		let xj = ps[j][0]
		let yj = ps[j][1]
		let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
		if (intersect)
			inside = !inside
	}
	return inside
}

// polygon offset algorithm --------------------------------------------------

// parallel line segment at a distance on the right side of a segment.
// use a negative distance for the left side, or reflect the returned points
// against their respective initial points.
function line_offset(d, x1, y1, x2, y2) {
	// normal vector of the same length as original segment.
	let dx = -(y2-y1)
	let dy =   x2-x1
	let k = d / distance(x1, y1, x2, y2) // normal vector scale factor
	// normal vector scaled and translated to (x1,y1) and (x2,y2)
	out[0] = x1 + dx * k
	out[1] = y1 + dy * k
	out[2] = x2 + dx * k
	out[3] = y2 + dy * k
	return out
}

// evaluate a line at time t using linear interpolation.
// the time between 0..1 covers the segment interval.
function line_point(t, x1, y1, x2, y2) {
	out[0] = x1 + t * (x2 - x1)
	out[1] = y1 + t * (y2 - y1)
	return out
}

// intersect line segment (x1, y1, x2, y2) with line segment (x3, y3, x4, y4).
// returns the time on the first line where intersection occurs.
// if the intersection occurs outside the segments themselves, then t is
// outside the 0..1 range. if the lines are parallel then t is +/-inf.
// if they are coincidental, t is NaN.
function line_line_intersection(x1, y1, x2, y2, x3, y3, x4, y4) {
	let d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)
	return ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d
}

function set_seg_offset(p1, p2, d) {
	for (let seg of p1.segs) {
		if (seg[0] == p2) { // (p2,p1) right side offset
			seg[-2] = d
			return
		} else if (seg[1] == p2) { // (p1,p2) right side offset
			seg[-1] = d
			return
		}
	}
	// TODO: see why this breaks
	///assert(false, '#'+p1.segs.length)
}

// TODO: implement fast path for axis-aligned segments.
function offset_corner(p0, p1, p2, d) {
	set_seg_offset(p0, p1, d)
	set_seg_offset(p1, p2, d)
	p0.max_offset = max(p0.max_offset, abs(d))
	p1.max_offset = max(p1.max_offset, abs(d))
	p2.max_offset = max(p2.max_offset, abs(d))
	let [x1, y1, x2, y2] = line_offset( d, p0[0], p0[1], p1[0], p1[1])
	let [x3, y3, x4, y4] = line_offset(-d, p2[0], p2[1], p1[0], p1[1])
	let t1 = line_line_intersection(x1, y1, x2, y2, x3, y3, x4, y4)
	if (abs(t1) == inf) { // 0-degree corner: make a line cap of 2 points, 1*d thick
		let dx = x2 == x4 ? d * sign(x1 - x2) : 0
		let dy = y2 == y4 ? d * sign(y1 - y2) : 0
		out[0] = x2 + dx
		out[1] = y2 + dy
		out[2] = x4 + dx
		out[3] = y4 + dy
	} else if (t1 != t1) { // 180-degree corner: use the offset point on the first line
		out[0] = x2
		out[1] = y2
		out[2] = null
		out[3] = null
	} else { // bent corner
		out[2] = null
		out[3] = null
		if (x1 == x2 && y3 == y4 || y1 == y2 && x3 == x4) { // axis-aligned and _|_ to each other
			let t1s = -sign(t1-1) // branchless version of t1 < 1 ? 1 : -1
			out[0] = x2 + d * sign(x2 - x1) * t1s
			out[1] = y2 + d * sign(y2 - y1) * t1s
		} else {
			line_point(t1, x1, y1, x2, y2)
		}
	}
	return out
}

function points_colinear(p0, p1, p2) {
	return (
		pseudo_angle(p1[0] - p0[0], p1[1] - p0[1]) ==
		pseudo_angle(p2[0] - p1[0], p2[1] - p1[1])
	)
}

function offset_poly(ps, d) {
	let ops = []

	// remove null segments as we can't offset those (they don't have a normal).
	let ps1 = ps
	ps = []
	for (let i = 0, n = ps1.length; i < n; i++) {
		let p0 = ps1[mod(i-1, n)]
		let p1 = ps1[i]
		if (!points_equal(p0, p1))
			ps.push(p1)
	}

	if (ps.length == 1) { // single null seg: make a square
		let ci = 0
		for (let op of [[-d, -d], [d, -d], [d, d], [-d, d]]) {
			op.p = ps[0]
			op.ci = ci++
			ops.push(op)
		}
	} else {
		let ci = 0
		for (let i = 0, n = ps.length; i < n; i++) {
			let p1 = ps[i]
			let i0 = i-1
			let i2 = i+1
			let p0 = ps[mod(i0--, n)]
			let p2 = ps[mod(i2++, n)]
			let [x1, y1, x2, y2] = offset_corner(p0, p1, p2, d)
			let [x0, y0] = p1
			let op1 = [x1 - x0, y1 - y0]
			op1.p = p1
			op1.ci = ci++
			ops.push(op1)
			if (x2 != null) {
				let op2 = [x2 - x0, y2 - y0]
				op2.p = p1
				op2.ci = ci++
				ops.push(op2)
			}
		}
	}
	return ops
}

/* ---------------------------------------------------------------------------
	Algorithm for extracting all base cycles from an unidirected planar graph.
	- input: no null segs, no isolated points, no overlapping or intersecting segs allowed.
	- points can be: end-points (#adj=1), joints (#adj=2) or branch points (#adj > 2).
	- output: cycles and filaments.
	Paper : https://www.geometrictools.com/Documentation/MinimalCycleBasis.pdf
	Code  : https://github.com/vbichkovsky/min-cycles/blob/master/src/cycles.js
*/

function rebuild_adj_refs(ps) {
	for (let p of ps)
		p.adj.length = 0
	for (let p of ps)
		for (let seg of p.segs)
			p.adj.push(seg[1-seg_pi(seg, p)])
}

function rem_edge(p1, p2, ps) {
	remove_value(p1.adj, p2)
	remove_value(p2.adj, p1)
	if (p1.adj == 0) remove_value(ps, p1)
	if (p2.adj == 0) remove_value(ps, p2)
}

function rem_filament(p, ps) {
	while (p && p.adj.length < 2) {
		remove_value(ps, p)
		let pa = p.adj[0]
		if (pa)
			rem_edge(p, pa, ps)
		p = pa
	}
}

function is_cw(ps) {
	let s = 0
	for (let i = 0, n = ps.length; i < n; i++) {
		let [x1, y1] = ps[mod(i-1, n)]
		let [x2, y2] = ps[i]
		s += (x2-x1)*(y2+y1)
	}
	return s < 0
}

function left_bottom_point(ps) {
	return ps.reduce((p0, p1) => {
		let x1 = p1[0]
		let x0 = p0[0]
		if (x1 < x0) return p1
		if (x0 < x1) return p0
		let y1 = p1[1]
		let y0 = p0[1]
		if (y1 > y0) return p1
		return p0
	})
}

// return a number from the range [0..4) which is monotonically increasing
// with the clockwise angle that the input vector makes against the x axis.
// NOTE: one branch miss (20cy) + one division (4cy) is still faster than atan2 (100cy).
// Then again, one cache miss is 100cy so all this is irrelevant.
function pseudo_angle(dx, dy) {
	let p = dx / (abs(dx) + abs(dy))  // -1..0 (x <= 0) or 0..1 (x >= 0)
	return dy < 0 ? 3 + p : 1 - p     //  2..4 (y <= 0) or 0..2 (y >= 0)
}

// return the angle sweep from angle a1 to a2 in cw (+) or ccw (-) dir.
function angle_sweep(a1, a2, clockwise, circle_sweep) {
	circle_sweep ??= 4
	let d = a2 - a1
	if (d < 0 && clockwise)
		d += circle_sweep
	else if (d > 0 && !clockwise)
		d -= circle_sweep
	return d
}

// return p1 from p.adj where the angle at p on (p0,p,p1) is smallest in cw or ccw direction.
function next_adj(p0, p, clockwise, max_a) {
	max_a ??= inf
	if (p.adj.length == 1 && max_a >= 2) // end-point, go back (or forward if first)
		return p.adj[0]
	let x0 = p0 ? p0[0] - p[0] : 0
	let y0 = p0 ? p0[1] - p[1] : 1
	let a0 = pseudo_angle(x0, y0)
	let min_a = inf // min angle
	let min_p // point with min angle to (p0,p)
	for (let p1 of p.adj) {
		if (p1 == p0)
			continue
		let x1 = p1[0] - p[0]
		let y1 = p1[1] - p[1]
		let a1 = pseudo_angle(x1, y1)
		let a = abs(angle_sweep(a1, a0, clockwise))
		if (a < min_a && a <= max_a) {
			min_a = a
			min_p = p1
		}
	}
	return min_p
}

function closed_walk(first, outer_cycle) {
	let walk = []
	let curr = first
	let prev
	do {
		walk.push(curr)
		let next = next_adj(prev, curr, !prev || outer_cycle)
		prev = curr
		curr = next
		if (curr == first) {
			if (outer_cycle) {
				// when tracing the outer cycle is not enough to stop when the
				// starting point is encountered since multiple outer cycles can
				// meet at the starting point (connected with filaments or not).
				let next = next_adj(prev, curr, true)
				if (next == walk[1])
					break
			} else {
				break // filament check done later on inner cycles
			}
		}
	} while (1)
	return walk
}

function extract_cycles_for(comp, gen_id) {
	let ps = [...comp.ps]
	while (ps.length > 0) {
		let p = left_bottom_point(ps)
		let c = closed_walk(p)
		if (c[1] != c[c.length-1]) { // not started with a filament
			c.i = gen_id('cycle')
			c.comp = comp
			c.area_pos = poly_center(c)
			comp.cycles.push(c)
		}
		// the first edge is always safe to remove because starting from the leftmost
		// point means that there cannot be a cycle to the right of that first edge
		// so that edge is part of at most one cycle: our cycle.
		rem_edge(c[0], c[1], ps)
		// the removed edge's end-points are now possibly end-points of filaments
		// that we must remove too.
		rem_filament(c[0], ps)
		rem_filament(c[1], ps)
	}
}

function extract_outer_cycle_for(comp, gen_id) {
	let p = left_bottom_point(comp.ps)
	let c = closed_walk(p, true)
	c.reverse() // outer cycle must go clockwise
	c.outer = true
	c.i = gen_id('cycle')
	c.comp = comp
	c.area_pos = poly_center(c)
	comp.cycles.push(c)
	comp.outer_cycle = c
}

// house plan model utils ----------------------------------------------------

function is_h(seg) { return seg[0][1] == seg[1][1] }
function is_v(seg) { return seg[0][0] == seg[1][0] }
function is_null(seg) { return is_h(seg) && is_v(seg) }
function seg_dir(seg) { return is_h(seg) ? '-' : is_v(seg) ? '|' : '/' }

function seg_x1(seg) { return min(seg[0][0], seg[1][0]) }
function seg_y1(seg) { return min(seg[0][1], seg[1][1]) }
function seg_x2(seg) { return max(seg[0][0], seg[1][0]) }
function seg_y2(seg) { return max(seg[0][1], seg[1][1]) }

function set_seg_x1(seg, x) { let x1i = seg[0][0] < seg[1][0] ? 0 : 1; seg[x1i][0] = x }
function set_seg_y1(seg, y) { let y1i = seg[0][1] < seg[1][1] ? 0 : 1; seg[y1i][1] = y }
function set_seg_x2(seg, x) { let x2i = seg[0][0] < seg[1][0] ? 1 : 0; seg[x2i][0] = x }
function set_seg_y2(seg, y) { let y2i = seg[0][1] < seg[1][1] ? 1 : 0; seg[y2i][1] = y }

function seg_axis(seg) { return is_v(seg) ? seg_x1(seg) : seg_y1(seg) }
function seg_m1  (seg) { return is_v(seg) ? seg_y1(seg) : seg_x1(seg) }
function seg_m2  (seg) { return is_v(seg) ? seg_y2(seg) : seg_x2(seg) }

function set_seg_m1  (seg, m) { if (is_v(seg)) set_seg_y1(seg, m); else set_seg_x1(seg, m) }
function set_seg_m2  (seg, m) { if (is_v(seg)) set_seg_y2(seg, m); else set_seg_x2(seg, m) }
function set_seg_axis(seg, a) {
	if (is_v(seg)) {
		seg[0][0] = a
		seg[1][0] = a
	} else {
		seg[0][1] = a
		seg[1][1] = a
	}
}

function points_equal(p1, p2) { return p1[0] == p2[0] && p1[1] == p2[1] }

function seg_pi(seg, p) {
	assert(seg[0] == p || seg[1] == p)
	return seg[0] == p ? 0 : 1
}

function seg_i1(seg) { let mi = is_v(seg) ? 1 : 0; return seg[0][mi] < seg[1][mi] ? 0 : 1 }
function seg_i2(seg) { let mi = is_v(seg) ? 1 : 0; return seg[0][mi] < seg[1][mi] ? 1 : 0 }

function seg_p1(seg) { return seg[seg_i1(seg)] }
function seg_p2(seg) { return seg[seg_i2(seg)] }

function seg_center(seg) {
	let [p1, p2] = seg
	let [x1, y1] = p1
	let [x2, y2] = p2
	return [
		(x2 + x1) / 2,
		(y2 + y1) / 2,
	]
}

// ep = edge point aka offset point.
function ep_x(ep) { return ep[0] + ep.p[0] }
function ep_y(ep) { return ep[1] + ep.p[1] }

function edge_is_v(ep1, ep2) {
	let x1 = ep_x(ep1)
	let x2 = ep_x(ep2)
	// near() not need here since we special-case offseting axis-aligned _|_ segs.
	return near(x1, x2)
}

// face plan model utils -----------------------------------------------------

// NOTE: face is 1,2,3,4 going clockwise from the left-side face.
let face_is_v = face => face & 1
let face_sign = face => (face & 2) - 1

G.v = face_is_v
G.s = face_sign

// view utils ----------------------------------------------------------------

let format_length = d => format_kcount(d / 1e2, 2)+'m'
let format_area = a => format_kcount(a / 1e4, 2)+'m²'

function plan2d(e) {

	e.ps ??= []
	e.segs ??= []
	e.comps = []
	e.root_comps = []

	let gen_id = e.gen_id
	let ps = e.ps
	let segs = e.segs
	let comps = e.comps
	let root_comps = e.root_comps

	// model editing -------------------------------------------------------

	function init_point(p, i) {
		p.segs = []
		p.adj = []
		p.i = gen_id('point')
	}

	function add_point(x, y) {
		let p = [x, y]
		init_point(p, ps.length)
		ps.push(p)
		log('point added: {0} {1},{2}', p.i, x, y)
		return p
	}
	e.add_point = add_point

	function rem_point(p) {
		remove_value(ps, p)
		log('point removed: {0}', p.i)
	}

	function rem_points(cond, msg) {
		let a = []
		remove_values(ps, function(p) {
			if (!cond(p)) return
			a.push(p.i)
			return true
		})
		if (a.length)
			log('{0} removed: {1}', msg ?? 'points', a.join(' '))
	}

	function add_seg_ref(p, seg) {
		p.segs.push(seg)
	}

	function rem_seg_ref(p, seg) {
		remove_value(p.segs, seg)
	}

	function add_seg_refs(seg) {
		add_seg_ref(seg[0], seg)
		add_seg_ref(seg[1], seg)
	}

	function rem_seg_refs(seg) {
		rem_seg_ref(seg[0], seg)
		rem_seg_ref(seg[1], seg)
	}

	function add_seg(p1, p2) {
		let seg = [p1, p2]
		seg.i = gen_id('seg')
		segs.push(seg)
		add_seg_refs(seg)
		log('seg added: {0}: {1} {2}', seg.i, seg[0].i, seg[1].i)
		return seg
	}
	e.add_seg = add_seg

	function rem_seg(seg) {
		rem_seg_refs(seg)
		remove_value(segs, seg)
		log('seg removed: {0}', seg.i)
	}

	function rem_segs(cond, msg) {
		let a = []
		remove_values(segs, function(seg) {
			if (!cond(seg)) return
			rem_seg_refs(seg)
			a.push(seg.i)
			return true
		})
		if (log && a.length)
			log('{0} removed: {1}', msg ?? 'segs', a.join(','))
	}

	function rem_marked_segs(msg) {
		rem_segs(seg => seg.removed, msg)
	}

	function set_seg_point(seg, i, p) {
		let old_p = seg[i]
		rem_seg_ref(old_p, seg)
		seg[i] = p
		add_seg_ref(p, seg)
		log('seg end moved: {0}/{1}: {2}->{3}', seg.i, i, old_p.i, p.i)
		return old_p
	}
	e.set_seg_point = set_seg_point

	// model fixing --------------------------------------------------------

	function rebuild_seg_refs() {
		for (let p of ps)
			p.segs.length = 0
		for (let seg of segs)
			add_seg_refs(seg)
	}

	function remove_isolated_points() {
		rem_points(p => p.segs.length == 0, 'isolated points')
	}

	function remove_null_segs() {
		rem_segs(is_null, 'null segs')
	}

	function remove_angled_segs() {
		rem_segs(seg => seg_dir(seg) == '/', 'angled segs')
	}

	// NOTE: assumes segs are sorted, null segs removed, points deduplicated.
	function merge_colinear_segs() {
		for (let p of ps) {
			if (p.segs.length == 2) {
				let s1 = p.segs[0]
				let s2 = p.segs[1]
				if (is_v(s1) && is_v(s2) || is_h(s1) && is_h(s2)) { // colinear
					let s1_pi = seg_pi(s1, p)
					let s2_p2 = s2[1-seg_pi(s2, p)]
					push_log()
					set_seg_point(s1, s1_pi, s2_p2)
					rem_seg(s2)
					pop_log('segs merged: {0} + {1} => {0}', s1.i, s2.i, s1.i)
				}
			}
		}
	}

	// shortens seg at m with new point and adds new seg without detaching the original seg's end-points.
	function split_seg_at(seg, m) {
		push_log()
		let m1 = seg_m1(seg)
		let m2 = seg_m2(seg)
		let x = is_v(seg) ? seg_x1(seg) : m
		let y = is_v(seg) ? m : seg_y1(seg)
		let new_p = add_point(x, y)
		let old_p = set_seg_point(seg, seg_i2(seg), new_p)
		let new_seg = add_seg(new_p, old_p)
		pop_log('seg split: {0} {4}>{1}<{5} => {2} {3}', seg.i, m, seg.i, new_seg.i, m1, m2)
	}

	// NOTE: only works for h and v segs.
	function split_intersecting_segs_on(v) {
		push_log()
		for (let seg1 of segs) {
			if (is_v(seg1) == v) {
				for (let seg2 of segs) {
					if (is_v(seg2) != v) {
						let m1  = seg_m1(seg1)
						let m2  = seg_m2(seg1)
						let bm1 = seg_m1(seg2)
						let bm2 = seg_m2(seg2)
						let a   = seg_axis(seg1)
						let ba  = seg_axis(seg2)
						if (bm1 <= a && bm2 >= a && ba > m1 && ba < m2) {
							// splitting adds a seg at the end of segs array which will
							// be also tested in the outer loop and possibly split further.
							// the shortened seg is potentially split multiple times
							// in this inner loop.
							split_seg_at(seg1, ba)
						}
					}
				}
			}
		}
		pop_log('split all intersecting segs')
	}
	function split_intersecting_segs() {
		split_intersecting_segs_on(0)
		split_intersecting_segs_on(1)
	}

	// NOTE: leaves isolated points behind.
	function points_cmp(p1, p2) {
		let dx = p1[0] - p2[0]; if (dx) return dx
		let dy = p1[1] - p2[1]; if (dy) return dy
		return p1.i - p2.i
	}
	function deduplicate_points() {
		push_log()
		ps.sort(points_cmp)
		let p0
		for (let i = 0; i < ps.length; i++) {
			let p = ps[i]
			if (p0 && points_equal(p, p0)) {
				for (let j = 0; j < p.segs.length; j++) { // each connected seg
					let seg = p.segs[j]
					for (let i = 0; i < 2; i++) // each seg end
						if (seg[i] == p) {
							set_seg_point(seg, i, p0, 'seg end point dedup')
							j-- // because seg was just removed from p.segs
						}
				}
				continue
			}
			p0 = p
		}
		pop_log('deduplicate all points')
	}

	// NOTE: requires no intersecting segments.
	function break_overlapping_segs() {
		push_log()
		segs.sort(function(s1, s2) {
			// level 1 grouping by direction
			let v1 = is_v(s1)
			let v2 = is_v(s2)
			let dv = v1 - v2
			if (dv) return dv
			// level 2 grouping by axis
			let m1 = seg_axis(s1)
			let m2 = seg_axis(s2)
			let dm = m1 - m2
			if (dm) return dm
			// level 3 grouping by starting point because most segments are
			// non-overlapping and we want to skip those quickly.
			let i = v1 ? 1 : 0
			let c1 = min(s1[0][i], s1[1][i])
			let c2 = min(s2[0][i], s2[1][i])
			return c1 - c2
		})
		let i0, v0, m0
		for (let i = 0, n = segs.length; i <= n; i++) {
			let seg = segs[i]
			let v = seg ? is_v(seg) : null
			let m = seg ? seg_axis(seg) : null
			if (v0 == null) {
				i0 = i
				v0 = v
				m0 = m
			} else if (v != v0 || m != m0) {
				if (i >= i0 + 2) { // there's at least 2 segments on this axis
					for (let j = i0+1; j < i; j++) {
						let seg1 = segs[j]
						let seg0 = segs[j-1]
						let m1_1 = seg_m1(seg1)
						let m2_0 = seg_m2(seg0)
						if (m1_1 < m2_0) {
							// seg points that are overlapping segs have no _|_ joints
							// or they wouldn't be overlapping the seg, so it's safe
							// to remove the overlapping seg as long as we elongate
							// the overlapped seg.
							log('segs overlap: {0} {1}: {2}<={3}: seg {1} removed, seg {0}.m2 set to {4}',
								seg0.i, seg1.i, m1_1, m2_0, seg_m2(seg1))
							seg1.removed = true
							set_seg_m2(seg0, max(seg_m2(seg1), seg_m2(seg0)))
						}
					}
				}
				i0 = i
				v0 = v
				m0 = m
			}
		}
		rem_marked_segs()
		pop_log('breaking overlapping colinear segs')
	}

	// finding graph components --------------------------------------------

	function add_comp() {
		let comp = {}
		comp.i = gen_id('comp')
		comp.ps = []
		comp.cycles = []
		comp.segs = []
		comp.islands = []
		comps.push(comp)
		return comp
	}

	// NOTE: needs adj refs
	function find_comps() {

		for (let p of ps)
			p.visited = false

		comps.length = 0

		function dfs(p, ps, segs) {
			p.visited = true
			ps.push(p)
			for (let seg of p.segs)
				segs.add(seg)
			for (p of p.adj)
				if (!p.visited)
					dfs(p, ps, segs)
		}

		for (let p of ps) {
			if (!p.visited) {
				let comp = add_comp()
				let segs = set()
				dfs(p, comp.ps, segs)
				comp.segs = set_toarray(segs)
				log('comp {0}: {1}', comp.i, comp.ps.map(p=>p.i).join(' '))
			}
		}

	}

	// finding which components are inside islands -------------------------

	function points_bb(ps) {
		let bb = bbox()
		for (let [x, y] of ps) {
			bbox_add_point(bb, x, y)
		}
		return bb
	}

	function edges_bb(eps) {
		let bb = bbox()
		for (let ep of eps)
			bbox_add_point(bb, ep_x(ep), ep_y(ep))
		return bb
	}

	function plan_bb() {
		let bb = bbox()
		for (let co of comps) {
			bbox_add_bbox(bb, ...co.outer_cycle.edges.bb)
		}
		return bb
	}

	function is_inside_poly(c, ps, ps_bb) { // comp inside poly check
		if (!bbox_inside_bbox(c.bb, ps_bb))
			return false
		return hit_poly(c.ps[0][0], c.ps[0][1], ps)
	}

	function is_inside_comp(c, p) { // comp inside comp check
		return is_inside_poly(c, p.ps, p.bb)
	}

	function is_inside_cycle(co, cy) { // comp inside cycle check
		return is_inside_poly(co, cy, cy.bb)
	}

	// NOTE: O(n^2)
	function is_directly_inside_comp(c, p) { // comp directly inside comp check
		if (!is_inside_comp(c, p))
			return false
		for (let q of comps)
			if (q != c && q != p && q.inside && is_inside_comp(c, q) && is_inside_comp(q, p))
				return false
		return true
	}

	function find_inside_comps() {

		// point-based bbox: enough for computing inside flag.
		for (let c of comps) {
			c.inside = false
			c.parent = null
			c.islands.length = 0
			c.bb = points_bb(c.ps)
			for (let cy of c.cycles)
				cy.bb = points_bb(cy)
		}

		// set inside flag with O(n^2) in order to lower the n for the O(n^4) loop below.
		root_comps.length = 0
		for (let c of comps) {
			for (let p of comps) {
				if (p != c && is_inside_comp(c, p)) {
					c.inside = true
					break
				}
			}
			if (!c.inside)
				root_comps.push(c)
		}

		// NOTE: O(n^4) but only checks islands which should be rare.
		for (let c of comps) {
			if (!c.inside)
				continue
			for (let p of comps) {
				if (p != c && is_directly_inside_comp(c, p)) {
					c.parent = p
					p.islands.push(c)
				}
			}
		}

		// assign islands to inner cycles.
		for (let comp of comps) {
			for (let cycle of comp.cycles) {
				if (cycle.outer)
					continue
				cycle.islands = []
				for (let icomp of comp.islands) {
					if (is_inside_cycle(icomp, cycle)) {
						cycle.islands.push(icomp)
						log('comp {0} is inside comp {1} cycle {2}', icomp.i, comp.i, cycle.i)
					}
				}
			}
		}

	}

	// hit testing ------------------------------------------------------------

	function hit_edges(x, y, eps) {
		let inside = false
		for (let i = 0, n = eps.length, j = n-1; i < n; j = i++) {
			let xi = ep_x(eps[i])
			let yi = ep_y(eps[i])
			let xj = ep_x(eps[j])
			let yj = ep_y(eps[j])
			let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
			if (intersect)
				inside = !inside
		}
		return inside
	}

	function hit_cycle(x, y, c) {
		if (c.outer)
			return
		if (!hit_bbox(x, y, c.edges.bb))
			return
		for (let icomp of c.islands) {
			for (let c1 of icomp.cycles) {
				let c2 = hit_cycle(x, y, c1)
				if (c2)
					return c2
			}
		}
		if (!hit_edges(x, y, c.edges))
			return
		return c
	}
	function hit_cycles(x, y) {
		for (let co of comps) {
			for (let c of co.cycles) {
				let hit_c = hit_cycle(x, y, c)
				if (hit_c)
					return hit_c
			}
		}
	}
	e.hit_cycles = hit_cycles

	// plan loading & validation -------------------------------------------

	function extract_cycles() {

		for (let c of comps)
			c.cycles.length = 0

		for (let c of comps)
			extract_outer_cycle_for(c, gen_id)
		rebuild_adj_refs(ps)

		for (let c of comps)
			extract_cycles_for(c, gen_id)
		rebuild_adj_refs(ps)

		if (1)
		for (let co of comps)
			for (let c of co.cycles)
				log('cycle {0}/{1} {2} {3} {4}: {5}', co.i, c.i,
					is_cw(c) ? 'cw' : 'ccw',
					c.outer ? 'outer' : '',
					c.inside ? 'inside' : '',
					c.map(p=>p.i).join(' ')
				)
	}

	e.after_fix = noop
	function fix() {
		split_intersecting_segs()
		break_overlapping_segs()
		remove_null_segs()
		deduplicate_points()
		merge_colinear_segs()
		remove_isolated_points()
		rebuild_adj_refs(ps)
		find_comps()
		extract_cycles()
		find_inside_comps()
		e.after_fix()
		// create_edges()
		// e.snap_lines[0] = snap_lines_for(1)
		// e.snap_lines[1] = snap_lines_for(0)
	}
	e.fix = fix

	// init -------------------------------------------------------------------

	function init() {
		for (let i = 0, n = ps.length; i < n; i++)
			init_point(ps[i], i)

		let seg_i = 0
		for (let seg of segs) {
			seg.i = gen_id('seg')
			for (let k = 0; k < 2; k++) {
				let i = seg[k]
				let p
				if (isarray(i)) // inline point
					p = add_point(...i)
				else
					p = check(ps[i], 'seg {0}/{1} invalid index {2}', seg.i, k, i)
				seg[k] = p
			}
		}
		remove_values(segs, seg => !seg[0] || !seg[1])

		rebuild_seg_refs()
		remove_angled_segs()
		fix()
	}
	e.init = init

	return e
}

// house model ---------------------------------------------------------------

let DEFAULT_FLOOR_H = 250

function house_plan(t) {

	let house_plan = {floor_plans: [], floor_h: t.floor_h ?? DEFAULT_FLOOR_H}

	let next_id = {}
	function gen_id(k) {
		if (!next_id[k])
			next_id[k] = 1
		else
			next_id[k]++
		return next_id[k]
	}

	function house_plan_bb() {
		let bb = bbox()
		for (let floor_plan of house_plan.floor_plans)
			bbox_add_bbox(bb, ...floor_plan.bb)
		return bb
	}

	function floor_plan(t, floor_i) {

		let floor_plan = plan2d({ps: t.ps, segs: t.segs, gen_id: gen_id,
			house_plan: house_plan, i: floor_i, h: t.h ?? house_plan.floor_h,
		})
		assert(floor_plan.h)
		let ps = floor_plan.ps
		let segs = floor_plan.segs
		let comps = floor_plan.comps
		let root_comps = floor_plan.root_comps
		let add_point = floor_plan.add_point
		let add_seg = floor_plan.add_seg
		let set_seg_point = floor_plan.set_seg_point
		let fix = floor_plan.fix

		floor_plan.snap_lines = []

		floor_plan.after_fix = function() {
			create_edges()
			floor_plan.snap_lines[0] = snap_lines_for(1)
			floor_plan.snap_lines[1] = snap_lines_for(0)
		}

		function fix_areas_for(comp) {
			for (let c of comp.cycles) {
				if (c.outer)
					continue
				let a0 = c.edges.area
				for (let icomp of c.islands) {
					fix_areas_for(icomp)
					c.edges.area -= icomp.outer_cycle.edges.area
				}
				let a1 = c.edges.area
				if (0 && a1 != a0)
					log('cycle {0} area fixed: {1} + {2} = {3}', c.i, a1, a0-a1, a0)
			}
		}

		function edges_area(eps) {
			let area = 0
			for (let i = 1, n = eps.length; i <= n; i++)
				area += ep_x(eps[mod(i, n)]) * (ep_y(eps[mod(i+1, n)]) - ep_y(eps[i-1]))
			return area / 2
		}

		function edges_bb(eps) {
			let bb = bbox()
			for (let ep of eps)
				bbox_add_point(bb, ep_x(ep), ep_y(ep))
			return bb
		}

		function floor_plan_bb() {
			let bb = bbox()
			for (let co of comps) {
				bbox_add_bbox(bb, ...co.outer_cycle.edges.bb)
			}
			return bb
		}

		function create_edges() {

			for (let p of ps)
				p.max_offset = 0

			for (let comp of comps) {
				for (let c of comp.cycles) {
					c.edges = offset_poly(c, (c.outer ? (c.comp.inside ? -4 : -12) : -4))
					c.edges.bb = edges_bb(c.edges)
					c.edges.area = abs(edges_area(c.edges))
				}
			}

			for (let c of root_comps)
				fix_areas_for(c)

			// compute the level plan bbox now that we have outer skins.
			floor_plan.bb = floor_plan_bb()

			// recompute house plan bbox.
			if (house_plan.bb) // not in init
				house_plan.bb = house_plan_bb()

		}

		// plan view UI ops ----------------------------------------------------

		// Find and fix the the cycles that contain the sequence (p0,p1,p2) or (p2,p1,p0).
		// If (p0,p1,p2) is found then the cycle is to the left of the sequence if it's an inner cycle.
		// If (p2,p1,p0) is found then the cycle is to the right of the sequence if it's an inner cycle.
		// It's the opposite if it's an outer cycle.
		// The same cycle will contain the sequence twice (once as is once in reverse)
		// if the sequence is (part of) a filament.
		// NOTE: replacing a point in the cycle (instead of always adding one) makes the cycle
		// technically invalid (as it's skipping a point) but we do it to keep the offset edge
		// stable at that corner while dragging the segment.
		function fix_cycle(c, i, fw, action, new_p, p0, p1, p2) {
			if (action == 'replace') {
				log('cycle point replaced: {0}/{1}: {2}->{3}', c.i, i, c[i].i, new_p.i)
				c[i] = new_p
			} else if (action == 'insert') {
				i = fw ? i : i+1 // insert point in the cycle array
				log('cycle point inserted: {0}/{1} (before {2}): {3}', c.i, i, c[i] ? c[i].i : 'end', new_p.i)
				insert(c, i, new_p)
			}
		}
		function fix_cycles_containing(p0, p1, p2, action, new_p) {
			push_log()
			for (let comp of comps)
				for (let c of comp.cycles) {
					let i0 = 0
					while (1) {
						let i = c.indexOf(p1, i0)
						if (i == -1)
							break
						let fp0 = c[mod(i-1, c.length)]
						let fp2 = c[mod(i+1, c.length)]
						if (fp0 == p0 && fp2 == p2) fix_cycle(c, i, 1, action, new_p, p0, p1, p2)
						if (fp0 == p2 && fp2 == p0) fix_cycle(c, i, 0, action, new_p, p2, p1, p0)
						i0 = i+1
					}
				}
			pop_log('all cycles containing ({0},{1},{2}): {3} with {4}', p0.i, p1.i, p2.i, action, new_p.i)
		}

		// colinear segs directly end-to-end tied to the segment we want to move
		// must be separated by addidng a _|_ seg in between so they're not dragged along.
		// NOTE: do not deduplicate points after this!
		function detach_seg_at(seg, i, p00) {
			push_log()
			let p  = seg[i]
			let p0 = seg[1-i]
			let new_p = add_point(p[0], p[1])

			// each side of (p0,p) needs a different kind of fixing depending on
			// whether there's a _|_ seg at the separation point on that side or not.
			if (p.adj.length > 2) {
				for (let cw = 0; cw <= 1; cw++) {
					let p1 = next_adj(p0, p, cw, 1)
					fix_cycles_containing(p0, p, p1 ?? p00, p1 ? 'replace' : 'insert', new_p)
				}
			} else { // no _|_ segs on the sides.
				fix_cycles_containing(p0, p, p00, 'insert', new_p)
			}

			set_seg_point(seg, i, new_p, 1)
			let new_seg = add_seg(p, new_p)
			pop_log('seg detached: {0}', seg.i)
		}
		function opposite_seg(seg, i) {
			let v = is_v(seg)
			let p = seg[i]
			for (let seg1 of p.segs) { // each segment connected to that end-point
				if (seg1 == seg) // itself
					continue
				if (is_v(seg1) != v) // not colinear
					continue
				if (is_null(seg1)) // just added
					continue
				return seg1
			}
		}
		function detach_opposite_seg(seg, i) {
			let seg1 = opposite_seg(seg, i)
			if (!seg1) return
			let p = seg[i]
			if (seg1[0] == p) detach_seg_at(seg1, 0, seg[1-i])
			else
			if (seg1[1] == p) detach_seg_at(seg1, 1, seg[1-i])
		}
		function detach_colinear_segs(seg) {
			detach_opposite_seg(seg, 0)
			detach_opposite_seg(seg, 1)
		}

		function segs_overlap(am1, am2, bm1, bm2) { // check if two segments overlap
			return !(am2 <= bm1 || bm2 <= am1)
		}

		function snap_lines_for(v, exclude_seg) {
			let mi = v ? 0 : 1
			let ms = []
			for (let plan of house_plan.floor_plans) {
				for (let p of plan.ps) {
					if (exclude_seg && (exclude_seg[0] == p || exclude_seg[1] == p))
						continue
					let m = p[mi]
					ms.push(m)
				}
			}
			ms.sort()
			uniq_sorted(ms)

			ms.snap = function(m, snap_d) {
				let min_d = 1/0
				let min_m
				for (let m1 of ms) {
					let d = abs(m - m1)
					if (d <= snap_d && d < min_d) {
						min_d = d
						min_m = m1
					}
				}
				return min_m // ?? snap(m, 10)
			}

			ms.v = v

			return ms
		}

		function snap_x(x, nosnap) {
			let snap_d = nosnap ? 2 : 20
			return floor_plan.snap_lines[0].snap(x, snap_d)
		}
		function snap_y(y, nosnap) {
			let snap_d = nosnap ? 2 : 20
			return floor_plan.snap_lines[1].snap(y, snap_d)
		}
		floor_plan.snap_x = snap_x
		floor_plan.snap_y = snap_y

		function seg_move_bump_limit(seg, sign) {
			let v = is_v(seg)
			let a = seg_axis(seg)
			let min_a1 = sign * 1/0
			let s_m1 = seg_m1(seg)
			let s_m2 = seg_m2(seg)
			for (let seg1 of segs) {
				let s1_m1 = seg_m1(seg1)
				let s1_m2 = seg_m2(seg1)
				let a1 = seg_axis(seg1)
				if (is_v(seg1) != v) {
					let closest_m = sign < 0 ? max(s1_m1, s1_m2) : min(s1_m1, s1_m2)
					s1_m1 = a1
					s1_m2 = a1
					a1 = closest_m
				}
				if (sign * a1 > sign * a && sign * a1 < sign * min_a1) {
					if (segs_overlap(s_m1, s_m2, s1_m1, s1_m2)) {
						min_a1 = a1
					}
				}
			}
			return min_a1
		}
		function seg_move_ranges(seg) {
			let min_a = seg_move_bump_limit(seg, -1)
			let max_a = seg_move_bump_limit(seg,  1)
			let ranges = [
				[min_a, max_a],
			]
			return ranges
		}
		function seg_resize_bump_limit(seg, p, sign) {
			let v = is_v(seg)
			let a = p[v ? 1 : 0]
			let m = p[v ? 0 : 1]
			let min_a1 = sign * 1/0
			for (let seg1 of segs) {
				if (is_v(seg1) != v) {
					let a1 = seg_axis(seg1)
					if (sign * a1 > sign * a && sign * a1 < sign * min_a1) {
						let m1 = seg_m1(seg1)
						let m2 = seg_m2(seg1)
						if (m >= m1 && m <= m2)
							min_a1 = a1
					}
				}
			}
			return min_a1
		}
		function seg_resize_ranges(seg, p) {
			let min_a = seg_resize_bump_limit(seg, p, -1)
			let max_a = seg_resize_bump_limit(seg, p,  1)
			let ranges = [
				[min_a, max_a],
			]
			return ranges
		}
		function closest_range(a, ranges) {
			let min_range
			let min_d = 1/0
			for (let range of ranges) {
				let [a1, a2] = range
				if (a >= a1 && a <= a2) { // in range
					min_range = range
					break
				}
				let d = max(0, min(abs(a1 - a), abs(a2 - a))) // distance to range's closest end-point
				if (d < min_d) {
					min_range = range
					min_d = d
				}
			}
			return min_range
		}
		function snap_seg(a, ranges, snap_lines, draw_state, snap_d) {
			let snap_range = closest_range(a, ranges)
			let [min_a, max_a] = snap_range
			a = clamp(a, min_a, max_a)
			let sa = snap_lines.snap(a, ui.key('shift') ? 2 : snap_d)
			draw_state.snap_lines.length = 0
			if (sa != null)
				draw_state.snap_lines.push(sa, snap_lines.v)
			return sa
		}

		// find the seg in the left, right, top, bottom side around p.
		function seg_around_point(p, sdx, sdy) {
			let p0 = [p[0] + sdx, p[1] + sdy]
			let p1 = next_adj(p0, p, 1, 0)
			// find the seg of (p, p1)
			for (let seg of p.segs)
				if (seg[0] == p && seg[1] == p1 || seg[1] == p && seg[0] == p1)
					return seg
		}

		function start_move_seg(seg, draw_state) {

			push_log()

			detach_colinear_segs(seg)

			pop_log('START MOVE SEG: {0}', seg.i)
			pr_log()

			let move_freely = seg[0].segs.length == 1 && seg[1].segs.length == 1
			let seg0 = [[...seg[0]], [...seg[1]]]
			let ranges = seg_move_ranges(seg)
			let snap_lines = snap_lines_for(is_v(seg), move_freely && seg)
			let v = is_v(seg0)
			let m_snap_lines = move_freely && snap_lines_for(!is_v(seg), seg)

			// find all affected _|_ edges so we can show their lengths as we move the seg
			{
			let perp_edges = []
			// find the farthest edge point from `c.edges[i0]` going in `dir` direction
			// in the array, which has the same spatial direction `v` with the previous point.
			function last_perp_edge_point(c, i, n, dir, v) {
				let ep0 = c.edges[mod(i, n)]
				while (1) {
					let ep1 = c.edges[mod(i, n)]
					let ep2 = c.edges[mod(i+dir, n)]
					if (ep2.p == ep0.p) // end-cap, don't measure
						return
					if (edge_is_v(ep1, ep2) != v) // changed direction, return last edge point
						return ep1
					i += dir
				}
			}
			let sp1 = seg[0]
			let sp2 = seg[1]
			let v = is_v(seg)
			for (let co of comps) {
				for (let c of co.cycles) {
					for (let i = 0, n = c.edges.length; i <= n; i++) {
						let ep1 = c.edges[mod(i+0, n)]
						let ep2 = c.edges[mod(i+1, n)]
						if (!(ep1.p == sp1 && ep2.p == sp2 || ep1.p == sp2 && ep2.p == sp1)) // not seg's edge
							continue
						let ep0 = last_perp_edge_point(c, i+0, n, -1, !v)
						let ep3 = last_perp_edge_point(c, i+1, n,  1, !v)
						if (!(ep0 || ep3))
							continue
						if (0) {
							// remove measurement of parallel wall of the same length
							let A = v ? 0 : 1 // index of cross axis of perp segs
							let dupe = ep0 && ep3 && ep0.p[A] == ep3.p[A]
							if (dupe)
								ep3 = null
						}
						if (ep0) perp_edges.push([ep0, ep1])
						if (ep3) perp_edges.push([ep2, ep3])
					}
				}
			}
			draw_state.measure_edges = perp_edges
			}

			let s = {}

			s.move = function(dx, dy, draw_state) {

				let dm = v ? dy : dx
				let da = v ? dx : dy

				if (move_freely) {

					let a = seg_axis(seg0) + da
					let sa = snap_lines.snap(a) ?? a
					a = sa ?? a

					// snap both end-points on main-axis.
					let m1 = seg_m1(seg0) + dm
					let m2 = seg_m2(seg0) + dm
					let m1s = m_snap_lines.snap(m1)
					let m2s = m_snap_lines.snap(m2)
					if (m1s != null && m2s != null) // both ends snapped
						if (abs(m1s - m1) <= abs(m2s - m2)) // pick the one closer to snap line
							m2s = null
						else
							m1s = null
					if (m1s != null)
						m2s = m1s + (seg_m2(seg0) - seg_m1(seg0))
					else if (m2s != null)
						m1s = m2s - (seg_m2(seg0) - seg_m1(seg0))

					seg[0][0] =  v ? a : m1s ?? m1
					seg[1][0] =  v ? a : m2s ?? m2
					seg[0][1] = !v ? a : m1s ?? m1
					seg[1][1] = !v ? a : m2s ?? m2

				} else { // move on cross axis

					let a = seg_axis(seg0) + (v ? dx : dy)
					let sa = snap_seg(a, ranges, snap_lines, draw_state, 20)
					a = sa ?? a
					set_seg_axis(seg, a)
					create_edges()

				}

			}

			s.stop = function(draw_state, remove_seg) {
				push_log()
				if (remove_seg)
					rem_seg(seg)
				fix()
				pop_log('STOP MOVE SEG: {0}', seg.i)
				pr_log()
				draw_state.snap_lines.length = 0
				draw_state.measure_edges.length = 0
			}

			return s
		}
		floor_plan.start_move_seg = start_move_seg

		function start_resize_seg(p, mx0, my0, dx, dy, sdx, sdy, draw_state) {

			// based on direction of drag, either detach a seg or add a seg, and start resizing it.
			push_log()

			let seg
			if (p) {
				// find seg in the drag direction around p.
				if (p.segs.length == 1 && is_v(p.segs[0]) == !!sdy) {
					// p is a free end-point and we're dragging along its main axis: resize it.
					seg = p.segs[0]
				} else {
					// find the seg around p in the direction of drag: that's the segment we want to detach and resize.
					seg = seg_around_point(p, sdx, sdy)
					if (seg) {
						// detach seg at branch point p so we can then resize it by its free end-point.
						let x = p[0] + dx * abs(sdx)
						let y = p[1] + dy * abs(sdy)
						let new_p = add_point(x, y)
						set_seg_point(seg, seg_pi(seg, p), new_p)
						p = new_p
					}
				}
			}

			if (!seg) { // create new seg, anchored to "hovered point" or to "mouse pos when clicked"
				let x1, y1
				if (p) {
					[x1, y1] = p
				} else {
					x1 = mx0
					y1 = my0
				}
				let x2 = x1 + dx * abs(sdx)
				let y2 = y1 + dy * abs(sdy)
				let p1 = add_point(x1, y1)
				let p2 = add_point(x2, y2)
				seg = add_seg(p1, p2)
				p = p2
			}

			let p0 = [...p]

			fix()

			pop_log('START RESIZE SEG: {0}', seg.i)
			pr_log()

			let ranges = seg_resize_ranges(seg, p)
			let snap_lines = snap_lines_for(!is_v(seg), seg)

			let s = {seg: seg}

			s.resize = function(dx, dy, draw_state, hs) {
				let x1 = p0[0] + dx * abs(sdx)
				let y1 = p0[1] + dy * abs(sdy)

				let a = sdx ? x1 : y1
				let sa = snap_seg(a, ranges, snap_lines, draw_state, 30)
				if (sa != null)
					a = sa
				if (sdx)
					x1 = a
				else
					y1 = a
				p[0] = x1
				p[1] = y1
				hs.set('x', x1)
				hs.set('y', y1)
				create_edges()
			}

			s.stop = function(draw_state) {
				push_log()
				fix()
				pop_log('STOP RESIZE SEG: {0}', seg.i)
				pr_log()
				draw_state.snap_lines.length = 0
				draw_state.measure_edges.length = 0
			}

			return s
		}
		floor_plan.start_resize_seg = start_resize_seg

		// init floor_plan -----------------------------------------------------

		push_log()
		floor_plan.init()
		pop_log('LEVEL LOADED {0}', floor_plan.i)

		return floor_plan
	}

	// face view --------------------------------------------------------------

	function face_view(face) {

		let fv = face_is_v(face)
		let fs = face_sign(face)

		let face_view = {house_plan: house_plan, i: face}

		let ep_m    = fv ? ep_y : ep_x
		let ep_axis = fv ? ep_x : ep_y

		function edge_sign(ep1, ep2) {
			return ep_m(ep1) < ep_m(ep2) ? 1 : -1
		}

		let walls = [] // exterior wall horizontal measurements
		let plans = []

		function create_face_plans() {

			walls.length = 0
			plans.length = 0

			let min_floor =  1/0
			let max_floor = -1/0

			// find outer edges that are projecting in the face's direction.
			for (let floor_plan of house_plan.floor_plans) {
				for (let comp of floor_plan.comps) {
					if (comp.inside)
						continue
					let eps = comp.outer_cycle.edges
					for (let i = 0, n = eps.length; i <= n; i++) {
						let ep1 = eps[mod(i  , n)]
						let ep2 = eps[mod(i+1, n)]
						if (edge_is_v(ep1, ep2) != fv) // _|_ edge: invisible
							continue
						if (edge_sign(ep1, ep2) != fs) // back-face edge: obscured: cull it
							continue

						if (fs == -1) // normalize seg direction to aid merging.
							;[ep2, ep1] = [ep1, ep2]

						walls.push([ep1, ep2, floor_plan, comp])

						min_floor = min(min_floor, floor_plan.i)
						max_floor = max(max_floor, floor_plan.i)
					}
				}
			}

			// sort walls by depth.
			walls.sort(function(w1, w2) {
				// 1st level grouping: by depth (asc order).
				let y1 = ep_axis(w1[0])
				let y2 = ep_axis(w2[0])
				let dy = fs * (y1 - y2)
				if (dy) return dy
				// 2nd level grouping: by floor (desc order).
				let l1 = w1[2].i
				let l2 = w2[2].i
				return l2 - l1
			})

			let eq_depth = (w1, w2) => ep_axis(w1[0]) == ep_axis(w2[0])
			let eq_floor = (w1, w2) => w1[2] == w2[2]

			// create face polygons by merging the faces that are on the same vertical plane.
			for (let [j1, j2] of group_sorted(walls, eq_depth)) {

				// 1st level grouping: j1,j2 is all walls of a single depth plane.

				let segs = []
				let y = 0

				function add_seg(x1, y1, x2, y2, ep1, ep2) {
					let p1 = [x1, y1]
					let p2 = [x2, y1]
					let seg = [p1, p2]
					segs.push(seg)
					// set back refs to origin eps for quick updating
					p1.ep1 = ep1
					p2.ep2 = ep2
				}

				let last_i1, last_i2
				for (let [i1, i2] of group_sorted(walls, eq_floor, j1, j2)) {

					// 2nd level grouping: i1,i2 is all walls of a single floor of this depth plane.

					let floor_plan = walls[i1][2]
					let floor = floor_plan.i
					let h = floor_plan.h
					let y1 = y
					let y2 = y + h

					for (let i = i1; i < i2; i++) {

						// make vertical segments
						let [ep1, ep2] = walls[i]
						let x1 = ep_m(ep1)
						let x2 = ep_m(ep2)
						add_seg(x1, y1, x2, y2, ep1, ep2)

						// for top and bottom floors, make top and bottom segments too.
						if (floor == min_floor || floor == max_floor) {
							let y = floor == min_floor ? y2 : y1
							add_seg(x1, y, x2, y, ep1, ep2)
						}
					}

					// merge segments between this floor and the last floor.
					// adding all end-points from the segments of both floors
					// and sorting them gives us exactly the segments we want,
					// no analyzing intersections necessary.
					if (last_i1 != null) {

						let a = []

						for (let i = i1; i < i2; i++)
							a.push(walls[i][0], walls[i][1])
						for (let i = last_i1; i < last_i2; i++)
							a.push(walls[i][0], walls[i][1])

						a.sort((ep1, ep2) => ep_m(ep1) - ep_m(ep2))

						for (let i = 0, n = a.length; i < n; i += 2) {
							let ep1 = a[i]
							let ep2 = a[i+1]
							let x1 = ep_m(ep1)
							let x2 = ep_m(ep2)
							if (x1 != x2)
								add_seg(x1, y2, x2, y2, ep1, ep2)
						}

					}

					y += h
					last_i1 = i1
					last_i2 = i2
				}

				let plan = plan2d({segs: segs, gen_id: gen_id})
				push_log()
				plan.init()
				pop_log('FACE PLAN {0}/{1} {2} {3}..{4}', face, plans.length, ep_axis(walls[j1][0]), j1, j2)
				plans.push(plan)


			}

		}

		function wall_face_rect(plan, lv, wr, i, scale) {
			let h = pix(lv.h, scale)
			let v  = wall_vert(wr, i)
			let p1 = wall_p1(wr, i+0, true, null, scale)
			let p2 = wall_p1(wr, i+1, true, null, scale)
			let X = v ? 1 : 0
			let Y = v ? 0 : 1
			let x1 = p1[X]
			let x2 = p2[X]
			let x = min(x1, x2)
			let w = max(x1, x2) - x
			let y = 0
			return [x, y, w, h, p1[Y]] // (x, y, w, h, z)
		}

		create_face_plans()

		return face_view
	}

	function face_bb(vert) { // returns (x1, y1, x2, y2, min_depth, max_depth)
		let [x1, y1, x2, y2] = house_plan.bb
		let h = 0
		for (let floor_plan of house_plan.floor_plans)
			h += floor_plan.h
		if (vert)
			return [y1, 0, y2, h]
		else
			return [x1, 0, x2, h]
	}
	house_plan.face_bb = face_bb

	// init house_plan --------------------------------------------------------

	push_log()

	for (let i = 0, n = t.floors.length; i < n; i++)
		house_plan.floor_plans[i] = floor_plan(t.floors[i], i)

	for (let i = 1; i <= 4; i++)
		house_plan.face_views = face_view(i)

	house_plan.bb = house_plan_bb()

	pop_log('PLAN LOADED')
	pr_log()

	return house_plan

}

// shared scale --------------------------------------------------------------

function scaler() {
	let s = {}
	let line_width = 2 // thickness of wall line stroke in pixels at 1:1 scale
	let scale, margin
	s.d = d => round(d * scale)
	s.x = x => round(x * scale)
	s.y = y => round(y * scale)
	s.plan_x = x => x / scale
	s.plan_y = y => y / scale
	s.plan_d = d => d / scale
	s.ep_x = e => s.x(e.p[0]) + s.d(e[0])
	s.ep_y = e => s.y(e.p[1]) + s.d(e[1])
	s.transform = function(cx, w, h) {
		if (s.rotation) {
			let xc = round(w / 2)
			let yc = round(h / 2)
			cx.translate(xc, yc)
			cx.rotate(s.rotation)
			cx.translate(-xc, -yc)
		}
		cx.translate(s.x0, s.y0)
	}
	function set_scale(sc) {
		scale = sc
		s.scale = sc
		// snap line width to an even number for sharpness
		s.line_width = snap(line_width * sc, 2)
	}
	let bb = bbox()
	s.scale_to_fit = function(bb1, w, h) {
		if (s.zoomed) return
		let margin = ceil(ui.em(2) + line_width)
		w -= 2 * margin
		h -= 2 * margin
		array_set(bb, bb1)
		bbox_rotate(bb, s.rotation)
		let [x1, y1, x2, y2] = bb
		let bw = x2 - x1
		let bh = y2 - y1
		set_scale(min(
			scale,
			w / bw,
			h / bh
		))
		if (!s.panned) {
			// in pixels from widget's origin
			s.x0 = -s.x(x1) + margin + round((w - s.d(x2 - x1)) / 2)
			s.y0 = -s.y(y1) + margin + round((h - s.d(y2 - y1)) / 2)
		}
	}
	s.set_scale = function(sc) {
		if (s.zoomed) return
		set_scale(sc)
	}
	s.zoom = function(d, xc, yc) { // zoom around (xc,yc) pixels from widget's origin
		if (!d) return
		d /= 150
		d *= 1.2

		let plan_xt = s.plan_x(-s.x0 + xc)
		let plan_yt = s.plan_y(-s.y0 + yc)

		set_scale(clamp(abs(scale * (d < 0 ? 1 / d : d)), 0.1, 10))

		// TODO: rotate

		let xt = s.x(plan_xt)
		let yt = s.y(plan_yt)

		s.x0 = -(xt - xc)
		s.y0 = -(yt - yc)

		s.zoomed = true
	}
	s.reset_zoom = function() {
		s.zoomed = false
		s.panned = false
	}
	return s
}

let scale_group = memoize(name => scaler())

// plan view -----------------------------------------------------------------

function draw_grid(cx, sg, x0, y0, w, h, step, dark_color, light_color) {
	if (!sg.show_grid)
		return
	if (sg.d(step) < 7)
		return
	let color = ui.dark() ? dark_color : light_color
	cx.strokeStyle = color
	for (let i = mod(sg.plan_x(x0), step), n = sg.plan_d(w); i < n; i += step) {
		cx.beginPath()
		cx.moveTo(sg.x(i), 0)
		cx.lineTo(sg.y(i), h-1)
		cx.stroke()
	}
	for (let i = mod(sg.plan_y(y0), step), n = sg.plan_d(h); i < n; i += step) {
		cx.beginPath()
		cx.moveTo(0, sg.x(i))
		cx.lineTo(w-1, sg.y(i))
		cx.stroke()
	}
}

function draw_edges(cx, sg, eps) {
	for (let ep of eps) {
		let x = sg.ep_x(ep)
		let y = sg.ep_y(ep)
		if (ep == eps[0])
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()
}

function draw_walls(cx, sg, comps, segs) {
	for (let comp of comps) {

		cx.beginPath()

		for (let c of comp.cycles) {
			if (!c.edges)
				continue
			draw_edges(cx, sg, c.edges)
		}

		if (!cx.wall_pattern) {
			let w = 100
			let c = new OffscreenCanvas(w, w)
			let x = c.getContext('2d')
			let g = x.createLinearGradient(0, 0, w, 2*w)
			for (let i = 0, n = 2*w; i <= n; i += 4) {
				g.addColorStop(clamp((i - 1) / n, 0, 1), 'white')
				g.addColorStop(clamp((i + 0) / n, 0, 1), 'gray')
				g.addColorStop(clamp((i + 1) / n, 0, 1), 'white')
			}
			x.rect(0, 0, w, w)
			x.fillStyle = g
			x.fill()
			cx.wall_pattern = cx.createPattern(c, 'repeat')
		}
		if (sg.scale > 0.4) {
			cx.fillStyle = DEBUG_PLAN ? '#333' : cx.wall_pattern
			cx.fill('nonzero')
			cx.lineWidth = DEBUG_PLAN ? 2 : sg.line_width
			cx.strokeStyle = 'black' //ui.fg_color('text')
			cx.lineJoin = 'round'
			cx.stroke()
			cx.lineJoin = 'miter'
			cx.lineWidth = 1
		} else if (sg.scale > 0.2) { // too small to stroke
			cx.fillStyle = ui.fg_color('text')
			cx.fill()
		} else { // to small to even show edges
			for (let seg of segs) {
				let x1 = sg.x(seg[0][0]) + .5
				let y1 = sg.y(seg[0][1]) + .5
				let x2 = sg.x(seg[1][0]) + .5
				let y2 = sg.y(seg[1][1]) + .5
				cx.beginPath()
				cx.moveTo(x1, y1)
				cx.lineTo(x2, y2)
				cx.strokeStyle = ui.fg_color('text')
				cx.stroke()
			}
		}
	}
}

// evaluate a line at time t using linear interpolation.
// the time between 0..1 covers the segment interval.
function point_on_line(t, x1, y1, x2, y2) {
	out[0] = x1 + t * (x2 - x1)
	out[1] = y1 + t * (y2 - y1)
	return out
}
function draw_length(cx, sg, x1, y1, x2, y2) {

	let d = distance(x1, y1, x2, y2)
	if (sg.d(d) < 20)
		return

	let s = format_length(d)

	x1 = sg.x(x1)
	y1 = sg.y(y1)
	x2 = sg.x(x2)
	y2 = sg.y(y2)

	if (x1 > x2) {
		let x3 = x1
		let y3 = y1
		x1 = x2
		y1 = y2
		x2 = x3
		y2 = y3
	}
	let a = atan2(y2 - y1, x2 - x1)

	cx.save()

	cx.font = 'bold 14px sans-serif'
	let m = ui.measure_text(cx, '0.00m')
	let w = m.width

	let t1 = clamp((sg.d(d) - (w + 10)) / 2 / sg.d(d), 0, 1)
	let t2 = clamp((sg.d(d) + (w + 10)) / 2 / sg.d(d), 0, 1)

	if (!(t1 > 0 && t2 < 1)) {
		s = '...'
		w = 10
	}

	cx.translate(.5, .5)

	cx.beginPath()

	// left arrow
	let [x1a1, y1a1] = point_around(x1, y1, 8, a + 45*rad)
	let [x1a2, y1a2] = point_around(x1, y1, 8, a - 45*rad)
	let [x1e, y1e] = point_on_line(t1, x1, y1, x2, y2)

	cx.moveTo(x1  , y1)
	cx.lineTo(x1a1, y1a1)
	cx.moveTo(x1  , y1)
	cx.lineTo(x1a2, y1a2)
	cx.moveTo(x1  , y1)
	cx.lineTo(x1e , y1e)

	// right arrow
	let [x2a1, y2a1] = point_around(x2, y2, 8, a + (90+45)*rad)
	let [x2a2, y2a2] = point_around(x2, y2, 8, a - (90+45)*rad)
	let [x2e, y2e] = point_on_line(t2, x1, y1, x2, y2)
	cx.moveTo(x2  , y2)
	cx.lineTo(x2a1, y2a1)
	cx.moveTo(x2  , y2)
	cx.lineTo(x2a2, y2a2)
	cx.moveTo(x2  , y2)
	cx.lineTo(x2e , y2e)

	cx.strokeStyle = ui.fg_color('text')
	cx.stroke()

	let [xc, yc] = point_on_line(.5, x1, y1, x2, y2)
	cx.translate(xc, yc)
	cx.rotate(a)
	let tx = round(-w / 2)
	let ty = round((m.fontBoundingBoxAscent - m.fontBoundingBoxDescent) / 2)
	cx.translate(tx, ty)
	cx.fillStyle = ui.fg_color('text')
	cx.fillText(s, 0, 0)

	cx.restore()
}

let PLAN_VIEW_ID         = ui.S-1
let PLAN_VIEW_DRAW_STATE = ui.S+0

ui.box_widget('plan_view', {

	create: function(cmd, id, plan, fr, align, valign, min_w, min_h) {

		let s = ui.state(id)
		let draw_state = s.get('draw_state')
		if (!draw_state) {
			draw_state = {snap_lines: [], measure_edges: [], above_floors: [], below_floors: []}
			s.set('draw_state', draw_state)
		}
		s.set('plan', plan)

		let [dstate, dx, dy] = ui.drag(id)

		let sg = scale_group('editor')

		dx /= sg.scale
		dy /= sg.scale

		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {

			let hs = ui.hover(id)
			let cs = ui.captured(id)

			if (dstate == 'drag') {

				let action = hs.get('action')
				let seg    = hs.get('seg')
				let p      = hs.get('p')

				if (action == 'move_seg') { // move seg
					cs.set('move_seg', plan.start_move_seg(seg, draw_state))
				} else if (action == 'pan') {
					sg.pan_x0 = sg.x0
					sg.pan_y0 = sg.y0
					cs.set('action', action)
				}
			}

			let action = cs.get('action')

			if (!action && (abs(dx) >= 10 || abs(dy) >= 10)) { // dragged far enough to assume intent to drag.

				// establish direction of drag on x and y axis.
				let sdx = abs(dx) > 1.5 * abs(dy) ? sign(dx) : 0 // straight enough
				let sdy = abs(dy) > 1.5 * abs(dx) ? sign(dy) : 0 // straight enough
				if (sdx || sdy) {
					action = 'resize_seg'
					cs.set('action', action)
					let p   = cs.get('p')
					let mx0 = cs.get('x')
					let my0 = cs.get('y')
					let s = plan.start_resize_seg(p, mx0, my0, dx, dy, sdx, sdy, draw_state)
					cs.set('resize_seg', s)
				}

			}

			if (action == 'move_seg')
				cs.get('move_seg').move(dx, dy, draw_state)

			if (action == 'resize_seg')
				cs.get('resize_seg').resize(dx, dy, draw_state, hs)

			if (action == 'pan') {
				sg.x0 = sg.pan_x0 + sg.d(dx)
				sg.y0 = sg.pan_y0 + sg.d(dy)
				sg.panned = true
			}

			if (dstate == 'drop') {
				if (action == 'move_seg') {
					cs.get('move_seg').stop(draw_state, ui.dblclick)
				} else if (action == 'resize_seg') {
					cs.get('resize_seg').stop(draw_state)
				}
			}

		}

		ui.stack()

			ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
					id, draw_state,
				)

			ui.m(ui.sp())
			ui.v(1, ui.sp())

				ui.h(0, ui.sp05(), 's', 't')

					ui.bold()
					ui.text('', floor_names[plan.i] ?? S(plan.i+'_floor', '{0}ᵗʰ FLOOR', plan.i))

					if (!ui.window_focused) {
						ui.p(ui.sp05(), 0)
						ui.stack('', 0, '[')
							ui.font('far')
							ui.nobold()
							ui.xlarge()
							ui.color('text')
							ui.text('', '\uf11c', 0, 'c', 'c')
							ui.polyline('', '0 5  35 20', 1, null, null, 'text', null, 2)
						ui.end_stack()
					}

					ui.v(1); ui.end()

					if (sg.zoomed) {
						if (ui.icon_button(id+'.zoom_button', 'fas', sg.scale > 1 ? '\uf00e' : '\uf010', 0, ']')) {
							sg.reset_zoom()
							ui.redraw()
						}
					}

					if (ui.icon_button(id+'.rotate_button', 'fas', '\uf2f1', 0)) {
						sg.rotation = ((sg.rotation ?? 0) + 90*rad) % (360*rad)
						ui.animate()
					}

					if (ui.icon_button(id+'.grid_button', 'fas', '\uf00a', 0)) {
						sg.show_grid = !sg.show_grid
						ui.animate()
					}

				ui.end_h()

				ui.button_stack('', 0, ']')
				ui.button_bb()

					ui.v(0, ui.sp())

						{
						let state = ui.button_state(id+'.c1')
						ui.button_icon('fas', '\uf245', state)
						}

						{
						let state = ui.button_state(id+'.c2')
						ui.button_icon('fas', '\uf0b2', state)
						}

					ui.end_v()

				ui.end_button_stack()

			ui.end_v()

		ui.end_stack()

	},

	after_position: function(a, i, axis)	{
		let sg = scale_group('editor')
		if (!axis) {
			sg.set_scale(1/0)
			return
		}
		let w  = a[i+2]
		let h  = a[i+3]
		let id = a[i+PLAN_VIEW_ID]
		let plan = ui.state(id).get('plan')
		sg.scale_to_fit(plan.house_plan.bb, w, h)
	},

	after_translate: function(a, i) {
		let x00 = a[i+0]
		let y00 = a[i+1]
		let id = a[i+PLAN_VIEW_ID]
		let draw_state = a[i+PLAN_VIEW_DRAW_STATE]

		let sg = scale_group('editor')
		let plan = ui.state(id).get('plan')

		draw_state.x0 = sg.x0
		draw_state.y0 = sg.y0
		draw_state.scale = sg.scale
		draw_state.rotation = sg.rotation

		// pick what parts of the plan to send over the network for drawing
		// and in which format. note that the plan has arrays with props but
		// the props will not be sent over because of how json works.
		draw_state.comps = plan.comps
		draw_state.segs = plan.segs // TODO: remove this from draw stream
		draw_state.ps = plan.ps // TODO: remove this from draw stream
		draw_state.plan_snap_lines = plan.snap_lines

		draw_state.above_floors.length = 0
		draw_state.below_floors.length = 0
		for (let plan1 of plan.house_plan.floor_plans) {
			if (plan1 == plan)
				continue
			let t = {comps: plan1.comps, segs: plan1.segs}
			let a = plan1.i > plan.i ? draw_state.above_floors : draw_state.below_floors
			a.push(t)
		}

	},

	draw: function(a, i) {

		let x00   = a[i+0]
		let y00   = a[i+1]
		let w     = a[i+2]
		let h     = a[i+3]
		let id    = a[i+PLAN_VIEW_ID]
		let draw_state = a[i+PLAN_VIEW_DRAW_STATE]
		let x0 = draw_state.x0
		let y0 = draw_state.y0

		x00 += ui.focused(id) ? 100 : 0

		let hs = ui.hit(id)
		let cs = ui.captured(id)
		let hit_action  = hs?.get('action')
		let hit_seg     = hs?.get('seg')
		let hit_p       = hs?.get('p')
		let hit_cycle   = hs?.get('cycle')
		let hit_x       = hs?.get('x')
		let hit_y       = hs?.get('y')
		let drag_action = cs?.get('action')
		let drag_seg    = cs?.get('seg')

		let sg = scale_group('editor')
		sg.set_scale(draw_state.scale)
		sg.rotation = draw_state.rotation

		let cx = ui.cx
		cx.save()

		cx.beginPath()
		cx.rect(x00, y00, w, h)
		cx.clip()

		cx.translate(x00, y00)
		cx.font = 'bold 14px sans-serif'

		// fixed grid
		cx.save()
		cx.translate(.5, .5)
		// TODO: make this dynamic; show at most 3-levels based on zoom level
		// with dynamic lightness based on level.
		if (0) {
		for (let i = 0; i < 3; i++) {
			let step = (i == 0 ? 1 : i == 1 ? 5 : 10)
			let L = ui.dark() ? 1 : 0
			draw_grid(cx, sg, x0, y0, w, h,  10, hsl(0, 0, L))
		}
		}
		draw_grid(cx, sg, x0, y0, w, h,  10, '#222'   , '#eee')
		draw_grid(cx, sg, x0, y0, w, h,  50, '#282828', '#ddd')
		draw_grid(cx, sg, x0, y0, w, h, 100, '#333'   , '#ccc')
		cx.restore()

		// legend
		{
		let m = ui.em()
		let cm = 100
		let d = sg.d(cm)
		while (d > w - 2*m) {
			cm /= 5
			d = sg.d(cm)
		}
		cx.beginPath()
		let t = 4
		let x = w - d - m - t
		let y = h - m - t
		cx.rect(x, y, d, t)
		cx.fillStyle = ui.fg_color('label')
		cx.fill()
		let s = format_length(cm)
		let tw = ui.measure_text(cx, s).width
		cx.fillText(s, x + d - tw, y - 2)
		}

		// help
		{
		let m = ui.em()
		cx.fillStyle = ui.fg_color('label')
		let s = 'CTRL=No Snap  SHIFT=Pan'
		cx.fillText(s, m, h - m)
		}

		sg.transform(cx, w, h)

		// below floors
		cx.globalAlpha = .1
		for (let plan1 of draw_state.below_floors)
			draw_walls(cx, sg, plan1.comps, plan1.segs)
		cx.globalAlpha = 1

		// snap lines
		cx.setLineDash([5, 8])
		cx.strokeStyle = ui.dark() ? '#555' : '#999'
		for (let i = 0, sl = draw_state.snap_lines, n = sl.length; i < n; i += 2) {
			let sa   = sl[i]
			let is_v = sl[i+1]
			let x1, y1, x2, y2
			if (is_v) {
				x1 = sg.x(sa)
				x2 = sg.x(sa)
				y1 = -draw_state.y0
				y2 = -draw_state.y0 + h
			} else {
				y1 = sg.y(sa)
				y2 = sg.y(sa)
				x1 = -draw_state.x0
				x2 = -draw_state.x0 + w
			}
			cx.beginPath()
			cx.moveTo(x1+.5, y1+.5)
			cx.lineTo(x2+.5, y2+.5)
			cx.stroke()
		}
		cx.setLineDash([])

		// room backgrounds
		for (let co of draw_state.comps) {
			for (let c of co.cycles) {
				if (c.outer)
					continue
				if (!c.edges)
					continue

				cx.beginPath()

				draw_edges(cx, sg, c.edges)

				// island outer cycles are clockwise so they draw as holes.
				for (let icomp of c.islands)
					draw_edges(cx, sg, icomp.outer_cycle.edges)

				cx.fillStyle = ui.alpha_adjust(ui.bg_color_hsl('bg1', hit_cycle == c ? 'hover' : null), .5)
				cx.fill()
			}
		}

		// walls of this floor
		draw_walls(cx, sg, draw_state.comps, draw_state.segs)

		// walls of above floor
		cx.globalAlpha = .1
		for (let plan1 of draw_state.above_floors)
			draw_walls(cx, sg, plan1.comps, plan1.segs)
		cx.globalAlpha = 1

		// cycles area
		if (sg.scale > 0.4)
			for (let co of draw_state.comps) {
				for (let c of co.cycles) {
					if (c.outer)
						continue
					let [x, y] = c.area_pos
					x = sg.x(x)
					y = sg.y(y)
					cx.fillStyle = ui.fg_color('label')
					let s = format_area(c.edges.area)
					if (DEBUG_PLAN) s = co.i + '/' + c.i + ' ' + s
					cx.fillText(s, x, y+5)
				}
			}

		// edge measurements
		let me = draw_state.measure_edges
		if (me) {
			for (let [ep1, ep2] of me) {
				let x1 = ep_x(ep1)
				let y1 = ep_y(ep1)
				let x2 = ep_x(ep2)
				let y2 = ep_y(ep2)
				;[x1, y1, x2, y2] = line_offset(-10, x1, y1, x2, y2, [])
				draw_length(cx, sg, x1, y1, x2, y2)
			}
		}

		// hit point
		if (hit_x != null && hit_y != null) {
			let x = sg.x(hit_x)
			let y = sg.y(hit_y)
			cx.beginPath()
			cx.arc(x, y, 3, 0, 2*PI)
			cx.strokeStyle = 'black'
			cx.lineWidth = 3
			cx.stroke()
			cx.lineWidth = 1
			cx.fillStyle = 'white'
			cx.fill()
		}

		// orthogonal measurements
		if (0)
		for (let i = 0; i < 2; i++) {
			for (let m of draw_state.plan_snap_lines[i]) {
				let x = sg.x(i == 0 ? m : -50)
				let y = sg.y(i == 1 ? m : -20)
				cx.save()
				cx.translate(x, y)
				//if (i == 0)
					cx.rotate(-PI/4)
				cx.fillStyle = 'white' //ui.fg_color('label')
				cx.strokeStyle = 'black'
				cx.shadowBlur = 4
				cx.shadowColor = 'black'
				let s = format_length(m)
				cx.fillText(s, 0, 0)
				cx.restore()
			}
		}

		// cursor
		let seg = drag_action == 'move_seg' && drag_seg || (hit_action == 'move_seg' && hit_seg)
		if (seg) {
			if (seg[0].segs.length == 1 && seg[1].segs.length == 1)
				ui.set_cursor('move')
			else
				ui.set_cursor(is_v(seg) ? 'ew-resize' : 'ns-resize')
		} else if (hit_p)
			ui.set_cursor('copy')
		else if (drag_action == 'pan')
			ui.set_cursor('grabbing')
		else if (hs) {
			if (hit_action == 'pan')
				ui.set_cursor('grab')
			else
				ui.set_cursor('copy')
		}

		// DEBUG ---------------------------------------------------------------

		// segment lines and segment numbers
		if (DEBUG_PLAN)
		for (let seg of draw_state.segs) {
			let p1 = seg[0]
			let p2 = seg[1]
			cx.beginPath()
			let x1 = sg.x(p1[0])
			let y1 = sg.y(p1[1])
			let x2 = sg.x(p2[0])
			let y2 = sg.y(p2[1])
			cx.moveTo(x1, y1)
			cx.lineTo(x2, y2)
			cx.strokeStyle = hit_seg == seg ? 'white' : '#666'
			cx.stroke()

			let [x0, y0] = seg_center(seg)
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = '#f66'
			cx.fillText(seg.i, x, y)
		}

		// point numbers
		if (DEBUG_PLAN)
		for (let p of draw_state.ps) {
			let [x0, y0] = p
			let x = sg.x(x0) - 5
			let y = sg.y(y0) + 5
			cx.fillStyle = 'white'
			cx.fillText(p.i, x, y)
		}

		// edge point numbers
		if (0 && DEBUG_PLAN)
		for (let c of draw_state.comps) {
			let co = c // no var shadowing because langauge designers are dumb
			for (let c of co.cycles) {
				for (let ep of c.edges) {
					let x = sg.ep_x(ep) - 5
					let y = sg.ep_y(ep) + 15
					cx.fillStyle = '#0f0'
					cx.fillText(c.i+'/'+ep.ci, x, y)
				}
			}
		}

		cx.restore()
	},

	/*	sets in hovers(id):
		action=pan                 shift pressed, pan, don't hit anything
		p                          hit joint
		seg, action=move_seg       hit segment
		seg, x or y                hit around segment along its length
		x and/or y                 hit vert and/or horiz snap line
		cycle                      inside inner cycle
	*/
	hit: function(a, i) {

		let x00 = a[i+0]
		let y00 = a[i+1]
		let w   = a[i+2]
		let h   = a[i+3]
		let id  = a[i+PLAN_VIEW_ID]
		let draw_state = a[i+PLAN_VIEW_DRAW_STATE]

		if (ui.captured_id != null && !ui.clickup)
			return

		if (!ui.hit_box(a, i))
			return

		let hs = ui.hover(id)
		if (!hs)
			return

		let sl = draw_state.snap_lines
		sl.length = 0

		let sg = scale_group('editor')

		let cx = ui.cx

		let pan    = ui.key('shift')
		let nosnap = ui.key('control')

		sg.zoom(ui.wheel_dy,
			ui.mx - x00,
			ui.my - y00
		)

		if (pan) {
			hs.set('action', 'pan')
			return
		}

		let plan = ui.state(id).get('plan')

		cx.save()
		cx.translate(x00, y00)
		sg.transform(cx, w, h)
		ui.update_mouse()

		let mx = sg.plan_x(ui.mx)
		let my = sg.plan_y(ui.my)

		let snap_margin = 15

		let hit_p, hit_seg, hit_action, hit_cycle

		for (let p of draw_state.ps) {
			let dx = ui.mx - sg.x(p[0])
			let dy = ui.my - sg.y(p[1])
			let snap_d = nosnap ? 2 : sg.d(p.max_offset) + sg.line_width + snap_margin
			if (abs(dx) <= snap_d && abs(dy) <= snap_d) {
				hit_p = p
				hs.set('p', p) // point to start new seg from
				hs.set('x', p[0])
				hs.set('y', p[1])
				sl.push(p[0], 1, p[1], 0)
				break
			}
		}

		if (!hit_p)
			for (let seg of draw_state.segs) {

				let x1 = seg[0][0]
				let y1 = seg[0][1]
				let x2 = seg[1][0]
				let y2 = seg[1][1]
				let v = is_v(seg)

				let sx1, sy1, sx2, sy2 // screen hit box

				// test over the seg's area between its offset edges.
				let m = sg.line_width
				if (v) {
					let x = x1
					sx1 = sg.x(x + seg[y1 < y2 ? -2 : -1]) - m
					sx2 = sg.x(x - seg[y1 < y2 ? -1 : -2]) + m
					sy1 = sg.y(seg_y1(seg))
					sy2 = sg.y(seg_y2(seg))
				} else if (y1 == y2) {
					let y = y1
					sy1 = sg.y(y + seg[x1 > x2 ? -2 : -1]) - m
					sy2 = sg.y(y - seg[x1 > x2 ? -1 : -2]) + m
					sx1 = sg.x(seg_x1(seg))
					sx2 = sg.x(seg_x2(seg))
				} else {
					continue
				}
				if (ui.hit_bb(sx1, sy1, sx2, sy2)) {
					hit_seg = seg
					hit_action = 'move_seg'
					hs.set('seg', seg)
					hs.set('action', hit_action)
					break
				}

				// try a wider area and compute the point of the mouse projected on the seg.
				if (v) {
					sx1 -= snap_margin
					sx2 += snap_margin
				} else {
					sy1 -= snap_margin
					sy2 += snap_margin
				}
				if (ui.hit_bb(sx1, sy1, sx2, sy2)) {
					hit_seg = seg
					hs.set('seg', seg)
					let sx = !v ? plan.snap_x(mx, nosnap) ?? mx : null
					let sy = v  ? plan.snap_y(my, nosnap) ?? my : null
					hs.set('x', sx ?? x1)
					hs.set('y', sy ?? y1)
					if (sx != null) sl.push(sx, 1)
					if (sy != null) sl.push(sy, 0)
					break
				}

			}

		// hit snapping point
		if (!hit_p && !hit_seg) {
			let sx = plan.snap_x(mx, nosnap)
			let sy = plan.snap_y(my, nosnap)
			hs.set('x', sx ?? mx)
			hs.set('y', sy ?? my)
			if (sx != null) sl.push(sx, 1)
			if (sy != null) sl.push(sy, 0)
		}

		// hit inner cycle
		if (!hit_p && !hit_seg) {
			hit_cycle = plan.hit_cycles(mx, my)
			if (hit_cycle)
				hs.set('cycle', hit_cycle)
		}

		cx.restore()
		ui.update_mouse()

	},

})

// face view -----------------------------------------------------------------

let FACE_VIEW_ID   = ui.S-1
let FACE_VIEW_PLAN = ui.S+0
let FACE_VIEW_FACE = ui.S+1

ui.box_widget('face_view', {

	create: function(cmd, id, house_plan, face, fr, align, valign, min_w, min_h) {

		let s = ui.state(id)
		let draw_state = s.get('draw_state')
		if (!draw_state) {
			draw_state = {snap_lines: [], measure_edges: []}
			s.set('draw_state', draw_state)
		}
		s.set('house_plan', house_plan)

		let [dstate, dx, dy] = ui.drag(id)

		let sg = scale_group('editor')

		dx /= sg.scale
		dy /= sg.scale

		return ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
				id, house_plan, face
			)
	},

	/*
	after_position: function(a, i, axis)	{
		let sg = scale_group('editor')
		if (!axis) {
			sg.set_scale(1/0)
			return
		}
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let face = a[i+FACE_VIEW_FACE]
		let house_plan = ui.state(id).get('house_plan')
		let v = face_is_v(face)
		sg.scale_to_fit(house_plan.face_bb(v), w, h)
	},
	*/

	draw: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let plan = a[i+FACE_VIEW_PLAN]
		let face = a[i+FACE_VIEW_FACE]

		// face is 1,2,3,4 going clockwise from the left-to-right face.
		let v = face_is_v(face)
		let face_sign = face <= 2 ? 1 : -1

		return

		let hs = ui.hit(id)

		let cx = ui.cx

		cx.beginPath()

		cx.save()

		cx.translate(x00, y00)
		cx.translate(-face_x, -face_y)

		let walls = sort_face_walls(plan, face)

		for (let floor_num = plan.floors.length-1; floor_num >= 0; floor_num--) {

			let lv = plan.floors[floor_num]
			let h = pix(lv.h, scale)

			// draw walls (offset face) in depth order.
			let X = v ? 1 : 0
			let Y = v ? 0 : 1
			for (let [wr, i] of walls) {

				if ((wr.floor ?? 0) != floor_num)
					continue

				let [x, y, w, h, z] = wall_face_rect(plan, lv, wr, i, scale)

				let depth = lerp(z, min_depth * scale, max_depth * scale, 0, 1)

				cx.beginPath()
				cx.rect(x, y, w, h)
				cx.fillStyle = ui.hsl_adjust(ui.bg_color_hsl('bg3'), 1, 1, depth, 1 - depth/4)
				cx.fill()

				cx.beginPath()
				cx.rect(x + .5, .5, w, h)
				cx.strokeStyle = ui.fg_color('text')
				cx.stroke()

				// draw openings.
				let wall = wr.walls[i]
				let ops = wall.openings
				if (ops) {
					for (let op of ops) {

						let [x, y, w, h] = opening_face_rect(op, wr, i, lv, scale)

						cx.save()
						cx.translate(x, y)

						cx.beginPath()
						cx.rect(0, 0, w, h)
						cx.fillStyle = ui.bg_color('bg')
						cx.fill()

						let op_class = comp[op.type]
						op_class.draw_face(cx, op, w, h, hs)

						cx.restore()
					}
				}

			}

			cx.translate(0, h)

		}

		cx.restore()

	},

	hit: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+FACE_VIEW_ID]
		let plan = a[i+FACE_VIEW_PLAN]
		let face = a[i+FACE_VIEW_FACE]

		return

		// face is 1,2,3,4 going clockwise from the left-to-right face.
		let face_vert = (face-1) & 1
		let face_sign = face <= 2 ? 1 : -1

		let hs = ui.hit(id)
		let cs = ui.captured(id)

		if (!cs) {

			let [scale, face_x, face_y] = face_scale(plan, face_vert, w, h)

			let cx = ui.cx

			cx.save()
			cx.translate(x00, y00)
			cx.translate(-face_x, -face_y)
			ui.update_mouse()

			let walls = sort_face_walls(plan, face_vert, face_sign)
			walls.reverse()

			let y = 0
			for (let floor_num = plan.floors.length-1; floor_num >= 0; floor_num--) {

				let lv = plan.floors[floor_num]

				if (hit_face(plan, lv, floor_num, walls, id, scale, true))
					break

				y += pix(lv.h, scale)
				cx.translate(0, y)
				ui.update_mouse()
			}

			cx.restore()
			ui.update_mouse()

		}

	},

})

// test UI -------------------------------------------------------------------

G.test_plan = house_plan({

	floor_h: 250,
	floors: [
		{
			segs: [
				// outside rect
				[[0,0],[500,0]],
				[[500,0],[500,500]],
				[[500,500],[0,500]],
				[[0,500],[0,0]],

				[[0,300],[500,300]],
				[[0,200],[300,200]],
				[[200,0],[200,400]],

				// peninsula
				[[300,200],[300,100]],
				[[300,100],[400,100]],
				[[400,100],[400,200]],
				[[400,200],[300,200]],

				[[200,400],[300,400]],

				[[500,300],[600,300]],
				[[600,300],[600,400],],
				[[600,300],[700,300]],

				// brick-like-layout for testing seg detach on seg move

				// [[700,500],[700,1000]],
				// [[700,1000],[1200,1000]],
				// [[1200,1000],[1200,500]],
				// [[1200,500],[700,500]],
				// [[900,500],[900,1000]],
				// [[700,600],[900,600]],
				// [[700,800],[900,800]],
				// [[900,700],[1200,700]],
			],
		},
		{
			segs: [
				[[100,300],[600,300]],
				[[100,300],[100,100]],

				// island for testing inside check

				[[0,600],[600,600]],
				[[600,600],[600,1000]],
				[[600,1000],[0,1000]],
				[[0,1000],[0,600]],

				[[100,650],[350,650]],
				[[350,650],[350,900]],
				[[350,900],[100,900]],
				[[100,900],[100,650]],

				[[150,700],[200,700]],
				[[200,700],[200,800]],
				[[200,800],[150,800]],
				[[150,800],[150,700]],

				[[300,700],[250,700]],
				[[250,700],[250,800]],
				[[250,800],[300,800]],
				[[300,800],[300,700]],

			],
		},
	],

})

ui.main = function() {

	ui.m(20)

	ui.v()

		ui.h(0, ui.sp05())

			if (ui.button('debug_plan_button', 'DEBUG', 0))
				DEBUG_PLAN = !DEBUG_PLAN

			if (ui.button('btn_light', 'lights', 0))
				ui.default_theme = ui.default_theme == 'light' ? 'dark' : 'light'

		ui.end_h()

		ui.h()

			for (let floor_plan of test_plan.floor_plans) {

			//for (let i = test_plan.floor_plans.length-1; i >= 0; i--) {
				// let floor_plan = test_plan.floor_plans[i]
				ui.m(10)
				ui.stack()
					ui.bb('', null, null, 1, 'light')
					ui.plan_view('pv'+floor_plan.i, floor_plan)
				ui.end_stack()
			}

			ui.v()

				for (let face = 1; face <= 4; face++) {
					ui.m(10)
					ui.stack()
						ui.bb('', null, null, 1, 'light')
						ui.face_view('fv'+face, test_plan, face)
					ui.end_stack()
				}

			ui.end_v()

		ui.end_h()

	ui.end_v()

}

DEBUG_PLAN = 0

}()) // module function

</script>
</body>
</html>
