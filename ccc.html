<!DOCTYPE html>
<html theme=dark>
<body>
<base href="www/">
<link rel="preload" href="fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="fa-solid-900.woff2"   as="font" type="font/woff2" crossorigin>
<script src=glue.js global extend></script>
<script src=ui.js></script>
<script src=ui_validation.js></script>
<script src=ui_nav.js></script>
<script src=ui_grid.js></script>
<script>

function wall_point(ps, i) {
	return ps[mod(i, ps.length)]
}

function wall_is_horiz(ps, i) {
	let p1 = wall_point(ps, i+0)
	let p2 = wall_point(ps, i+1)
	return p1[1] == p2[1]
}

function wall_dir(ps, i) {
	let X = wall_is_horiz(ps, i) ? 0 : 1
	let p1 = wall_point(ps, i+0)
	let p2 = wall_point(ps, i+1)
	return p1[X] < p2[X] ? 1 : -1
}

function wall_offset(ps, i, o) {
	let p0 = wall_point(ps, i-1)
	let p1 = wall_point(ps, i+0)
	let p2 = wall_point(ps, i+1)
	let x0 = p0[0]
	let y0 = p0[1]
	let x1 = p1[0]
	let y1 = p1[1]
	let x2 = p2[0]
	let y2 = p2[1]
	let h1 = y1 == y2
	let h0 = y0 == y1
	let v1 = x1 == x2
	assert(h1 != h0)
	assert(h1 != v1)
	let d1 = h1 ? x1 < x2 : y1 < y2
	let d0 = h0 ? x0 < x1 : y0 < y1
	let ox = 0
	let oy = 0
	if (d1 == d0) {
		ox = d1 ?  1 : -1
		oy = d1 ? -1 :  1
	} else if ((d1 < d0) == h1) {
		ox =  1
		oy =  1
	} else {
		ox = -1
		oy = -1
	}
	return [
		x1 + ox * o,
		y1 + oy * o
	]
}

function wall_offset_dir(ps, i) {
	let p1 = wall_point(ps, i+0)
	let p2 = wall_point(ps, i+1)
	let x1 = p1[0]
	let y1 = p1[1]
	let x2 = p2[0]
	let y2 = p2[1]
	let h = y1 == y2
	let d = h ? x1 < x2 : y1 < y2
	return h ? (d ? -1 : 1) : (d ? 1 : -1)
}

function overlap_segs(_a1, _a2, _b1, _b2) {
	let a1 = min(_a1, _a2)
	let a2 = max(_a1, _a2)
	let b1 = min(_b1, _b2)
	let b2 = max(_b1, _b2)
	return !(a2 <= b1 || b2 <= a1)
}

function wall_lines(ps, i1, o) {
	let p1  = wall_point  (ps, i1+0)
	let p2  = wall_point  (ps, i1+1)
	let op1 = wall_offset (ps, i1+0, o)
	let op2 = wall_offset (ps, i1+1, o)
	let h = p1[1] == p2[1]
	let Y = h ? 1 : 0
	if (p1[Y] > op1[Y])
		return [op1, op2, p1, p2]
	else
		return [p1, p2, op1, op2]
}

function wall_rect(ps, i1, o) {
	let p1 = wall_point(ps, i1+0)
	let p2 = wall_point(ps, i1+1)
	let h = p1[1] == p2[1]
	let op1 = wall_offset(ps, i1+0, o)
	let op2 = wall_offset(ps, i1+1, o)
	let X = h ? 0 : 1
	let Y = h ? 1 : 0
	let r = [0, 0, 0, 0]
	r[X+0] = min(p1[X], op1[X], p2[X], op2[X])
	r[X+2] = max(p1[X], op1[X], p2[X], op2[X])
	r[Y+0] = min(p1[Y], op1[Y])
	r[Y+2] = max(p1[Y], op1[Y])
	return r
}

function opening_rect(plan, op) {
	let t = plan.ext_wall_thickness
	let r = [op.x, op.y, op.w, t, 0]
	let ps = plan.ext_walls
	let rotate = false
	if (op.wall != null) {
		let p1    = wall_point      (ps, op.wall)
		let horiz = wall_is_horiz   (ps, op.wall)
		let dir   = wall_dir        (ps, op.wall)
		let odir  = wall_offset_dir (ps, op.wall)
		let X = horiz ? 0 : 1
		let Y = horiz ? 1 : 0
		r[X] = p1[X] + (dir > 0 ? op.d : -(op.d + op.w))
		r[Y] = p1[Y] + (odir > 0 ? 0 : -t)
		if (!horiz) {
			r[4] = 90 * rad
			r[0] += t
		}
	}
	return r
}

function moving_ranges(plan, ti1) {
	let o = plan.ext_wall_thickness
	let ps = plan.ext_walls
	let n = ps.length
	let ti0 = mod(ti1-1, n)
	let ti2 = mod(ti1+1, n)
	let p1 = ps[ti1]
	let p2 = ps[ti2]
	let h = p1[1] == p2[1]
	let X = h ? 0 : 1
	let Y = h ? 1 : 0
	let tl = wall_lines(ps, ti1, o)

	// collision with walls
	let rangeY = [-1/0, 1/0]
	for (let i1 = 0; i1 < n; i1++) {
		if (i1 == ti1 || i1 == ti0 || i1 == ti2)
			continue
		let r = wall_rect(ps, i1, o)

		if (r[Y+2] <= tl[0][Y]) // rect bottom side < top of the wall
			if (overlap_segs(tl[0][X], tl[1][X], r[X], r[X+2])) {
				let minY = r[Y+2]+1
				if (tl[0][Y] < p1[Y]) // offset side up
					minY += o
				rangeY[0] = max(rangeY[0], minY)
			}

		if (r[Y+0] >= tl[2][Y]) // rect top side > bottom of the wall
			if (overlap_segs(tl[2][X], tl[3][X], r[X], r[X+2])) {
				let maxY = r[Y+0]-1
				if (tl[2][Y] > p1[Y]) // offset side down
					maxY -= o
				rangeY[1] = min(rangeY[1], maxY)
			}

	}
	return [rangeY]
}

function draw_walls(cx, plan, ps, hs) {

	let n = ps.length

	cx.beginPath()

	// draw offset path clockwise.
	for (let i = 0; i < n; i++) {
		let [x, y] = wall_offset(ps, i, plan.ext_wall_thickness)
		if (i == 0)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()

	// draw inner path counterclockwise.
	for (let i = n-1; i >= 0; i--) {
		let x = ps[i][0]
		let y = ps[i][1]
		if (i == n-1)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()

	cx.lineWidth = 1
	cx.strokeStyle = ui.fg_color('text')
	cx.fillStyle = ui.bg_color('bg3')
	cx.fill()
}

function draw_openings(cx, plan, ps, hs) {
	for (let op of plan.openings) {
		let [x, y, w, h, rotation] = opening_rect(plan, op)

		cx.save()
		cx.translate(x, y)
		cx.rotate(rotation)

		cx.beginPath()
		cx.rect(0, 0, w, h)
		cx.fillStyle = ui.bg_color('bg')
		cx.fill()

		if (op.type == 'window') {
			cx.beginPath()
			cx.rect(.5, .5 - 4, w, h + 4)
			cx.moveTo(.5, .5 + round(h / 3))
			cx.lineTo(.5 + w, .5 + round(h / 3))
		} else if (op.type == 'door') {
			cx.beginPath()
			cx.arc(.5, .5 + round(h / 2), .5 + w, 0, 90 * rad)
			cx.lineTo(.5, .5 + round(h / 2))
		}
		cx.strokeStyle = ui.fg_color('text', hs && hs.get('opening') == op ? 'hover' : null)
		cx.stroke()

		cx.restore()
	}
}

let PLAN_ID     = ui.S-1
let PLAN_STRUCT = ui.S+0

ui.box_widget('plan', {

	create: function(cmd, id, fr, align, valign, min_w, min_h, plan) {

		let ps = plan.ext_walls

		let [dstate, dx, dy] = ui.drag(id)

		let hs = ui.hovers(id)
		let cs = ui.captured(id)
		let cursors = {x: 'ew-resize', y: 'ns-resize'}

		if (dstate == 'hover') {
			let side = hs.get('side')
			if (side)
				ui.set_cursor(cursors[side])
			let opening = hs.get('opening')
			if (opening) {
				ui.set_cursor('move')
			}
		}
		if (dstate == 'drag') {
			let side = hs.get('side')
			if (side) {
				let pi   = hs.get('pi')
				let pi0  = hs.get('pi0')
				ui.set_cursor(cursors[side])
				cs.set('side', side)
				cs.set('pi'  , pi)
				cs.set('pi0' , pi0)
				cs.set('px0' , ps[pi][0])
				cs.set('py0' , ps[pi][1])
				cs.set('rs'  , moving_ranges(plan, pi0))
			}
			let opening = hs.get('opening')
			if (opening) {
				cs.set('opening', opening)
			}
		}
		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {
			let side = cs.get('side')
			if (side) {
				let pi   = cs.get('pi')
				let pi0  = cs.get('pi0')
				let rs   = cs.get('rs')
				ui.set_cursor(cursors[side])
				let X = side == 'x' ? 0 : 1
				let dX = X ? dy : dx
				let pX = cs.get(X ? 'py0' : 'px0') + dX
				let r = rs[0]
				pX = clamp(pX, r[0], r[1])
				ps[pi0][X] = pX
				ps[pi ][X] = pX
			}
			let opening = cs.get('opening')
			if (opening) {
				//
			}
		}

		return ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
				id, plan
			)
	},

	draw: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+PLAN_ID]
		let plan = a[i+PLAN_STRUCT]
		let ps = plan.ext_walls

		let hs = ui.hit(id)

		let cx = ui.cx

		cx.beginPath()

		cx.translate(x00, y00)

		draw_walls(cx, plan, ps, hs)
		draw_openings(cx, plan, hs)

		cx.translate(-x00, -y00)

	},

	hit: function(a, i) {

		let x00 = a[i+0]
		let y00 = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+PLAN_ID]
		let plan = a[i+PLAN_STRUCT]
		let ps = plan.ext_walls

		let hs = ui.hovers(id)
		let cs = ui.captured(id)

		if (!cs) {

			for (let op of plan.openings) {
				let [x, y, w, h, angle] = opening_rect(plan, op)
				if (ui.hit_rect(x00 + x, y00 + y, w, h)) {
					let hs = ui.hover(id)
					hs.set('opening', op)
					return
				}
			}

			let n = ps.length
			let x0 = x00 + ps[n-1][0] + .5
			let y0 = y00 + ps[n-1][1] + .5
			for (let i = 0; i < n; i++) {
				let x = x00 + ps[i][0] + .5
				let y = y00 + ps[i][1] + .5
				if (x0 == x) { // vert
					if (abs(ui.mx - x) < 5 && ui.my >= min(y, y0) && ui.my <= max(y, y0)) {
						let hs = ui.hover(id)
						hs.set('pi' , i)
						hs.set('pi0', mod(i-1, n))
						hs.set('side', 'x')
					}
				} else if (y0 == y) { // horiz
					if (abs(ui.my - y) < 5 && ui.mx >= min(x, x0) && ui.mx <= max(x, x0)) {
						let hs = ui.hover(id)
						hs.set('pi' , i)
						hs.set('pi0', mod(i-1, n))
						hs.set('side', 'y')
					}
				}
				x0 = x
				y0 = y
			}

		}

	},

})

let plan = {
	ext_walls: [[0, 0], [100, 0], [100, 100], [200, 100], [200, 200], [100, 200], [100, 300], [0, 300]],
	ext_wall_thickness: 5,
	int_walls: [
		{},
		{},
	],
	openings: [
		{wall: 7, d: 50, w: 150, type: 'window'},
		{wall: 6, d: 20, w:  50, type: 'door'},
		{w: 30, type: 'window', x: 500, y: 500, w: 40},
	],
}

ui.main = function() {

	ui.m(100)
	ui.v()
		ui.plan('p1', 1, null, null, null, null, plan)
	ui.end_v()

}

</script>
</body>
</html>
