<!DOCTYPE html>
<html theme=dark>
<body>
<base href="www2/">
<link rel="preload" href="fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="fa-solid-900.woff2"   as="font" type="font/woff2" crossorigin>
<script src=glue.js global extend></script>
<script src=ui.js></script>
<script src=ui_validation.js></script>
<script src=ui_nav.js></script>
<script src=ui_grid.js></script>
<script>

function wall_x(a, i) {
	let vert = i & 1
	return a[mod(i-2+vert, a.length)]
}

function wall_y(a, i) {
	let vert = i & 1
	return a[mod(i-1-vert, a.length)]
}

function wall_X(a, i) { return a[mod(i  , a.length)] }
function wall_Y(a, i) { return a[mod(i-1, a.length)] }

function wall_set_X(a, i, v) { a[mod(i  , a.length)] = v }
function wall_set_Y(a, i, v) { a[mod(i-1, a.length)] = v }

function wall_point_direct(a, i) {
	let vert = i & 1
	let n = a.length
	let ix = mod(i-2+vert, n)
	let iy = mod(i-1-vert, n)
	return [a[ix], a[iy]]
}

function wall_line(a, i) { // points in draw order
	let vert = i & 1
	let n = a.length
	let ix1 = mod(i-2+vert, n)
	let iy1 = mod(i-1-vert, n)
	let ix2 = mod(i+0-vert, n)
	let iy2 = mod(i-1+vert, n)
	return [a[ix1], a[iy1], a[ix2], a[iy2]]
}

function wall_vert  (a, i) { return i & 1 }
function wall_horiz (a, i) { return 1-(i & 1) }

function wall_sign(a, i) {
	let n = a.length
	let iX1 = mod(i-2, n)
	let iX2 = mod(i+0, n)
	return sign(a[iX2] - a[iX1])
}

function wall_point(a, i, o) {
	let p = wall_point_direct(a, i)
	if (!o)
		return p
	let h1 = wall_horiz(a, i)
	let s1 = wall_sign (a, i+0)
	let s0 = wall_sign (a, i-1)
	let ox = 0
	let oy = 0
	if (s1 == s0) {
		ox =  s1
		oy = -s1
	} else {
		ox = (s1 < s0) == h1 ? 1 : -1
		oy = ox
	}
	p[0] += ox * o
	p[1] += oy * o
	return p
}

function wall_offset_sign(a, i) {
	let h = wall_horiz(a, i)
	let s = wall_sign (a, i)
	return h ? -s : s
}

function overlap_segs(_a1, _a2, _b1, _b2) {
	let a1 = min(_a1, _a2)
	let a2 = max(_a1, _a2)
	let b1 = min(_b1, _b2)
	let b2 = max(_b1, _b2)
	return !(a2 <= b1 || b2 <= a1)
}

function wall_lines(a, i, o) { // lines in screen order, points in draw order
	let p1  = wall_point(a, i+0)
	let p2  = wall_point(a, i+1)
	let op1 = wall_point(a, i+0, o)
	let op2 = wall_point(a, i+1, o)
	if (wall_offset_sign(a, i) < 0)
		return [op1, op2, p1, p2]
	else
		return [p1, p2, op1, op2]
}

function wall_rect(a, i, o) {
	let p1  = wall_point(a, i+0)
	let p2  = wall_point(a, i+1)
	let op1 = wall_point(a, i+0, o)
	let op2 = wall_point(a, i+1, o)
	let h   = wall_horiz(a, i)
	let X = h ? 0 : 1
	let Y = h ? 1 : 0
	let r = [0, 0, 0, 0]
	r[X+0] = min(p1[X], op1[X], p2[X], op2[X])
	r[X+2] = max(p1[X], op1[X], p2[X], op2[X])
	r[Y+0] = min(p1[Y], op1[Y])
	r[Y+2] = max(p1[Y], op1[Y])
	return r
}

function opening_rect(plan, op) {
	let t = plan.ext_wall_thickness
	let r = [op.sx, op.sy || 0, op.w, t, 0]
	let a = plan.ext_walls
	if (op.wall != null) {
		let p1    = wall_point       (a, op.wall)
		let horiz = wall_horiz       (a, op.wall)
		let dir   = wall_sign        (a, op.wall)
		let odir  = wall_offset_sign (a, op.wall)
		let X = horiz ? 0 : 1
		let Y = horiz ? 1 : 0
		r[X] = p1[X] + (dir > 0 ? op.d : -(op.d + op.w))
		r[Y] = p1[Y] + (odir > 0 ? 0 : -t)
		if (!horiz) {
			r[4] = 90 * rad
			r[0] += t
		}
	}
	return r
}

function opening_face_rect(plan, op) {
	let t = plan.ext_wall_thickness
	let r = [op.x, plan.h - op.h - (op.y || 0), op.w, op.h]
	let a = plan.ext_walls
	if (op.wall != null) {
		let p1    = wall_point       (a, op.wall)
		let horiz = wall_horiz       (a, op.wall)
		let dir   = wall_sign        (a, op.wall)
		let odir  = wall_offset_sign (a, op.wall)
		let X = 1-horiz
		let Y = horiz
		r[0] = p1[X] + (dir > 0 ? op.d : -(op.d + op.w))
	}
	return r
}

function moving_ranges(plan, ti1) {
	let o = plan.ext_wall_thickness
	let a = plan.ext_walls
	let n = a.length
	let ti0 = mod(ti1-1, n)
	let ti2 = mod(ti1+1, n)
	let p1 = wall_point(a, ti1)
	let p2 = wall_point(a, ti2)
	let h = wall_horiz(a, ti1)
	let X = h ? 0 : 1
	let Y = h ? 1 : 0
	let tl = wall_lines(a, ti1, o)

	// collision with walls
	let rangeY = [-1/0, 1/0]
	for (let i1 = 0; i1 < n; i1++) {
		if (i1 == ti1 || i1 == ti0 || i1 == ti2)
			continue
		let r = wall_rect(a, i1, o)

		if (r[Y+2] <= tl[0][Y]) // rect bottom side < top of the wall
			if (overlap_segs(tl[0][X], tl[1][X], r[X], r[X+2])) {
				let minY = r[Y+2]+1
				if (tl[0][Y] < p1[Y]) // offset side up
					minY += o
				rangeY[0] = max(rangeY[0], minY)
			}

		if (r[Y+0] >= tl[2][Y]) // rect top side > bottom of the wall
			if (overlap_segs(tl[2][X], tl[3][X], r[X], r[X+2])) {
				let maxY = r[Y+0]-1
				if (tl[2][Y] > p1[Y]) // offset side down
					maxY -= o
				rangeY[1] = min(rangeY[1], maxY)
			}

	}
	return [rangeY]
}

function draw_walls(cx, plan, a, hs) {

	let n = a.length

	cx.beginPath()

	// draw offset path clockwise.
	for (let i = 0; i < n; i++) {
		let [x, y] = wall_point(a, i, plan.ext_wall_thickness)
		if (i == 0)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()

	// draw inner path counterclockwise.
	for (let i = n-1; i >= 0; i--) {
		let x = wall_x(a, i)
		let y = wall_y(a, i)
		if (i == n-1)
			cx.moveTo(x, y)
		else
			cx.lineTo(x, y)
	}
	cx.closePath()

	cx.lineWidth = 1
	//cx.strokeStyle = ui.fg_color('text')
	cx.fillStyle = ui.bg_color('bg3')
	cx.fill()
}

function draw_openings(cx, plan, a, hs) {
	for (let op of plan.openings) {
		let [x, y, w, h, rotation] = opening_rect(plan, op)

		cx.save()
		cx.translate(x, y)
		cx.rotate(rotation)

		cx.beginPath()
		cx.rect(0, 0, w, h)
		cx.fillStyle = ui.bg_color('bg')
		cx.fill()

		if (op.type == 'window') {
			cx.beginPath()
			cx.rect(.5, .5 - 4, w, h + 4)
			cx.moveTo(.5, .5 + round(h / 3))
			cx.lineTo(.5 + w, .5 + round(h / 3))
		} else if (op.type == 'door') {
			cx.beginPath()
			cx.arc(.5, .5 + round(h / 2), .5 + w, 0, 90 * rad)
			cx.lineTo(.5, .5 + round(h / 2))
		}
		cx.strokeStyle = ui.fg_color('text', hs && hs.get('opening') == op ? 'hover' : null)
		cx.stroke()

		cx.restore()
	}
}

function draw_facade(cx, plan, a, horiz, sign, hs) {

	// sort walls by depth.
	let walls = []
	for (let i = 0, n = a.length; i < n; i++) {
		if (wall_horiz(a, i) != horiz)
			continue
		if (wall_sign(a, i) != sign)
			continue
		walls.push(i)
	}
	walls.sort(function(i1, i2) {
		let y1 = wall_Y(a, i1)
		let y2 = wall_Y(a, i2)
		return y1 < y2 ? sign : y1 > y2 ? -sign : 0
	})

	// draw walls in depth order.
	let X = horiz ? 0 : 1
	let Y = horiz ? 1 : 0
	for (let i of walls) {
		let t = plan.ext_wall_thickness
		let p1 = wall_point(a, i+0, t)
		let p2 = wall_point(a, i+1, t)
		let x1 = p1[X]
		let x2 = p2[X]
		let x = min(x1, x2)
		let w = max(x1, x2) - x
		let y = p1[Y]
		let h = plan.h

		cx.beginPath()
		cx.rect(x, 0, w, h)
		cx.fillStyle = ui.hsl_adjust(ui.bg_color_hsl('bg3'), 1, 1, p1[Y] / 500)
		cx.fill()

		cx.beginPath()
		cx.rect(x + .5, .5, w, h)
		cx.strokeStyle = ui.fg_color('text')
		cx.stroke()

		// draw openings.
		for (let op of plan.openings) {
			if (op.wall != i)
				continue

			let [x, y, w, h] = opening_face_rect(plan, op)

			cx.save()
			cx.translate(x, y)

			cx.beginPath()
			cx.rect(0, 0, w, h)
			cx.fillStyle = ui.bg_color('bg')
			cx.fill()

			if (op.type == 'window') {
				cx.beginPath()
				cx.rect(.5, .5, w, h)
			} else if (op.type == 'door') {
				cx.beginPath()
				cx.rect(.5, .5, w, h)
			}
			cx.strokeStyle = ui.fg_color('text', hs && hs.get('opening') == op ? 'hover' : null)
			cx.stroke()

			cx.restore()
		}

	}

}

let PLAN_ID     = ui.S-1
let PLAN_STRUCT = ui.S+0

ui.box_widget('plan', {

	create: function(cmd, id, fr, align, valign, min_w, min_h, plan) {

		let a = plan.ext_walls

		let [dstate, dx, dy] = ui.drag(id)

		let hs = ui.hovers(id)
		let cs = ui.captured(id)
		let cursors = {x: 'ew-resize', y: 'ns-resize'}

		if (dstate == 'hover') {
			let side = hs.get('side')
			if (side)
				ui.set_cursor(cursors[side])
			let opening = hs.get('opening')
			if (opening) {
				ui.set_cursor('move')
			}
		}
		if (dstate == 'drag') {
			let side = hs.get('side')
			if (side) {
				let pi = hs.get('pi')
				ui.set_cursor(cursors[side])
				cs.set('side', side)
				cs.set('pi'  , pi)
				cs.set('px0' , wall_x(a, pi))
				cs.set('py0' , wall_y(a, pi))
				cs.set('rs'  , moving_ranges(plan, pi))
			}
			let opening = hs.get('opening')
			if (opening) {
				cs.set('opening', opening)
			}
		}
		if (dstate == 'drag' || dstate == 'dragging' || dstate == 'drop') {
			let side = cs.get('side')
			if (side) {
				let pi = cs.get('pi')
				let rs = cs.get('rs')
				ui.set_cursor(cursors[side])
				let X = side == 'x' ? 0 : 1
				let dX = X ? dy : dx
				let pX = cs.get(X ? 'py0' : 'px0') + dX
				let r = rs[0]
				pX = clamp(pX, r[0], r[1])
				wall_set_X(a, pi-1, pX)
			}
			let opening = cs.get('opening')
			if (opening) {
				//
			}
		}

		return ui.cmd_box(cmd, fr, align, valign, min_w, min_h,
				id, plan
			)
	},

	draw: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+PLAN_ID]
		let plan = a[i+PLAN_STRUCT]
		let ps = plan.ext_walls

		let hs = ui.hit(id)

		let cx = ui.cx

		cx.beginPath()

		cx.translate(x00, y00)

		draw_walls(cx, plan, ps, hs)
		draw_openings(cx, plan, hs)

		cx.translate(0,  500)
		draw_facade(cx, plan, ps, 1, -1, hs)
		cx.translate(0, -500)

		cx.translate(0,  600)
		draw_facade(cx, plan, ps, 1, 1, hs)
		cx.translate(0, -600)

		cx.translate( 500, 0)
		draw_facade(cx, plan, ps, 0, 1, hs)
		cx.translate(-500, 0)

		cx.translate(500 ,  100)
		draw_facade(cx, plan, ps, 0, -1, hs)
		cx.translate(-500, -100)

		cx.translate(-x00, -y00)

	},

	hit: function(a, i) {

		let x00  = a[i+0]
		let y00  = a[i+1]
		let w    = a[i+2]
		let h    = a[i+3]
		let id   = a[i+PLAN_ID]
		let plan = a[i+PLAN_STRUCT]
		let ps = plan.ext_walls

		let hs = ui.hovers(id)
		let cs = ui.captured(id)

		if (!cs) {

			for (let op of plan.openings) {
				let [x, y, w, h, angle] = opening_rect(plan, op)
				if (ui.hit_rect(x00 + x, y00 + y, w, h)) {
					let hs = ui.hover(id)
					hs.set('opening', op)
					return
				}
			}

			let n = ps.length
			for (let i = 0; i < n; i++) {
				let x  = x00 + wall_x(ps, i+0) + .5
				let y  = y00 + wall_y(ps, i+0) + .5
				let x2 = x00 + wall_x(ps, i+1) + .5
				let y2 = y00 + wall_y(ps, i+1) + .5
				if (x2 == x) { // vert
					if (abs(ui.mx - x) < 5 && ui.my >= min(y, y2) && ui.my <= max(y, y2)) {
						let hs = ui.hover(id)
						hs.set('pi', i)
						hs.set('side', 'x')
					}
				} else if (y2 == y) { // horiz
					if (abs(ui.my - y) < 5 && ui.mx >= min(x, x2) && ui.mx <= max(x, x2)) {
						let hs = ui.hover(id)
						hs.set('pi', i)
						hs.set('side', 'y')
					}
				}
			}

		}

	},

})

let plan = {
	h: 80,
	ext_walls: [100, 100, 200, 200, 100, 300, 150, 400, 0, 0],
	ext_wall_thickness: 5,
	int_walls: [
		{},
		{},
	],
	openings: [
		{wall: 9, d: 50, w: 150, type: 'window', h: 50, y: 20},
		{wall: 8, d: 20, w:  50, type: 'door', h: 70},
		{type: 'window', sx: 700, sy: 700, w: 100, h: 70, y: 20},
	],
}

ui.main = function() {

	ui.m(100)
	ui.v()
		ui.plan('p1', 1, null, null, null, null, plan)
	ui.end_v()

}

</script>
</body>
</html>
